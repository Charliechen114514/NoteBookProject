# C++ STL 容器与算法

###  `vector` 和 `list` 异同 

`std::vector` 和 `std::list` 是 C++ STL 中两种非常常用的序列容器，它们在底层实现、内存管理和性能特性上有着显著的区别，适用于不同的场景。

**相同点：**

- **序列容器：** 它们都属于序列容器，意味着它们的元素都以严格的线性顺序排列，并且可以通过位置（或迭代器）访问。
- **支持迭代器：** 都可以使用迭代器进行遍历和元素访问（尽管迭代器的类型和功能有所不同）。
- **元素类型要求：** 存储的元素类型都必须是可复制构造和可赋值的（C++11 后，对于移动语义，还需要可移动构造和可移动赋值）。

**不同点：**

| 特性           | `std::vector`                                                | `std::list`                                                  |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **底层实现**   | **动态数组 (Dynamic Array)**。元素存储在连续的内存块中。     | **双向链表 (Doubly Linked List)**。每个元素包含数据和前后节点的指针。 |
| **内存分配**   | **连续存储**。当容量不足时，会重新分配更大的内存，并将旧元素复制/移动到新内存区域。 | **非连续存储**。每个元素独立分配内存。                       |
| **随机访问**   | **支持**。通过 `[]` 运算符或 `at()` 方法，时间复杂度为 **O(1)**。 | **不支持**。只能通过遍历实现，时间复杂度为 **O(N)**。        |
| **插入/删除**  | **中间插入/删除效率低**：需要移动后续所有元素，时间复杂度为 **O(N)**。   **末尾插入/删除效率高**：均摊 **O(1)** (仅当不触发扩容时为 O(1))。 | **插入/删除效率高**：一旦找到插入/删除点，只需修改少数指针，时间复杂度为 **O(1)**。   **头尾插入/删除效率高**：均为 **O(1)**。 |
| **缓存局部性** | **好**。由于连续存储，数据访问具有良好的缓存局部性，CPU 缓存命中率高。 | **差**。元素分散存储，数据访问的缓存局部性差，CPU 缓存命中率低。 |
| **内存开销**   | 较小，除数据外仅需存储容量和大小信息。可能存在少量空间浪费（当实际大小小于容量时）。 | 较大，每个元素除了数据外还需要存储两个指针（前向和后向），额外开销通常为 8-16 字节/元素。 |
| **迭代器失效** | **易失效**。插入/删除元素可能导致迭代器失效，尤其是扩容或在中间插入/删除时。 | **不易失效**。插入/删除操作只影响局部指针，不会使其他元素的迭代器失效（除非删除当前迭代器指向的元素）。 |
| **元素访问**   | 适用于通过索引进行随机访问的场景。                           | 适用于频繁在任意位置进行插入和删除的场景。                   |

**总结：**

- **`vector`** 更适合**读多写少**、需要**随机访问**、且元素总数变化**不频繁**或仅在**末尾操作**的场景。
- **`list`** 更适合**写多读少**、需要**频繁在任意位置插入/删除**、且不要求随机访问的场景。

------



###  `vector` 内存是怎么增长的，`vector` 的底层实现⭐⭐⭐⭐



`std::vector` 的底层实现是一个**动态数组**。它的内存增长策略是其性能特性的关键。

**`vector` 的底层实现：**

`std::vector` 的核心是一个**指向连续内存块的指针**，以及两个额外的信息：

1. **`size` (大小)：** 当前已存储的元素数量。
2. **`capacity` (容量)：** 当前已分配的内存块能够容纳的元素总数。

其内部通常维护着一个指针 `T* data`，指向其数据存储的起始地址；一个 `size_t current_size` 记录当前元素个数；一个 `size_t current_capacity` 记录当前能容纳的最大元素个数。

**`vector` 内存增长机制：**

当 `vector` 的 `size` 达到其 `capacity`（即当前分配的内存块已满），并且需要插入新元素时，`vector` 必须进行**扩容 (reallocation)**。这个扩容过程通常遵循以下步骤：

1. **判断扩容时机：** 当 `size == capacity` 且有新元素需要插入时，就会触发扩容。
2. **分配新内存：** `vector` 会在堆上分配一块**新的、更大**的连续内存块。新的容量通常是旧容量的**两倍**（或 1.5 倍，取决于具体的 STL 实现和编译器）。
3. **复制/移动元素：** 将旧内存区域中的所有元素**复制**（或在 C++11 及其以后版本中，如果元素类型支持**移动语义**，则进行**移动**）到新的内存区域。移动操作通常比复制效率更高，因为它避免了深拷贝。
4. **释放旧内存：** 释放旧的内存块，使其可以被系统回收。
5. **更新内部状态：** 更新 `vector` 内部的指针，使其指向新的内存区域，并更新 `capacity` 的值。

**内存增长策略的优点和缺点：**

- **优点：**
  - **均摊 O(1) 复杂度：** 虽然单次扩容操作的开销是 O(N)（N 为元素数量），但由于每次扩容都将容量翻倍（或增加固定比例），因此在一系列 `push_back` 操作中，每个元素的平均插入成本（均摊复杂度）是 O(1)。这样，即使需要多次扩容，总的性能仍然很高。
  - **良好的缓存局部性：** 元素存储在连续内存中，有利于 CPU 缓存的命中，提高数据访问速度。
  - **高效的随机访问：** 通过指针算术即可直接访问任意元素，O(1) 复杂度。
- **缺点：**
  - **扩容开销：** 扩容时涉及内存重新分配和大量元素的复制/移动，这是一个开销较大的操作，尤其对于包含复杂对象的 `vector`。频繁扩容会导致性能下降。
  - **迭代器失效：** 扩容会导致 `vector` 内部存储地址的改变，因此所有指向旧内存区域的迭代器、指针和引用都会失效。这是使用 `vector` 时需要特别注意的地方。
  - **内存浪费：** 实际使用的内存（`size`）可能小于分配的容量（`capacity`），存在一定的内存浪费。

为了避免频繁扩容，可以使用 `reserve()` 方法预先分配足够的内存。

###  `vector` 和 `deque` 的比较 

| 特性              | `std::vector`                                         | `std::deque`                                                 |
| ----------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| **底层实现**      | **动态数组**。单个连续的内存块。                      | **分段连续的动态数组**。通常由一个控制块（如数组或链表）管理多个固定大小的内存块（段）。 |
| **内存分配**      | **连续存储**。扩容时可能发生数据复制/移动。           | **非连续存储（逻辑上连续）**。每个段内连续，但段与段之间不连续。插入新元素时，可能分配新段。 |
| **随机访问**      | **支持**。O(1) 时间复杂度。                           | **支持**。O(1) 时间复杂度，但比 `vector` 略慢（需要两次解引用：先找到段，再找到段内偏移）。 |
| **头部插入/删除** | **效率低**。需要移动所有元素，O(N)。                  | **效率高**。O(1)，只需调整指针或分配新段。                   |
| **尾部插入/删除** | **效率高**。均摊 O(1) (不触发扩容时为 O(1))。         | **效率高**。O(1)，只需调整指针或分配新段。                   |
| **中间插入/删除** | **效率低**。O(N)。                                    | **效率低**。O(N)，因为仍需移动段内元素。通常比 `vector` 略快，因为只移动段内的元素，而不是整个容器。 |
| **缓存局部性**    | **好**。元素连续存储，缓存命中率高。                  | **较差**。元素在不同段中分散，缓存命中率低于 `vector`。      |
| **迭代器失效**    | **易失效**。插入/删除可能导致扩容，使所有迭代器失效。 | **头部/尾部插入/删除不会使现有迭代器失效** (除非删除迭代器指向的元素)。中间插入/删除仍可能使迭代器失效。 |
| **内存开销**      | 较小。                                                | 较大，需要额外的开销来管理分段的内存块（控制块和每个段的开销）。 |

**选择建议：**

- **使用 `std::vector`：**
  - 当需要大量随机访问，并且主要在末尾进行插入/删除操作时。
  - 对缓存局部性有较高要求时。
  - 当容器中的元素数量相对稳定或只在末尾增长时。
- **使用 `std::deque`：**
  - 当需要频繁在**两端**进行插入和删除操作时。
  - 对随机访问性能要求较高，但同时需要在两端高效操作时。
  - 当元素数量会频繁变化，且不希望发生整个容器内存重新分配时。
  - 在内存非常紧张的嵌入式系统，或需要严格控制内存分配次数的场景，`deque` 可能因为其分段分配策略而更可预测。

### 为什么 STL 里面有 `sort` 函数，`list` 里面还要再定义一个 `sort`

这是一个非常经典的问题，揭示了 STL 算法和容器设计哲学以及它们的底层特性。

**原因：`std::sort` 对迭代器类型有要求，而 `std::list` 的迭代器不满足要求。**

1. **`std::sort` 算法的要求：**
   - `std::sort` 是一个**通用算法**，定义在 `<algorithm>` 头文件中。
   - 它要求其操作的迭代器必须是**随机访问迭代器 (Random Access Iterator)**。
   - 随机访问迭代器支持：
     - `*iter` (解引用)
     - `++iter`, `--iter` (递增/递减)
     - `iter + n`, `iter - n` (跳跃式移动，O(1) 复杂度)
     - `iter1 - iter2` (计算距离，O(1) 复杂度)
     - `<, >, <=, >=` (比较大小)
   - `std::sort` 的实现通常是基于像**快速排序 (Quicksort)** 或**内省排序 (Introsort)** 这样的算法。这些算法的核心操作是元素的随机访问和交换（例如，随机选择枢轴，或者在数组的任意两个位置交换元素）。
2. **`std::list` 的迭代器类型：**
   - `std::list` 的底层是**双向链表**。
   - `std::list` 的迭代器是**双向迭代器 (Bidirectional Iterator)**。
   - 双向迭代器只支持：
     - `*iter` (解引用)
     - `++iter`, `--iter` (递增/递减)
     - **不支持**跳跃式移动 (`iter + n`) 或计算距离 (`iter1 - iter2`)。这意味着，要访问第 `n` 个元素，必须从头开始遍历 `n` 次，时间复杂度是 O(N)。
   - 因此，`std::list` 的迭代器**不满足 `std::sort` 所需的随机访问能力**。如果强行用 `std::sort` 对 `list` 进行排序，那么随机访问操作会变成 O(N)，导致整个排序算法的复杂度从 O(N log N) 恶化为 O(N^2)，性能非常差。
3. **`std::list::sort()` 成员函数：**
   - 由于通用 `std::sort` 不适用于 `list`，`std::list` 为了提供排序功能，在它自己的成员函数中实现了一个专用的 `sort()` 方法。
   - `std::list::sort()` 的实现通常是基于**归并排序 (Merge Sort)**。
   - **归并排序的特点：** 归并排序只需要双向迭代器，因为它只涉及元素的比较、移动和合并操作，而无需随机访问。它通过将链表拆分成小段，排序后合并来实现。
   - **时间复杂度：** 归并排序的时间复杂度为 O(N log N)，对于链表来说是高效的。

std::sort 和 std::list::sort() 采用了不同的排序算法，以适应它们各自底层数据结构的特性。std::sort 利用了数组的随机访问优势（O(1)），而 std::list::sort() 则利用了链表的方便插入/删除优势（O(1)），并避免了随机访问的低效（O(N)）。这种设计体现了 STL 的泛型编程思想，以及根据数据结构特性选择最优化算法的原则。

------



### STL 底层数据结构实现

STL (Standard Template Library) 提供了多种容器、算法和迭代器，它们底层的实现机制是理解其性能和使用场景的关键。

**1. 序列容器 (Sequence Containers)：**

- **`std::vector`：**
  - **底层：** **动态数组 (Dynamic Array)**。
  - **特点：** 元素在内存中**连续存储**。支持快速随机访问 (O(1))，尾部插入/删除均摊 O(1)，中间插入/删除 O(N)。扩容时涉及内存重新分配和元素复制/移动，可能导致迭代器失效。缓存局部性好。
- **`std::deque` (双端队列)：**
  - **底层：** **分段的动态数组 (Array of fixed-size arrays)**。通常由一个映射数组 (map) 管理多个固定大小的内存块（段）。
  - **特点：** 逻辑上连续，物理上不一定连续。支持快速随机访问 (O(1)，但比 vector 略慢)，两端插入/删除 O(1)，中间插入/删除 O(N)。头部和尾部操作不会使迭代器失效，但中间操作可能导致失效。缓存局部性不如 `vector`。
- **`std::list`：**
  - **底层：** **双向链表 (Doubly Linked List)**。每个节点包含数据和两个指针（前驱和后继）。
  - **特点：** 元素在内存中**非连续存储**。不支持随机访问 (O(N))。任意位置插入/删除 O(1) (前提是已获得迭代器)。插入/删除操作不会使其他迭代器失效（除非删除自身）。缓存局部性差。
- **`std::forward_list` (C++11 新增)：**
  - **底层：** **单向链表 (Singly Linked List)**。
  - **特点：** 只支持单向遍历。比 `std::list` 更省内存（少一个指针），但在某些操作上（如删除前一个元素）会更复杂。

**2. 容器适配器 (Container Adapters)：**

- **`std::stack` (栈)：**
  - **底层：** 默认使用 `std::deque`，也可以适配 `std::vector` 或 `std::list`。
  - **特点：** 后进先出 (LIFO)。只提供 `push`, `pop`, `top` 等操作。
- **`std::queue` (队列)：**
  - **底层：** 默认使用 `std::deque`，也可以适配 `std::list`。
  - **特点：** 先进先出 (FIFO)。只提供 `push`, `pop`, `front`, `back` 等操作。
- **`std::priority_queue` (优先队列)：**
  - **底层：** 默认使用 `std::vector`。
  - **特点：** 基于**堆 (Heap)** 数据结构实现（通常是大顶堆），保证队首元素是优先级最高的。每次插入和删除的时间复杂度为 O(log N)。

**3. 关联容器 (Associative Containers)：**

- **`std::map` 和 `std::multimap`：**
  - **底层：** **红黑树 (Red-Black Tree)**。
  - **特点：** 自动按键排序。`map` 键唯一，`multimap` 键可以重复。插入、删除、查找的平均和最坏时间复杂度都是 **O(log N)**。
- **`std::set` 和 `std::multiset`：**
  - **底层：** **红黑树 (Red-Black Tree)**。
  - **特点：** 存储的只是键，不存储值。`set` 键唯一，`multiset` 键可以重复。插入、删除、查找的平均和最坏时间复杂度都是 **O(log N)**。

**4. 无序关联容器 (Unordered Associative Containers) (C++11 新增)：**

- **`std::unordered_map` 和 `std::unordered_multimap`：**
  - **底层：** **哈希表 (Hash Table)**。
  - **特点：** 不保持键的顺序。`unordered_map` 键唯一，`unordered_multimap` 键可以重复。插入、删除、查找的**平均时间复杂度为 O(1)**，**最坏情况下为 O(N)**（哈希冲突严重时）。
- **`std::unordered_set` 和 `std::unordered_multiset`：**
  - **底层：** **哈希表 (Hash Table)**。
  - **特点：** 存储的只是键。`unordered_set` 键唯一，`unordered_multiset` 键可以重复。插入、删除、查找的**平均时间复杂度为 O(1)**，**最坏情况下为 O(N)**。

**5. 迭代器 (Iterators)：**

- 迭代器是泛型编程的核心，它们提供了一种统一的访问容器元素的方式，类似于指针。
- 根据底层容器的特性，迭代器分为五种类型：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。不同类型的迭代器支持不同的操作，例如只有随机访问迭代器支持 `+` 和 `-` 运算符。

理解这些底层实现对于正确选择容器、优化代码性能和避免常见问题（如迭代器失效）至关重要。

### 利用迭代器删除元素会发生什么？



当使用迭代器删除 STL 容器中的元素时，不同的容器类型会有不同的行为，特别是关于**迭代器失效 (Iterator Invalidation)** 的问题。迭代器失效意味着之前有效的迭代器、指针或引用不再指向有效或预期的内存位置。

**1. `std::vector`：**

- **删除单个元素 (`erase(iterator pos)`)：**

  - **`pos` 及 `pos` 之后的所有迭代器都会失效。** 这是因为 `vector` 删除元素后，会将删除点之后的所有元素向前移动以填补空缺，这改变了这些元素的内存地址。

  - **返回新的有效迭代器：** `erase` 函数会返回一个指向被删除元素之后的新位置的迭代器，这个新迭代器是有效的。你应该使用这个返回的迭代器继续操作。

  - **示例：**

    ```
    std::vector<int> v = {1, 2, 3, 4, 5};
    auto it = v.begin() + 2; // 指向 3
    it = v.erase(it);        // 删除 3，it 现在指向新的 3 (原 4 的位置)
    // 此时，任何之前指向 4 或 5 的迭代器都失效了
    ```

- **删除范围元素 (`erase(iterator first, iterator last)`)：**

  - `last` 及其之后的所有迭代器都会失效。`erase` 返回一个指向 `last` 位置之后的新迭代器。

- **头部插入 (`insert(begin(), value)`)：**

  - **所有迭代器都会失效。** 因为可能发生扩容，导致整个 `vector` 的内存重新分配。即使不扩容，也需要移动所有元素。

- **中间插入 (`insert(pos, value)`)：**

  - `pos` 及 `pos` 0之后的所有迭代器都会失效。也可能发生扩容，导致所有迭代器失效。

- **尾部插入 (`push_back()`)：**

  - **可能导致所有迭代器失效。** 当 `vector` 容量不足发生扩容时，会使所有迭代器失效。如果未扩容，则迭代器保持有效（除了 `end()` 迭代器）。

**2. `std::list` (和 `std::forward_list`)：**

- **删除单个元素 (`erase(iterator pos)`)：**

  - **只有被删除元素 `pos` 对应的迭代器会失效。** 其他元素的迭代器（包括 `pos` 之前和之后的）仍然有效。

  - **返回新的有效迭代器：** `erase` 函数会返回一个指向被删除元素之后的新位置的迭代器。

  - **示例：**

    ```
    std::list<int> l = {1, 2, 3, 4, 5};
    auto it = l.begin();
    std::advance(it, 2); // it 指向 3
    auto next_it = l.erase(it); // 删除 3，next_it 指向 4
    // 此时，指向 1, 2, 4, 5 的迭代器都仍然有效
    ```

- **插入 (`insert()`)：**

  - 插入操作不会使任何现有迭代器失效。新插入的元素会返回一个有效的迭代器。

**3. `std::deque`：**

- **删除单个元素 (`erase(iterator pos)`)：**
  - `pos` 及 `pos` 之后的所有迭代器会失效。
  - **`pos` 之前的迭代器仍然有效。** 这是因为 `deque` 是分段存储的，删除操作只影响删除点及之后的数据段。
- **插入 (`insert()`)：**
  - 在两端插入（`push_front`, `push_back`）不会使任何现有迭代器失效（除了 `end()` 迭代器）。
  - 在中间插入会使 `pos` 及 `pos` 之后的所有迭代器失效。

**4. 关联容器 (`std::map`, `std::set`, `std::multimap`, `std::multiset`) 和 无序关联容器 (`std::unordered_map`, `std::unordered_set` 等)：**

- **删除单个元素 (`erase(iterator pos)`)：**

  - **只有被删除元素 `pos` 对应的迭代器会失效。** 其他元素的迭代器仍然有效。

  - **返回新的有效迭代器：** `erase` 函数会返回一个指向被删除元素之后的新位置的迭代器。

  - **示例：**

    ```
    std::map<int, std::string> m = {{1, "a"}, {2, "b"}, {3, "c"}};
    auto it = m.find(2); // it 指向 {2, "b"}
    auto next_it = m.erase(it); // 删除 {2, "b"}，next_it 指向 {3, "c"}
    // 此时，指向 {1, "a"} 的迭代器仍然有效
    ```

- **插入 (`insert()`)：**

  - 插入操作不会使任何现有迭代器失效。

**总结：**

了解迭代器失效规则对于编写健壮的 C++ 代码至关重要。在使用迭代器进行插入和删除操作时，**务必注意容器的特性**：

- 对于 `vector` 这种基于数组的容器，任何可能导致元素移动的操作（尤其是中间插入/删除和扩容）都会导致迭代器失效，需要重新获取或使用 `erase` 的返回值。
- 对于 `list` 和关联容器（如 `map`, `set`）这种基于链表或树的容器，插入/删除操作通常只会使受影响的少数迭代器失效，其他迭代器保持有效。

------



### `map` 是如何实现的，查找效率是多少



**`std::map` 的底层实现：**

`std::map` 在 C++ 标准库中通常是基于**红黑树 (Red-Black Tree)** 实现的。

红黑树的特性：

红黑树是一种自平衡的二叉查找树 (Self-Balancing Binary Search Tree)。它在每个节点中增加了一个颜色属性（红色或黑色），并通过以下规则来保证树的平衡性：

1. 每个节点不是红色就是黑色。
2. 根节点是黑色的。
3. 每个叶子节点（NIL 节点，空节点）是黑色的。
4. 如果一个节点是红色的，则它的子节点必须是黑色的（即不能有两个连续的红色节点）。
5. 从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。

通过这些规则，红黑树能够保证从根节点到任何叶子节点的最长路径不超过最短路径的两倍，从而确保了树的高度是平衡的，近似于 `log N`（N 为节点数）。

std::map 中键值对的存储：

在 std::map 中，每个节点存储一个 std::pair<const Key, Value>，其中 Key 用作排序依据，并且是不可修改的（因为修改键会破坏树的结构）。

**`map` 的查找效率：**

由于 `std::map` 是基于红黑树实现的，其查找效率（以及插入和删除效率）在**平均情况**和**最坏情况**下都是 **O(log N)**。

- **O(log N) 的含义：**
  - `N` 是 `map` 中元素的数量。
  - `log N` 代表树的高度。由于红黑树是平衡的，树的高度会随着元素数量的增加而对数级增长。
  - 这意味着，即使 `map` 中有大量的元素，查找（插入、删除）操作也只需要相对较少的比较次数，效率非常高。

为什么是 O(log N)？

在红黑树中查找一个元素，与在普通二叉查找树中查找类似：从根节点开始，根据待查找键与当前节点键的比较结果，选择向左子树或右子树遍历。由于树是平衡的，每次比较都能将搜索范围缩小一半，因此查找路径的长度（即比较次数）最多与树的高度成正比。红黑树的高度是 O(log N)，所以查找效率是 O(log N)。

总结：

std::map 通过红黑树实现了高效的键值对存储和检索，保证了查询、插入和删除操作的对数时间复杂度，使其成为需要保持元素有序且高效查找的场景的理想选择。

------



### 几种模板插入的时间复杂度

这里我们主要讨论 STL 几种常用容器的**插入操作**的时间复杂度。插入操作的时间复杂度通常取决于插入的位置和容器的底层数据结构。

**1. `std::vector`：** (动态数组)

- **`push_back(value)` (在末尾插入)：**
  - **均摊时间复杂度：O(1)**。
  - **最坏时间复杂度：O(N)** (当触发扩容时，需要重新分配内存并复制所有旧元素)。
  - **解释：** 大多数情况下，`push_back` 只是在已分配内存的末尾添加元素。当容量不足时，`vector` 会扩容，通常将容量翻倍，并将所有元素复制/移动到新内存。由于扩容是指数增长的，所以均摊下来每次 `push_back` 的开销是常数级别。
- **`insert(iterator pos, value)` (在任意位置插入)：**
  - **时间复杂度：O(N)**。
  - **解释：** 在 `pos` 处插入元素时，需要将 `pos` 之后的所有元素向后移动一个位置。如果触发扩容，还会额外增加内存分配和复制的开销。因此，无论是否扩容，都需要移动 O(N) 个元素。

**2. `std::deque`：** (分段动态数组，双端队列)

- **`push_back(value)` (在末尾插入)：**
  - **时间复杂度：O(1)**。
  - **解释：** `deque` 在两端插入时，如果当前段已满，它会分配一个新的段，并将新元素放入其中，无需移动现有元素。
- **`push_front(value)` (在头部插入)：**
  - **时间复杂度：O(1)**。
  - **解释：** 同 `push_back`，`deque` 会在前端分配新段来容纳新元素。
- **`insert(iterator pos, value)` (在任意位置插入)：**
  - **时间复杂度：O(N)**。
  - **解释：** 虽然 `deque` 是分段的，但在中间插入仍然需要移动 `pos` 所在段及其后续段（或者 `pos` 所在段及其前序段）中的元素，以保持逻辑上的连续性。平均而言，需要移动大约 N/2 个元素。

**3. `std::list`：** (双向链表)

- **`push_back(value)` (在末尾插入)：**
  - **时间复杂度：O(1)**。
  - **解释：** 只需在链表尾部创建一个新节点，并调整几个指针。
- **`push_front(value)` (在头部插入)：**
  - **时间复杂度：O(1)**。
  - **解释：** 只需在链表头部创建一个新节点，并调整几个指针。
- **`insert(iterator pos, value)` (在任意位置插入)：**
  - **时间复杂度：O(1)** (前提是已经获得指向 `pos` 的迭代器)。
  - **解释：** 链表的特点是，一旦找到要插入的位置，只需创建新节点并调整前后节点的指针，操作与元素数量无关。如果需要从头/尾遍历到 `pos`，那么这部分遍历的开销是 O(N)，但插入本身是 O(1)。

**4. `std::map` / `std::set` (及其 `multi` 版本)：** (红黑树)

- **`insert(key, value)` (或 `insert(value)` for set)：**
  - **时间复杂度：O(log N)**。
  - **解释：** 插入元素需要先根据键值在红黑树中查找合适的插入位置（O(log N)），然后插入新节点，并通过旋转和重新着色来保持树的平衡性（这些操作也是 O(log N)）。

**5. `std::unordered_map` / `std::unordered_set` (及其 `multi` 版本)：** (哈希表)

- **`insert(key, value)` (或 `insert(value)` for set)：**
  - **平均时间复杂度：O(1)**。
  - **最坏时间复杂度：O(N)** (当哈希冲突严重，所有元素都映射到同一个桶，形成链表时)。
  - **解释：** 平均情况下，通过哈希函数可以直接计算出元素在哈希表中的存储位置（桶），然后进行插入。如果发生哈希冲突，则在链表中查找和插入。当冲突较少时，操作接近 O(1)。然而，如果哈希函数设计不佳或数据分布极端，导致大量冲突，则可能退化为链表查找，时间复杂度变为 O(N)。当负载因子超过阈值时，哈希表会进行重新哈希（rehash），这将导致 O(N) 的开销。

**总结表格：**

| 容器类型                   | `push_back()` / `push_front()` | `insert(pos, value)` (任意位置) |
| -------------------------- | ------------------------------ | ------------------------------- |
| `std::vector`              | 均摊 O(1) (最坏 O(N))          | O(N)                            |
| `std::deque`               | O(1)                           | O(N)                            |
| `std::list`                | O(1)                           | O(1) (如果迭代器已给出)         |
| `std::map`/`set`           | 不适用                         | O(log N)                        |
| `std::unordered_map`/`set` | 不适用                         | 平均 O(1) (最坏 O(N))           |


