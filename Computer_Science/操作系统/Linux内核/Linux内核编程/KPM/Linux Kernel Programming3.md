# Linux Kernel Programming 3

​	下面我们来聊一聊我们的printk，你可能没有印象！当然这是因为我使用的是pr_info，也就是printk的一个方便的封装。

​	要打印消息，用户空间 C 开发人员通常会使用可靠的 printf() glibc API（或者在编写 C++ 代码时使用 cout）。但是，重要的是要了解在内核空间中没有（用户模式或其他）库。因此，我们根本无法访问旧的 printf() API。相反，它基本上已在内核中重新实现为 printk() 内核 API。

​	想知道它的代码在哪里？好吧，它在这里定义为内核源代码树中的宏：

```
include/linux/printk.h
printk(fmt, …)
```

​	实际函数在这里：kernel/printk/printk.c:_printk()。事实上，内部 printk 实现非常复杂，涉及 printk 索引的包装层等等；

​	幸运的是，内核或内核模块通过 printk() API 发出消息非常简单，与使用 printf() 发出消息非常相似。在我们的简单内核模块中，操作发生的位置如下：printk(KERN_INFO "Hello, world\n");虽然乍一看与 printf 非常相似，但内核中的 printk API 却截然不同。在相似性方面，API 接收格式字符串作为其参数。格式字符串与 printf 的格式字符串几乎相同。但相似之处仅此而已。printf 和 printk 之间的一个关键区别是：用户空间 printf() 库 API 的工作原理是按要求格式化文本字符串并调用 write() 系统调用，而后者又实际上执行对 stdout 设备的写入，默认情况下，stdout 设备是终端窗口（或控制台设备）。内核 printk API 也按要求格式化其文本字符串，但其输出目的地不同。它至少会写入一个位置 - 以下列表中的第一个位置 - 并且可能还会写入其他几个位置：

- RAM 中的（易失性）内核日志缓冲区
- （非易失性）日志文件，即内核日志文件
- 控制台设备

​	接下来，不要过分依赖 printk() API；您很快就会了解到，使用它的现代和推荐方式是通过 pr_foo() 形式的宏（我们将在即将到来的 `pr_<foo>` 便利宏部分中介绍它们）。

​	当您通过 printk 发出消息时，可以保证输出进入内核内存（RAM）中的日志缓冲区。实际上，这构成了（易失性）内核日志。需要注意的是，在图形模式下运行 X 服务器（Xorg、Xwayland 或其他）进程（在典型的 Linux 发行版上工作的默认环境）时，您永远不会直接看到 printk 输出。

​	因此，这里显而易见的问题是：如何查看内核日志缓冲区内容？有几种方法。但是笔者建议的是dmesg，默认情况下，dmesg 会将整个内核日志缓冲区内容转储到 stdout。

​	在内核日志中，如 dmesg 实用程序所显示的那样，最左列方括号内的数字是一个简单的时间戳，格式为 [seconds.microseconds] - 自系统启动以来经过的时间（但不建议将其视为完全准确）。顺便说一句，这个时间戳是一个 Kconfig 变量 - 一个内核配置选项 - 名为 **CONFIG_PRINTK_TIME**；它可以被 printk.time 内核参数覆盖

​	下面我们来谈谈我们的几个模块的常用的几个实用工具！

### 列出活动内核模块 lsmod

​	回到我们的内核模块。到目前为止，我们已经构建了它，将它加载到内核中，并验证了它的入口点函数是否被调用，从而执行了 printk API。那么之后，它会做什么呢？啥也不做，就是打印点东西！我们可以使用 lsmod 实用程序轻松查找它：

```
[Charliechen@ArchLinux try1]$ sudo lsmod | grep hello
hello_lkm              12288  0
```

​	lsmod 显示当前驻留在（或活动）内核内存中的所有内核模块，按时间倒序排列。其输出为列格式，有三列和可选的第四列。让我们分别看一下每一列：

- 第一列显示内核模块的名称。
- 第二列是它在内核中占用的（静态）字节大小。
- 第三列是模块使用计数。
- 可选的第四列表示依赖模块，

​	此外，在最近的 x86_64 Ubuntu 发行版中，内核模块似乎占用了至少 16 KB 的内核内存，而在 Fedora 上则占用了大约 12 KB。
​	太棒了！现在您已经成功地在内核内存中构建、加载和运行了第一个内核模块，并且它基本上可以正常工作，下面说说看他的卸载部分

### 从内核内存卸载模块

​	要卸载内核模块，我们使用便捷实用程序 rmmod（删除模块）：

​	rmmod 的参数是内核模块的名称（如 lsmod 的第一列所示），而不是路径名。显然，就像 insmod 一样，我们需要以 root 用户身份运行 rmmod 实用程序才能成功（或使用 CAP_SYS_MODULE 功能）。

​	在这里，我们还可以看到，由于我们的 rmmod，LKM 框架首先调用正在删除的内核模块的退出例程（或“析构函数”）helloworld_lkm_exit() 函数。它依次调用 printk，发出 Goodbye, world... 消息（我们用 dmesg 查找）。

​	rmmod（请注意，在内部，它调用 delete_module() 系统调用）何时会失败？以下是一些情况：

- 权限：如果它不是以 root 身份运行，或者缺少 CAP_SYS_MODULE 功能（errno 设置为值 EPERM）。
- 如果内核模块的代码和/或数据正在被另一个模块使用（如果存在依赖关系；下一章的模块堆栈部分将详细介绍）或模块当前正在被进程（或线程）使用，则模块使用计数将为正，rmmod 将失败（errno 随后设置为值 EBUSY）；这是有道理的。
- 内核模块未使用 module_exit() 宏指定退出例程（或析构函数），并且 CONFIG_MODULE_FORCE_UNLOAD 内核配置选项被禁用。

​	与模块管理有关的几个便利实用程序只不过是指向单个 kmod 实用程序的符号（软）链接（类似于流行的 busybox 实用程序所做的）。包装器是 lsmod、rmmod、insmod、modinfo、modprobe 和 depmod。看看其中的几个：
