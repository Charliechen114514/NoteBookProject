# 操作系统：内存申请接口详解

​	这里我们讨论的内存接口，更多的是说明的kmalloc/vmalloc/kzalloc等接口。

## 内存子系统的划分

​	我们使用的内存所应对的场景不同，自然也就导致了我们需要对内存进行分区，从而保证内存的使用效率。对于经典的X86，我们划分为：`ZONE_DMA、ZONE_NORMAL、ZONE_HIGHMEM`而且还会在每一个去续上，构建多层次的分配器。

#### **Buddy Allocator** （伙伴系统）

​	Buddy Allocator实际上是接管我们对页进行申请内存后的管理工作，我们会把以页（PAGE_SIZE，通常 4 KB）为单位的物理连续内存进行以2^order 个连续页分配。这样，我们触发页面回收的时候，就会快速的合并同级order的页面蔟从而保证尽可能大的页面连续空余。

#### **SLAB/SLUB/SLOB 分配器**

​	SL*B分配器实际上进一步接管了我们的页，我们一般申请小对象的时候，不会一下子需要4KB分配出去，实际上是优化了小对象的内存申请使用

| 特性         | SLAB                 | SLUB                   | SLOB               |
| :----------- | :------------------- | :--------------------- | :----------------- |
| **设计目标** | 高性能、低碎片       | 简化SLAB，提升扩展性   | 极简，最小内存占用 |
| **数据结构** | 多级Slab缓存         | 每CPU Partial Slab列表 | 全局空闲链表       |
| **内存效率** | 中等（可能内部碎片） | 高（合并Slab）         | 极低（高外部碎片） |
| **性能**     | 高（缓存优化）       | 高（无锁竞争）         | 低（链表遍历）     |
| **复杂度**   | 高                   | 中等                   | 极低               |
| **调试支持** | 有限                 | 强大（SLUB_DEBUG）     | 无                 |
| **适用场景** | 高频小对象分配       | 现代通用内核（默认）   | 嵌入式无MMU系统    |

​	我们下面的主角：kmalloc/kzalloc 的小请求都走这里。

#### **vmalloc 区**

​	在高地址连续的虚拟区间（VMALLOC_START ~ VMALLOC_END）内，按页映射离散的物理页，提供虚拟连续但物理不连续的缓冲区。这样适用于我们对那些剩余零碎空间的使用提供了一定保障。vmalloc函数系列主要走的是这里的接口。

## GFP 标志与上下文

调用 kmalloc/kzalloc/alloc_pages 时，`gfp_t flags` 会决定：

- **可睡眠 vs 原子**
  - `GFP_KERNEL`：可睡眠，可触发 I/O、回收，适合进程上下文。
  - `GFP_ATOMIC`：不可睡眠，用于中断、软中断、持锁场景。
- **高端内存**
  - `__GFP_HIGHMEM`：允许从 ZONE_HIGHMEM 分配，用于 vmalloc。
- **DMA 区**
  - `GFP_DMA`、`GFP_DMA32`：限制物理地址低于设备 DMA 能力的区域。

## kmalloc函数

​	kmalloc就像我们glibc提供的接口malloc一样，它用来分配**物理上连续**、**虚拟上连续**的内存块。我们一般用在需要 DMA、I/O 缓冲区、或对物理地址有特殊要求的场景。

### 使用原型

```c
void *kmalloc(size_t size, gfp_t flags);
```

- `size`：要分配的字节数。（调用者的 `size` 会向上对齐到最接近的 `cache_line` 或者 `sizeof(void *) * 2`，以满足最严格的对齐需求。）
- `flags`：指定分配行为的 GFP 标志（如 `GFP_KERNEL`、`GFP_ATOMIC` 等）。

**选择分配路径**

```c
if (size <= KMALLOC_MAX_SIZE)
    ptr = __kmalloc(size, flags);
else
    ptr = __kmalloc_large(size, flags);
```

- **小对象**（`size ≤ KMALLOC_NORMAL_MAX_SIZE`，通常 8 KB）：走 SLAB/SLUB 路径。
- **大对象**：直接降级为 page 级分配，调用 `__get_free_pages(order)`。

### 流程

**SLUB 位分配（以 SLUB 为例）**

- **查找或建立 cache**：先建立缓存队列
  - 内核为每种 size_class（如 8B、16B、32B…8 KB）预先创建 `struct kmem_cache`。（就像伙伴系统那样的缓存队列）
- **从 CPU freelist 或 partial slab 拿对象**：尝试从内存对象中拿东西
  - 每个 CPU 维护一个本地 freelist，减少跨 CPU 竞争。
  - 若本地没有，再从共享 partial slab（半满 slab）获取。
- **初始化**
  - 若首次分配，SLUB 会调用 `slab_post_alloc(obj, cache, flags)` 执行构造器（ctor）或调试填充。

**大对象分配**：这里是fallback，如果发现对象非常大，则回退到也分配上

- 计算所需页数 `order = get_order(size)`。
- 调用 `__alloc_pages(flags, order)`，从伙伴系统获取连续页。
- 用 `page_address()` 将 `struct page *` 转为线性地址返回。

**返回与标记**

- kmalloc 返回的是内核线性地址空间中的指针，调用者无需再做映射。
- 若分配失败（例如内存不足或 GFP_ATOMIC 无法等待），返回 NULL。

#### 优缺点

优点：分配/释放速度快（使用对象缓存，命中率高）；模块化、碎片化控制较好。

缺点：分配过大对象会导致内存碎片，严重时可能分配失败；只能分配低端内存（ZONE_DMA、ZONE_NORMAL），无法跨越高端内存区域。

## kzalloc（≈ kmalloc + memset 0）

与 `kmalloc` 完全相同，但返回的内存**已被清零**（Zeroed）。

```
void *kzalloc(size_t size, gfp_t flags);
```

1. 调用 `kmalloc(size, flags)` 分配物理连续内存。
2. 如果分配成功，调用 `memset(ptr, 0, size)` 将整块内存置零。

#### 使用场景

- 分配需要全零初始化的结构体、数组，避免手动 `memset`，减少出错。
- 性能上比手动 kmalloc + memset 略有提升（内核可对 slab 对象做零化优化）。

## vmalloc：物理内存不要求连续的大分配

分配**虚拟上连续**、但**物理上不必连续**的一段内存区间，典型用于：大块内存分配（> 几 KB）、对物理连续性无要求的缓冲。

```
void *vmalloc(unsigned long size);
```

### 内部流程（简化）

1. **申请虚拟区间**，从而先把连续的虚拟地址找出来。

   - 调用 `get_vm_area_caller(size, VMALLOC_START, VMALLOC_END, PAGE_KERNEL);`
   - 在 vmalloc 区通过一颗红黑树（`vmap_area_struct`）管理空闲段，寻找足够长度的连续虚拟空间。

2. **物理页分配与映射**：建立虚拟地址到物理地址的页级别映射

   ```
   for (p = start; p < end; p += PAGE_SIZE) {
       struct page *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
       map_vm_area(p, page_to_pfn(page), PAGE_KERNEL);
   }
   ```

   - 每一页都调用 `alloc_page`（可能来自高端区），然后通过 `remap_pfn_range()` 或 `vmap_pfn_range()` 建立页表映射。

3. **TLB 和缓存**

   - 完成映射后需刷新 TLB（通过 `flush_vm_range()`），确保新映射对 CPU 可见。

4. **释放**

   - `vfree(addr)` 会反向遍历页表，释放每个物理页，然后回收虚拟区间。

#### 优势与限制

- **优点**
  - 可以分配大于单个 slab 最大对象限制的大内存块。
  - 不会因为物理碎片导致分配失败。
- **缺点**
  - 分配 / 释放慢：需要多次分配页和建立页表映射。
  - 内存访问速度略低于 `kmalloc`，因为会多一次页表查找。
  - 分配的内存不适合 DMA（通常需要物理连续）。

## 对比一下

### 接口对比

| 特性             | kmalloc                       | kzalloc                       | vmalloc               |
| ---------------- | ----------------------------- | ----------------------------- | --------------------- |
| 物理连续性       | 是                            | 是                            | 否                    |
| 虚拟连续性       | 是                            | 是                            | 是                    |
| 默认初始化       | 随机垃圾                      | 全 0                          | 随机垃圾              |
| 最大推荐分配大小 | 几 KB（受 slab 最大对象限制） | 同 kmalloc                    | 理论可达数 MB~数十 MB |
| 分配/释放开销    | 低                            | 略高于 kmalloc（额外 memset） | 高（多页分配 + 建表） |
| DMA 兼容         | 支持                          | 支持                          | 不支持                |
| 内存碎片         | 可能（大对象）                | 同 kmalloc                    | 物理碎片影响小        |

### 选型与性能考虑

| 场景                         | 接口               | 核心考量                          |
| ---------------------------- | ------------------ | --------------------------------- |
| 小对象、碎片少、需要物理连续 | kmalloc/GFP_KERNEL | 极低延迟、DMA 兼容                |
| 小对象、需原子上下文         | kmalloc/GFP_ATOMIC | 中断安全，无死锁                  |
| 需自动全零                   | kzalloc            | 安全初始化，防止信息泄露          |
| 大块缓冲、对物理地址无要求   | vmalloc            | 可扩展到数十 MB，避免伙伴系统碎片 |
| NUMA 优化                    | kmalloc_node       | 保证跨节点分配性能                |

- **小内存、性能敏感、需要物理连续** → `kmalloc`
- **小内存、需要全零初始化** → `kzalloc`
- **大内存（> slab 限制）、物理连续性不重要** → `vmalloc`

