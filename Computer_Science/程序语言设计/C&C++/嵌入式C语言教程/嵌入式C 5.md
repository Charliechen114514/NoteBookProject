# 嵌入式C语言教程——程序的编译链接安装和运行（1）

​	笔者认为这个话题想要更加的深入，可以参考《高级C/C++编译教程》或者是《程序员的自我修养》来深入的理解，这里只是一个简单的提纲。以供参考

## 程序的编译

​	程序的编译是一个老生常谈的话题：

​	程序编译是将源代码转换为计算机能够理解和执行的机器代码的过程。源代码通常是用高级编程语言编写的，如C++、Java或Python，而计算机只能直接理解二进制机器代码。因此，编译器的作用就是将这些高级语言指令转换成目标机器语言。

​	编译过程通常分为几个阶段。首先，编译器会进行词法分析，将源代码拆分成一个个基本的词法单元（如变量、运算符等）。接着，语法分析阶段会根据语言的语法规则，检查源代码是否符合语法结构，构建出一个语法树。然后，编译器会进行语义分析，确保代码的逻辑和数据访问是合理的，变量的使用符合规则。

​	接下来，编译器会进行优化，尝试改进代码的执行效率或减少占用的资源。优化可以在不同的层次上进行，包括循环优化、内存优化等。最后，编译器会将优化后的代码生成目标代码，这通常是特定于某种处理器架构的机器码，或者是平台相关的中间代码。

### 动手试试看

> as.c

```
int add(int a, int b){return a + b;}
int sub(int a, int b){return a - b;}
```

> as.h

```
int add(int a, int b);
int sub(int a, int b);
```

> main.c

```
#include <stdio.h>
#include "as.h"

int gv = 1;
int ugv;

int main()
{
        int a, b;
        static int sv = 2;
        static int usv;
        a = add(2, 3);
        b = sub(3, 2);
        printf("a=%d, b=%d\n", a, b);
}
```

​	我们直接一条龙：

```
charliechen@charliechen:~/learn$ gcc -o res main.c test.c
charliechen@charliechen:~/learn$ ./res
a=5, b=1
```

​	我们可以看看这个可执行文件到底是如何的：

```
charliechen@charliechen:~/learn$ readelf -h res
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           AArch64
  Version:                           0x1
  Entry point address:               0x640
  Start of program headers:          64 (bytes into file)
  Start of section headers:          68816 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         28
  Section header string table index: 27
```

​	以及包含哪一些基本的段：

```
charliechen@charliechen:~/learn$ readelf -S res
There are 28 section headers, starting at offset 0x10cd0:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000238  00000238
       000000000000001b  0000000000000000   A       0     0     1
  [ 2] .note.gnu.bu[...] NOTE             0000000000000254  00000254
       0000000000000024  0000000000000000   A       0     0     4
  [ 3] .note.ABI-tag     NOTE             0000000000000278  00000278
       0000000000000020  0000000000000000   A       0     0     4
  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298
       000000000000001c  0000000000000000   A       5     0     8
  [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8
       00000000000000f0  0000000000000018   A       6     3     8
  [ 6] .dynstr           STRTAB           00000000000003a8  000003a8
       0000000000000094  0000000000000000   A       0     0     1
  [ 7] .gnu.version      VERSYM           000000000000043c  0000043c
       0000000000000014  0000000000000002   A       5     0     2
  [ 8] .gnu.version_r    VERNEED          0000000000000450  00000450
       0000000000000030  0000000000000000   A       6     1     8
  [ 9] .rela.dyn         RELA             0000000000000480  00000480
       00000000000000c0  0000000000000018   A       5     0     8
  [10] .rela.plt         RELA             0000000000000540  00000540
       0000000000000078  0000000000000018  AI       5    21     8
  [11] .init             PROGBITS         00000000000005b8  000005b8
       0000000000000018  0000000000000000  AX       0     0     4
  [12] .plt              PROGBITS         00000000000005d0  000005d0
       0000000000000070  0000000000000000  AX       0     0     16
  [13] .text             PROGBITS         0000000000000640  00000640
       000000000000019c  0000000000000000  AX       0     0     64
  [14] .fini             PROGBITS         00000000000007dc  000007dc
       0000000000000014  0000000000000000  AX       0     0     4
  [15] .rodata           PROGBITS         00000000000007f0  000007f0
       0000000000000014  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         0000000000000804  00000804
       000000000000004c  0000000000000000   A       0     0     4
  [17] .eh_frame         PROGBITS         0000000000000850  00000850
       00000000000000dc  0000000000000000   A       0     0     8
  [18] .init_array       INIT_ARRAY       000000000001fd90  0000fd90
       0000000000000008  0000000000000008  WA       0     0     8
  [19] .fini_array       FINI_ARRAY       000000000001fd98  0000fd98
       0000000000000008  0000000000000008  WA       0     0     8
  [20] .dynamic          DYNAMIC          000000000001fda0  0000fda0
       00000000000001f0  0000000000000010  WA       6     0     8
  [21] .got              PROGBITS         000000000001ff90  0000ff90
       0000000000000070  0000000000000008  WA       0     0     8
  [22] .data             PROGBITS         0000000000020000  00010000
       0000000000000018  0000000000000000  WA       0     0     8
  [23] .bss              NOBITS           0000000000020018  00010018
       0000000000000010  0000000000000000  WA       0     0     4
  [24] .comment          PROGBITS         0000000000000000  00010018
       0000000000000026  0000000000000001  MS       0     0     1
  [25] .symtab           SYMTAB           0000000000000000  00010040
       0000000000000948  0000000000000018          26    72     8
  [26] .strtab           STRTAB           0000000000000000  00010988
       000000000000024c  0000000000000000           0     0     1
  [27] .shstrtab         STRTAB           0000000000000000  00010bd4
       00000000000000fa  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

​	这里指出的是：`readelf -h`就是获取ELF格式文件的头，它主要包括了可执行文件的运行平台的信息，软件版本，程序的入口地址，以及程序的文件头，段头等信息。

​	常常的，我们熟悉的section有.text，.data，.bss几个段，也就是代码段，数据段等。

​	对于一个大型的C项目中，编译系统是按照.C源文件作为编译单元一一进行编译的，编译系统实际上包含4个主要的工具：

- 预处理器
- 编译器
- 汇编器
- 链接器

最后生成的文件也分为三种可能：可重定位的，可被执行的和可被共享的文件。

## 预处理流程

​	预处理无非在处理这些情况：

- 头文件的展开：#include
- 宏的展开：#define 
- 条件编译选择：#ifdef...
- 控制编译属性：#pragma（这个一般保留，指示编译器做规定的动作）
- 删除注释
- 添加行号和文件标识符

​	到现在，我们的程序的基本的伪指令的部分就被分析结束，生成那些完全可以被编译器认识的指令了。下一步，就是我们的变异

## 编译

​	编译分为六个部分，依次是

1. 词法分析
2. 语法分析
3. 语义分析
4. 中间代码生成
5. 汇编代码生成
6. 目标代码生成

​	词法分析用来解析我们的C语言原程序，分解为一个一个记号单元token。常见的token如下：

- int, float,for,while等关键字
- 标识符
- 字面量，数字和字符串
- 运算符
- 分隔符

​	下一步对token序列进行解析，尝试构建合法的语义树，如果发现没法正确的构建预期的树（比如说少了分号这种），程序报错

​	在下一步就是语义分析：实际上就是查看表达式有没有问题，比如一些不该出现的词（没有声明的变量，break在case语句之外蹦出来了）等等

​	中间代码就似乎用来辅助生成汇编的，因为一些中间的伪指令非常方便翻译成目标代码



## 汇编

​	现在，我们已经将高级语言转换为可以翻译为机器语言的汇编指令了，我们会在这里生成机器指令还有一些额外的链接信息供我们生成大程序。

​	各位可以参看可重定位文件中的符号表，你会高兴的发现，我们每一个section都是0地址起手的。因为他还没有经过链接真正组合成可用的执行文件

```
charliechen@charliechen:~/learn$ readelf -S main.o
There are 13 section headers, starting at offset 0x440:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000048  0000000000000000  AX       0     0     4
  [ 2] .rela.text        RELA             0000000000000000  00000348
       0000000000000078  0000000000000018   I      10     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000088
       0000000000000008  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  00000090
       0000000000000008  0000000000000000  WA       0     0     4
  [ 5] .rodata           PROGBITS         0000000000000000  00000090
       000000000000000c  0000000000000000   A       0     0     8
  [ 6] .comment          PROGBITS         0000000000000000  0000009c
       0000000000000027  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000c3
       0000000000000000  0000000000000000           0     0     1
  [ 8] .eh_frame         PROGBITS         0000000000000000  000000c8
       0000000000000038  0000000000000000   A       0     0     8
  [ 9] .rela.eh_frame    RELA             0000000000000000  000003c0
       0000000000000018  0000000000000018   I      10     8     8
  [10] .symtab           SYMTAB           0000000000000000  00000100
       0000000000000210  0000000000000018          11    16     8
  [11] .strtab           STRTAB           0000000000000000  00000310
       0000000000000031  0000000000000000           0     0     1
  [12] .shstrtab         STRTAB           0000000000000000  000003d8
       0000000000000061  0000000000000000           0     0     1
```



### 符号表和重定位表

​	这是在汇编过程确定的，我们就是在汇编结束的时候需要生成一份信息表，用来确定符号的地址类型占用空间大小等。

符号表的每个符号条目包括以下属性：

| 属性       | 描述                                           | 类型及可能的取值                                             |
| ---------- | ---------------------------------------------- | ------------------------------------------------------------ |
| `st_name`  | 符号名称的索引，在符号字符串表中查找符号的名字 | `uint32_t`，指向符号字符串表的索引                           |
| `st_value` | 符号值或地址                                   | `uint32_t` 或 `uint64_t`，符号的实际地址（对于程序计数器，函数入口地址等） |
| `st_size`  | 符号的大小                                     | `uint32_t` 或 `uint64_t`，通常是数据类型或函数的大小         |
| `st_info`  | 符号的类型和绑定信息                           | `uint8_t`，由 `STB_*`（绑定）和 `STT_*`（类型）组成的组合    |
| `st_other` | 符号的其他属性（通常为保留字段）               | `uint8_t`，通常值为 0，扩展特性可使用                        |
| `st_shndx` | 符号所在的节区索引                             | `uint16_t`，指向符号所在节区的索引，若为 `SHN_UNDEF` 表示符号未定义 |

#### `st_info` 字段的值

`st_info` 字段由两个部分组成：

- 绑定（`STB_*`）: 绑定信息决定了符号如何与共享库等链接。常见的绑定类型包括：
  - `STB_LOCAL`: 局部符号，仅在当前模块中有效。
  - `STB_GLOBAL`: 全局符号，可以跨模块访问。
  - `STB_WEAK`: 弱符号，链接器可以选择覆盖它。
- 类型（`STT_*`）: 类型信息描述符号的类别，常见的类型包括：
  - `NOTYPE`: 未定义的符号类型。
  - `OBJECT`: 数据对象，如全局变量、静态变量等。
  - `FUNC`: 函数。
  - `SECTION`: 区段符号。
  - `FILE`: 文件符号，用于表示源文件。
  - `TLS`：线程存储
  - `COMMON`也就是全局的弱符号，在当前文件下不会为之分配空间

​	在每一个单独的文件当中，我们没有找到定义的符号就会被mark上NOTYPE，汇编器认为这些符号最终会找到他们的定义。因此，我们将直接工作交给了下一步：链接

## 链接

​	我们下一步就是组合这些可重定位文件进行可执行文件的最后生成。实际上就是裁决每一个段地址的基址，对相同类型的段进行合并。

​	链接过程通常分为以下几个主要阶段：符号解析、重定位、地址分配、符号表更新和生成可执行文件。

​	符号解析是链接过程的第一步，它的主要任务是解决程序中所有符号（如变量、函数等）之间的引用关系。符号表是符号解析的核心，它存储了所有符号的信息，包括符号的名称、地址、大小、类型等。在链接过程中，链接器需要通过符号表来确定不同目标文件中符号的定义和引用。

​	每个目标文件中都包含一个符号表。**符号表分为两类符号：定义符号和引用符号。定义符号是在目标文件中实际定义的符号，而引用符号是在目标文件中引用的符号，但并没有在该目标文件中定义。**

​	对于嵌入式Linux人，我们可能经常需要自己来写链接脚本。当然，一个简单的脚本那就是：

```
OUTPUT_FORMAT("elf32-littlearm")
OUTPUT_ARCH("arm")
ENTRY(_start)
SECTIONS
{
	. = 0x60000000
	.text: {*(.text)}
	. = 0x62000000
	.data = {*(.data)}
	.bss = {*(.bss)}
}
```

在符号解析过程中，链接器需要做以下几项工作：

- **符号冲突解决**：如果一个符号在多个目标文件中有定义，链接器会根据符号的类型（如 `STB_GLOBAL`、`STB_LOCAL` 等）和绑定规则来决定最终使用哪个定义。对于全局符号，如果存在多个定义，链接器会报错；对于弱符号（`STB_WEAK`），如果没有其他符号定义，链接器会选择使用弱符号。
- **符号重定向**：如果一个目标文件引用了一个在其他文件中定义的符号，链接器会将符号引用重定向到正确的地址。这涉及到从符号表中获取符号的地址信息，替换目标文件中相应的引用。

​	符号冲突解决的办法那就是符号决议，我们的链接器在上个阶段收集导的强弱符号来决定最终谁是最终的定义，裁决的办法是：

- 一山不容二虎，抓到强符号重定义就是报错（重定义）
- 强符号优先！
- 体积大者胜出

​	重定位是链接的第二个阶段，它的任务是修正程序中所有的内存地址。由于程序中的代码和数据通常是由多个源文件生成的，每个目标文件都有自己的地址空间。链接器需要将这些目标文件中的地址进行调整，使得所有代码和数据都能正确地结合成一个可执行文件。

重定位主要涉及两方面的内容：

- **符号地址的修正**：当程序中某个符号的地址发生变化时，链接器会使用重定位表（Relocation Table）来修改目标文件中所有引用该符号的地址。重定位表中的每一项记录了需要修改的地址，以及如何根据符号表中的符号信息来进行修正。
- **地址的调整**：链接器将各个目标文件合并后，分配新的地址给每个段（如代码段、数据段等）。这些新的地址会被写入到重定位表中，确保程序在加载时能够正确地引用这些符号。

重定位的过程具体分为以下几个步骤：

- **分析重定位表**：重定位表记录了需要重定位的地址、符号索引和重定位类型。链接器会根据这些信息，确定哪些位置需要进行修改。
- **应用重定位**：根据符号表中的符号地址，链接器会对目标文件中涉及到符号的指令进行修改，将原本的相对地址或偏移量调整为新的地址。
- **处理外部符号**：对于在目标文件中未定义的符号，链接器会将这些符号的地址留空，直到程序被加载时，由操作系统进行处理（如加载共享库时，操作系统会动态链接这些符号）。

​	在符号解析和重定位之后，链接器需要进行地址分配。地址分配的目的是为程序的每个部分（如代码段、数据段、堆栈等）分配一个合适的内存地址，使得程序在运行时能够正确地访问每个部分。

地址分配涉及以下几个主要的部分：

| 段名       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| **代码段** | 代码段存储了程序的可执行指令。链接器将为代码段分配一个固定的起始地址，这个地址通常是根据系统的内存布局来选择的 |
| **数据段** | 数据段存储了程序的全局变量、静态变量等。数据段的地址需要根据数据的大小进行调整，确保不会与代码段发生冲突 |
| **堆栈段** | 堆栈用于存储函数调用时的局部变量、返回地址等。堆栈的地址通常是动态分配的，程序运行时由操作系统管理 |
| **BSS段**  | BSS段用于存储未初始化的全局变量和静态变量。BSS段在链接时不占用磁盘空间，但它的大小会在链接时确定，并分配相应的内存 |

​	在链接的过程中，符号表需要不断地更新。初始符号表存储的是目标文件中的符号信息，而在链接过程中，链接器会根据符号解析和重定位的结果，对符号表进行修改。例如：

- **符号地址更新**：当符号的地址发生变化时，链接器会更新符号表中的符号地址。
- **符号类型修改**：有时符号的类型会发生变化。例如，某个符号原本是局部的，但由于被外部引用，它可能会被修改为全局符号。链接器会根据需要修改符号的类型。
- **符号表合并**：多个目标文件的符号表会在链接时合并，重复的符号会被去重，并保留正确的定义。

​	经过符号解析、重定位、地址分配和符号表更新后，链接器最终生成一个可执行文件。这个可执行文件包含了所有的代码、数据、符号信息以及必要的调试信息。在生成可执行文件时，链接器还会根据需要进行以下操作：

- **段合并**：链接器会将多个目标文件中的代码段、数据段等合并成一个统一的段，并对段进行重新排序和合并，确保每个段在内存中的布局是合理的。
- **生成节头表**：可执行文件中包含一个节头表，记录了每个节的起始地址、大小和类型等信息。
- **生成符号表和重定位表**：链接器将最终的符号表和重定位表嵌入到可执行文件中，确保程序能够在运行时动态加载符号并进行重定位。
- **添加调试信息**：如果编译时启用了调试选项，链接器会将调试信息嵌入到可执行文件中，供调试器使用。

​	节点表就是我们最后看到的那样，readelf -h得到的东西

## 运行

​	万事具备，只欠东风。现在，我们只需要在shell中运行这个可执行文件名称，也许可能还需要提供命令行的一些参数，就可以开始我们的运行了！

​	程序的运行从操作系统的加载程序开始。当用户请求启动一个程序时，操作系统会从存储设备（如硬盘或SSD）中将该程序加载到内存中。操作系统会读取可执行文件的头部信息，获取程序的结构、所需的资源、所依赖的共享库等。可执行文件通常以 ELF （Linux比较多）格式、PE （Windows比较多）格式或 Mach-O （MacOS比较多）格式存储，这些格式包含了程序的执行入口、代码段、数据段、符号表、重定位信息等。

​	操作系统会创建一个进程，将程序的各个部分（如代码段、数据段、BSS段等）映射到内存中。这些段的数据通常会被映射为虚拟地址，程序实际运行时的地址空间可能会不同于其在磁盘上的存储位置。操作系统还会在内存中为程序分配堆栈（Stack）和堆（Heap）空间，并为程序分配必要的文件描述符和其他资源。此外，如果程序需要依赖共享库，操作系统会在运行时将所需的库加载到内存中，并进行动态链接。

​	每个程序在运行时都有一个独立的地址空间，操作系统通过虚拟内存机制为程序提供隔离的内存空间。虚拟内存是操作系统提供的一种技术，使得程序认为自己拥有一块连续的内存区域，实际上这些内存地址可能是映射到物理内存中的不同位置。操作系统使用内存管理单元（MMU）将虚拟地址转换为物理地址。这个过程是透明的，程序并不需要关心实际的物理内存位置。内存中的不同区域被分配给程序的各个部分，如代码、数据、堆、栈等。程序的代码通常会被映射到内存中的只读区域，而数据则被映射到可读写的区域。

​	**内存映射表是一种常见的机制，用于将程序的虚拟地址映射到物理内存中的实际位置。操作系统会为每个进程建立一个页表，来管理虚拟地址到物理地址的转换。**这种映射关系确保了程序在运行时能够访问到所需的内存空间，而无需担心底层的物理内存管理细节。

​	一旦程序被加载到内存中，操作系统的任务调度程序将控制权交给程序的入口点（通常是 `main` 函数）。此时，程序开始执行。程序的执行是由 CPU 进行的。程序的每一条指令都会被加载到 CPU 中进行解码和执行。现代 CPU 采用流水线技术，将指令分成多个阶段并行处理，这样能够提高执行效率。

​	程序执行过程中会涉及到对内存的读写操作，程序会按照指令中的地址来访问数据。程**序的指令和数据通常是分开存储的，代码段（Text Segment）存储程序的指令，数据段（Data Segment）存储程序的静态数据。程序运行时，CPU 会根据程序计数器（PC）指示的位置逐条执行指令，直到遇到退出条件（如 `return` 语句或操作系统发出的中断）**。

​	程序的退出是其生命周期的最后一步。当程序执行完毕或者遇到致命错误时，操作系统会回收该程序使用的资源，关闭文件描述符，释放内存，终止所有与该程序相关的进程。

​	程序的退出通常通过以下几种方式实现：

- **正常退出**：程序通过 `exit` 系统调用或 `return` 语句结束执行，操作系统会回收资源并清理环境。
- **异常退出**：如果程序发生未处理的异常，操作系统会通过信号处理机制终止程序，并进行必要的资源回收。
- **外部终止**：操作系统可以通过 `kill` 命令或其他方式强制终止正在运行的程序。

​	退出时，操作系统会通知相关进程，释放所有与该进程相关的资源，并将进程的退出状态返回给父进程（如果存在）。程序的退出码（Exit Code）通常用于指示程序执行的结果，0 通常表示成功，非零值表示出现错误。
