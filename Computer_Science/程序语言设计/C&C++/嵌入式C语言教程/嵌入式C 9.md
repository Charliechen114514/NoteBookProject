# 嵌入式C 9：数据存储

## 大端模式和小端模式

​	实际上，计算机存数从来都有两个派别。那就是大端存储还是小端存储的问题。这个问题是对于那些大于1个字节类型的数据才需要考虑的。考虑我们现在需要存储0x12345678进入内存。大端模式就是将低字节存在低字节高地址存在高字节。比如说IBM, Sun, PowerPC等等就是这样的架构。常见的ARM x86等默认采取的行为是小端模式。也就是说：

```
原始数据: 0x12345678
大端模式: 12 34 56 78
小端模式: 78 56 34 12
-------------->地址增大
```

​	我们有一种办法来查询我们的地址是大端还是小段：

```
char is_little_endian(){
	const int res = 0x11223344;
	char b = a;
	return b == 0x44;
}
```

### C语言中的有符号数与无符号数

在 C 语言中，整数类型是最常用的数据类型之一，它们用于存储和处理各种数值。根据能否表示负数，整数类型可以分为**有符号数（Signed Integers）\**和\**无符号数（Unsigned Integers）**。这两种类型的数字在计算机中的表示、操作以及使用场景存在显著差异。理解它们之间的区别和应用场景，对于编写高效且正确的程序至关重要。本文将从有符号数和无符号数的定义、表示方法、运算规则以及实际应用等方面进行深入阐述。

### 基础概念

#### 1. 有符号数（Signed Integers）

有符号数（signed integers）可以表示正数、零以及负数。它们的存储方式通过**符号位**来区分正负数。通常情况下，有符号数使用**二进制补码（Two’s Complement）**表示法来存储，这种表示法使得加减法计算变得非常简单，硬件实现也更高效。

- **补码表示**：在二进制补码表示法中，最高位用于表示符号位，0 表示正数，1 表示负数。负数的表示方法是将其绝对值按位取反后再加 1。例如，8 位有符号数中的 `-1` 以补码形式表示为 `11111111`。

有符号整数的大小（以字节为单位）和范围通常与所使用的平台和编译器有关，但有一些典型的规则。例如，32 位有符号数的表示范围通常为：

- 最小值：`-2,147,483,648`
- 最大值：`2,147,483,647`

#### 2. 无符号数（Unsigned Integers）

无符号数（unsigned integers）只能表示零及正整数，不能表示负数。与有符号数不同，无符号数的所有位都用于表示数值本身，因此无符号数的表示范围要比同大小的有符号数大一倍。无符号整数类型常见的包括 `unsigned int`、`unsigned short`、`unsigned long` 等。

无符号数的范围没有负数，通常表现为从 0 开始，到该类型能够表示的最大值。例如，32 位无符号数的范围通常为：

- 最小值：`0`
- 最大值：`4,294,967,295`

与有符号数不同，所有的位都用于表示数值，因此无符号数能够表示更大的正整数。

#### 3. 数据类型的大小与范围

在 C 语言中，整数类型的大小和范围是由平台和编译器决定的。虽然 C 语言标准规定了不同整数类型的最小范围，但实际的大小通常是依赖于平台的。以下是一些常见整数类型的大小和范围示例：

| 类型        | 大小（字节） | 有符号范围（最小值，最大值）                            | 无符号范围（最小值，最大值）    |
| ----------- | ------------ | ------------------------------------------------------- | ------------------------------- |
| `char`      | 1            | -128 到 127                                             | 0 到 255                        |
| `short`     | 2            | -32,768 到 32,767                                       | 0 到 65,535                     |
| `int`       | 4            | -2,147,483,648 到 2,147,483,647                         | 0 到 4,294,967,295              |
| `long`      | 4 或 8       | -2,147,483,648 到 2,147,483,647                         | 0 到 4,294,967,295              |
| `long long` | 8            | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0 到 18,446,744,073,709,551,615 |

可以看到，无符号数和有符号数的范围差异显著。对于同样的存储空间，无符号数能够表示的数值范围更大，适合处理不需要负数的场景。

### 内存表示

在计算机内部，数值的存储方式通常是基于二进制编码的。对于有符号数和无符号数，它们的存储方式不同。

#### 有符号数的存储

有符号数通常采用**补码表示法**。补码表示法使得加法和减法操作非常简单，而且避免了正负零的概念，因此在硬件中实现起来较为高效。

以 8 位有符号数为例，其表示范围为 `-128` 到 `127`。其中：

- `00000000` 表示 `0`（零的补码表示）。
- `01111111` 表示 `127`（最大正数）。
- `10000000` 表示 `-128`（最小负数）。
- `11111111` 表示 `-1`（负一的补码表示）。

补码表示法的关键特点是，负数的补码可以通过对其正数绝对值的二进制表示按位取反后加 1 得到。例如：

- `-1` 的补码表示为：`11111111`
- `-2` 的补码表示为：`11111110`

#### 无符号数的存储

无符号数不需要符号位，所有位都用于表示数值本身。因此，存储无符号数时没有负数的概念，数据的表示更简单。以 8 位无符号数为例，其表示范围为 `0` 到 `255`。无符号数的所有二进制位都表示数值的大小。

- `00000000` 表示 `0`。
- `11111111` 表示 `255`（最大值）。

### 运算规则

在 C 语言中，**有符号数**与**无符号数**的运算遵循特定的规则，尤其是在混合运算时，需要特别小心。

#### 有符号数与无符号数的混合运算

在 C 语言中，当有符号数与无符号数进行运算时，**有符号数会被转换为无符号数**，这可能导致意外的结果。例如：

```
int a = -1;
unsigned int b = 1;
if (a < b) {
    printf("a < b\n");
}
```

在这个例子中，`a` 是有符号数，而 `b` 是无符号数。因为 `a` 是负数，C 语言会将其转换为无符号数，而 `-1` 转换为无符号数时将变为 `4294967295`。由于 `4294967295` 比 `1` 大，因此条件 `a < b` 会评估为 `false`，而不是我们预期的 `true`。因此，在进行有符号数和无符号数混合运算时，要特别小心，并考虑明确的类型转换。

#### 溢出和截断

溢出是指数值超出了类型能够表示的范围。在 C 语言中，有符号数溢出是未定义行为，而无符号数溢出则会导致**模运算**（环绕），即数值会“回绕”到最小值。

例如，对于 8 位无符号数，如果加上一个很大的值：

```
unsigned char x = 250;
x = x + 10;
```

`x` 将变为 `4`，因为 `250 + 10 = 260`，而 `260` 超出了 `0` 到 `255` 的范围，因此发生溢出，`260` 对 `256` 取模得到 `4`。

对于有符号数，当超出其表示范围时，行为是未定义的。例如：

```
int x = 2147483647;
x = x + 1;  // 溢出，行为未定义
```

## 对齐问题

### 一、结构体对齐

#### 1.1 结构体对齐的基本概念

在C语言中，结构体是由多个数据成员组成的复合数据类型。这些数据成员可能是不同的数据类型，如`int`、`float`、`char`等。结构体对齐是指编译器根据硬件平台对结构体成员的内存布局进行调整，以保证数据成员在内存中的位置符合其数据类型的对齐要求。

每种数据类型通常有一个对齐要求，这个要求是该数据类型大小的倍数。比如，`int`类型通常要求在4字节的边界上对齐，`double`类型通常要求在8字节的边界上对齐。结构体的对齐要求通常是其最大成员的对齐要求，即最大数据成员类型的对齐要求决定了整个结构体的对齐方式。

例如，在一个结构体中，如果包含`char`（1字节）和`int`（4字节）类型的成员，编译器通常会根据`int`的对齐要求将整个结构体对齐到4字节的边界。

#### 1.2 对齐填充

为了保证结构体成员的对齐，编译器通常会插入“填充字节”。填充字节是为了使结构体成员符合对齐要求而在结构体内存布局中插入的无意义字节。

举个例子，假设有以下结构体：

```
struct example {
    char a;
    int b;
};
```

在32位或64位系统中，`char`类型通常对齐到1字节，而`int`类型对齐到4字节。由于`a`占用1字节，接下来的3字节就会被填充，以保证`b`能够在4字节对齐的位置开始。这样，结构体的内存布局可能会是：

| 字节位置 | 内容 |
| -------- | ---- |
| 0        | `a`  |
| 1-3      | 填充 |
| 4-7      | `b`  |

这种填充使得结构体的总大小可能大于它的数据成员大小之和。因此，理解结构体的内存布局非常重要，尤其是当内存空间有限时，合理的结构体设计可以减少内存的浪费。

#### 1.3 结构体的对齐规则

结构体的对齐规则有时依赖于平台和编译器。一般来说，编译器会遵循以下基本规则：

1. **成员对齐要求**：结构体中的每个成员变量的存储地址必须是它本身对齐要求的倍数。例如，`int`通常要求4字节对齐，`char`通常对齐到1字节。
2. **结构体对齐要求**：结构体本身的对齐要求通常是其最大成员对齐要求的倍数。例如，如果结构体中有一个`double`（要求8字节对齐）和一个`char`（要求1字节对齐），那么结构体的对齐要求通常是8字节。
3. **内存填充**：编译器可能会在结构体成员之间插入填充字节，确保每个成员的对齐要求得到满足。

#### 1.4 结构体对齐的实际示例

考虑以下结构体：

```
#include <stdio.h>

struct example {
    char a;   // 1 byte
    int b;    // 4 bytes
    char c;   // 1 byte
};
```

在一个支持4字节对齐的平台上，`char`类型占用1字节，而`int`类型占用4字节，并且需要4字节对齐。因此，结构体的内存布局可能会如下所示：

| 字节位置 | 内容 |
| -------- | ---- |
| 0        | `a`  |
| 1        | 填充 |
| 2        | 填充 |
| 3        | 填充 |
| 4-7      | `b`  |
| 8        | `c`  |
| 9-11     | 填充 |

因此，这个结构体的大小将是12字节，而不是7字节（各个成员大小的和）。这种填充是为了保证`int`类型成员`b`的对齐要求得到满足。

#### 1.5 结构体的内存对齐优化

在编程中，如果我们希望减少内存浪费，可以使用编译器提供的对齐指令或关键字来控制结构体对齐。例如，在GCC中，可以使用`__attribute__((packed))`来关闭对齐，或者使用`#pragma pack`来控制结构体的对齐方式。这些指令有时可以用来减少结构体的内存占用，但可能会影响性能，因此要谨慎使用。

```
#pragma pack(1)  // 设置结构体按1字节对齐
struct example {
    char a;
    int b;
    char c;
};
```

### 二、联合体对齐

联合体（`union`）是C语言中的另一种复合数据类型，和结构体不同的是，联合体中的所有成员共享同一块内存空间。也就是说，联合体中每个成员的起始地址相同，只有一个成员能在同一时刻占用这块内存。

#### 2.1 联合体的内存布局

联合体的大小由其最大成员的大小决定。由于所有成员共享相同的内存空间，联合体的对齐要求通常是最大成员的对齐要求。

考虑以下联合体：

```
#include <stdio.h>

union example {
    char a;
    int b;
    double c;
};
```

在这个例子中，`char`类型的大小是1字节，`int`类型是4字节，`double`类型是8字节。因此，联合体的大小通常是8字节，因为它的最大成员`double`要求8字节对齐。

#### 2.2 联合体的对齐

联合体的对齐通常遵循以下规则：

1. **最大成员对齐**：联合体的对齐要求是其最大成员的对齐要求。例如，在上面的例子中，`double`类型要求8字节对齐，因此联合体的对齐要求是8字节。
2. **成员共享内存**：联合体中的所有成员共享同一内存空间，只有一个成员在任何给定时刻占用这块空间。由于这种共享，联合体的大小不等于所有成员的大小之和，而是最大成员的大小。

#### 2.3 联合体与结构体的对比

- **内存布局**：结构体的成员在内存中是并排存储的，而联合体的成员共享相同的内存空间。
- **对齐要求**：结构体的对齐要求是其最大成员的对齐要求，而联合体的对齐要求也取决于最大成员的对齐要求，但它的内存大小通常小于结构体。

#### 2.4 联合体的内存优化

和结构体一样，联合体也可以通过编译器指令进行优化。使用`#pragma pack`或`__attribute__((packed))`可以改变联合体的对齐方式，减少内存的浪费。

```
#pragma pack(1)  // 设置联合体按1字节对齐
union example {
    char a;
    int b;
    double c;
};
```
