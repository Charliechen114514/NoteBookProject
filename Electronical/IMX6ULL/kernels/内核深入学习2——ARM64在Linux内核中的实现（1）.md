# 内核深入学习2——ARM32与ARM64在Linux内核中的实现（1）

## 前言

​	这个是笔者阅读《奔跑吧Linux内核》的一部分笔记，和笔者的一些内核思考。笔者初学，当然会有很多不足的地方，恳请各位看官批评指正！

​	除非特殊表明，笔者这里介绍的都是AArch64架构，Arm32架构的部分笔者会特别的注明

### 从最宽泛的内存模型说起

​	对于存在MMU，也就是内存管理单元的处理器，我们的内存实际上被切分为两种经典的视图——对于真实的物理内存条而言，实际上只有真正的一片或者有限RAM，ROM，外设等等信息（也就是说，物理上的，我们看的着的），我们的数据是真实的放在这里。那另一个视图，也就是我们的编程/进程视图。每一个进程似乎都霸占了处理器（这就是一种虚拟化），好像独自占领了一个虚拟的内存条，这个内存条奇大无比。可以从0x0000 0000 0000 0000 到 0xFFFF FFFF FFFF FFFF。我们的程序完全不需要关心当前的地址是否实际上是其他进程所占用的，或者是否在物理上不可用，而是将这些细节剥离出去，减少了软件开发的耦合难度，相反，所有的检查/通过检查后的转化工作都交给了我们谈论过的MMU。

​	MMU使用经典的页表机制（后面我们会看到页表为了适应今天软件的发展做出的各种优化，这一点是笔者之前不所知道的）来搭建起来两者联系的桥梁。我们每一次向内存访问，都会被MMU所“拦截”，将我们在进程中使用的视图地址，实际上是存在一个更加使用广泛的术语——虚拟地址（因为你真拿这个地址就物理内存条找大概率扑空），按照MMU页表的指示做转化，得到的才是真正有效的物理地址。这个物理地址才真正存放我们的东西。

​	建立好上述的认知，我们才能进一步前进，理解这中间每一步到底发生了什么。

## 从页表说起

​	我们下面最想说的是——既然如此，我们的转化工作的细节是如何的呢？这是很自然的想法。对于AArch64而言，其MMU支持单一阶段的经典页表转化（也就是我们操作系统课上大伙最喜欢学的），也支持虚拟化扩展中的两步走阶段的页表转化。

​	我们现来聊一聊最基本的那个吧！单一过程的页表转化就是在

- 对于结果被缓存在了TLB中的场景，我们会直接查TLB表一下子拿到转化的结果。事情结束
- 对于没有缓存的，这就是TLB未命中场景，事情就会复杂一些，我们就必须快速的查询页表，一般的，AArch64启用的是4级页表，我们讨论的更多也是4级页表的细节方便我们的理解

​	对于TLB未命中的场景（处理器扑空，说明我们在做新的页表转化工作，虚拟地址和物理地址的联系没有放到台面上，我们没法一下子找到缓存的结果），我们需要做转化，**让我们以4KB页 + 物理总线48位来描述这个流程**：

1. 第一步**，瞄一眼虚拟地址的最高位是啥，我们依赖最高位选择TTBR寄存器**（TTBR寄存器有两个，分别维护了两个大的页表体系）

   > 问题：ARM64处理器的TTBR0和TTBR1中处理器是如何使用的呢？就是按照给定虚拟地址的最高位进行自动选择的。对于用户空间的地址，最高位总是0，因此选择TTBR0，反之对于内核着一些高位地址，则是TTBR1。

2. 第二步：这个TTBR本身的索引被`TTBR${n}_ELx`记住，搓过操作系统的朋友都知道，这是建立页表的时候我们自己选的位置，我们依赖`TTBR${n}_ELx`找到一级页表本身，对于我们讨论的情况，L0页表取出虚拟地址的39 ~ 47位这9位作为缩因，按照我们最喜欢的查表法拿到**2级页表的物理基地址**。

   为什么是物理基地址不是虚拟地址呢？嗯，你都做VA向PA转化的工作了，难不成还要循环查？

3. 第三步，重复上面的工作，直到找到我们的4级页表的对应的VA - PA索引对，这里存放着我们从47 - 12这个36位的物理地址基地址，这个时候，取出来虚拟地址的低12位，两者一个拼接，就能得到转化后的物理地址。

​	说完了上面的流程，我们就温习了一次流程。

​	下面说说ARM32位的，比如说，笔者玩的IMX6ULL上面跑的就是经典的ARMv7-A的32位的处理器。我们不考虑复杂的物理地址扩展的问题，只聊最基础的32位的查表过程。

​	ARMv7-A的MMU采用两级页表结构，将32位虚拟地址划分为多个索引段。以**典型的4KB页配置**为例，虚拟地址被划分为12位页内偏移、8位一级页表索引（页目录）和12位二级页表索引。这样来看，我们可以得到一个结论，**页的粒度决定了咱们的最后的OFFSET的位数，你看，4K就是12位表达嘛！**

1. 第一步：第一步**，瞄一眼虚拟地址的最高位是啥，我们依赖最高位选择TTBR寄存器**（TTBR寄存器有两个，分别维护了两个大的页表体系），这一点跟ARM64的流程完全一致（其中TTBR0通常用于用户进程地址空间，TTBR1用于内核空间。）
2. 第二部，利用一级页表项（页目录项）包含二级页表的物理基址或1MB大页的直接映射信息，和利用二级页表项则最终指向4KB物理页得到的基地址，并携带访问权限、缓存策略等属性。通过检查后一样组合偏移量和基地址得到我们的最终的物理地址

​	这样我们基本上掌握了最基本的处理器如何解决地址隔离与转化的问题了。

### L0到L3页表的构成

​	我们下一步，还需要看看，这些页表项自身是由啥构成的呢？

#### AArch64

##### **L0页表项**

作为页表遍历的起点，**L0页表通常由页表基址寄存器（TTBR0或TTBR1）指向**，其作用范围覆盖整个虚拟地址空间的最高位段。在标准的48位虚拟地址配置中，L0页表通过9位索引定位下一级页表（L1）的物理基址。页表项的63:12位存储L1页表的基地址（4KB对齐），而低12位则用于控制位：

- **Valid（位0）**：标志该条目是否有效。若为0，访问将触发页错误异常。
- **Type（位1）**：标识条目类型。0表示无效条目，1表示下一级页表（Block或Table类型）。
- **AttrIndx（位4:2）**：指向MAIR_ELx寄存器中的内存属性索引，定义该区域的缓存策略（如Device-nGnRnE或Normal Write-Back）。
- **NS（位5）**：非安全位，在TrustZone场景下区分安全与非安全内存访问。
- **AP（位7:6）**：访问权限位，控制用户/内核模式的读写权限（如只读、读写或无访问）。
- **SH（位9:8）**：共享性位，定义内存的共享域（如Non-shareable、Inner Shareable）。
- **AF（位10）**：访问标志位，硬件自动置1以标记页面被访问，支持页面回收算法。
  L0通常仅用于极端稀疏的地址空间管理，实际系统中可能直接使用L1作为顶级页表。

**L1页表项（层级1）**
L1页表承接L0的映射结果，其结构具备双重功能：若指向下一级页表（L2），则形成更细粒度的地址划分；若直接映射大页（如1GB块），则终止遍历。在1GB大页模式下，页表项的47:30位存储目标物理地址的高18位（1GB对齐），此时虚拟地址的L1索引段（9位）和后续L2/L3索引段被忽略。大页映射的关键控制位包括：

- **Contiguous（位52）**：连续位，标志相邻条目映射连续物理块，允许TLB合并优化。
- **PXN（位53）**/ **UXN（位54）**：特权/用户模式执行禁止位，防范代码注入攻击。
- **DBM（位55）**：脏位修饰符，配合硬件自动管理页面的脏状态（写操作标记）。
  L1页表在服务器场景中常用于映射大块内核空间或直接分配巨型内存区域。

**L2页表项（层级2）**
L2页表在常规四级配置中指向L3页表，但亦可直接映射2MB大页。其字段布局与L1类似，物理地址字段（47:21）对应2MB页基址。此层级的关键特性在于支持混合粒度映射——同一L2页表中可同时包含指向L3的条目和直接映射2MB页的条目。这为操作系统提供了灵活的内存分配策略，例如将频繁访问的数据段映射为大页以减少TLB压力，而堆栈等动态区域采用4KB页以节约物理内存。

**L3页表项（层级3）**
作为页表遍历的终点，L3页表项直接映射4KB物理页，其47:1247:12位存储物理页基址。此层级的控制位新增了与细粒度权限相关的特性：

- **nG（位11）**：非全局位，标记条目是否进程专属（TLB刷新时根据ASID决定是否失效）。
- **DBM（位55）**：与L1/L2协同工作，确保脏页追踪的一致性。
- **GP（位50）**：保护位，与AP组合实现特权级访问的二次校验。
  L3页表项是用户进程内存管理的核心载体，通过精确控制4KB页的权限和属性，实现内存保护与隔离。

这一部分是笔者直接摘取的资料。

在不启用LPAE时，Arm32采用两级页表结构（一级页表称为**页目录**，二级页表称为**页表**），支持4KB小页和1MB大页映射。虚拟地址划分为以下字段（以4KB页为例）：

- **一级索引（12位）**：定位页目录项。
- **二级索引（8位）**：定位页表项。
- **页内偏移（12位）**：定位4KB页内的具体地址。

#### AArch32

##### **一级页表项（页目录项）**

一级页表项长度为32位，其字段定义如下：

- **基地址字段（Bits 31:10）**：
  若条目映射1MB大页（Section），此字段存储物理地址的高22位（1MB对齐），直接合成物理地址；
  若条目指向二级页表，此字段存储二级页表的物理基地址（4KB对齐）。
- **类型字段（Bits 1:0）**：
  - `0b01`：粗粒度页表（指向二级页表，支持4KB页）。
  - `0b10`：1MB大页（Section）。
- **内存属性字段**：
  - **AP（Bits 11:10）**：访问权限（如特权/用户模式读写控制）。
  - **Domain（Bits 8:5）**：域标识符，与CP15的DACR寄存器配合实现域级权限检查。
  - **C、B（Bits 3:2）**：缓存策略（如Write-Through或Write-Back）。
  - **XN（Bit 4）**：执行禁止位（防止代码执行）。

##### **二级页表项（页表项）**

当一级页表项指向二级页表时，二级页表项定义4KB页的映射细节：

- **基地址字段（Bits 31:12）**：4KB页的物理基地址（高20位）。
- **内存属性字段**：
  - **AP（Bits 9:8）**：细化访问权限（覆盖一级页表的AP设置）。
  - **C、B（Bits 3:2）**：独立缓存策略（允许覆盖一级配置）。
  - **XN（Bit 0）**：执行禁止位。
- **全局位（G, Bit 17）**：标记是否为全局页（TLB刷新时保留条目）。
- **共享位（S, Bit 16）**：指示内存是否可被多核共享。

## Linux内核是如何协调这些抽象的？

​	让我们来看看Linux内核中是如何架起来页表的抽象的

- PGD：页全局目录 L0
- PUD：页上级目录 L1
- PMD：页中间目录 L2
- PT: 页表 L3

​	这就是我们的大致的对应关系。具体的位数跟我们刚刚介绍的一摸一样，所以没啥好讲的。更加详细的定义可以去查看`arch/arm64/include/asm/pgtable.h`和`arch/arm64/include/asm/pgtable-*.h`的内容，笔者这里不展开讨论了。笔者计划在下一篇博客详细聊聊