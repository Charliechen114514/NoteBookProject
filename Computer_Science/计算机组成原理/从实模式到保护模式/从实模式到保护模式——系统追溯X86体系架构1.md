# 从实模式到保护模式——系统追溯X86体系架构

## 什么是处理器

​	处理器是一个“器”，即器件，不太大，有的是长方形，有的是正方形，就像饼干。实际上，它是一块集成电路。如图2-2 所示，在处理器的底部或者四周，有大量的引脚，可以接受从外面来的电信号，或者向外发出电信号。**每个引脚都有自己的用处，在往电路板上安装的时候，不能接错**。所以，如图中所示，处理器在生产的时候，都会故意缺一个角，这是一个参照标志，可以确保安装的人不会弄错。当然，并不是所有的处理器都会缺一个角，这不是一个固定不变的做法。处理器的引脚很多，其中有一部分是用来将参与运算的数字送入处理器内部。**有些引脚是复用的，假如现在要进行加法运算，那么我们要重复使用这些引脚，来依次将被加数和加数送入。**

​	一旦被加数通过引脚送入处理器，代表这个二进制数字的一组电信号就会出现在与引脚相连的内部线路上。这是一排高低电平的组合，代表着二进制数中的每一位。这时候，必须用一个称为**寄存器（Register）**的电路锁住。之所以要这样做，是因为相同的引脚和线路马上还要用于输入加数。也正是因为这个原因，这些内部线路称为处理器内部总线。

## 什么是寄存器

​	寄存器是双向器件，可以在一端接受输入并加以锁存，同时，它也会在另一端产生一模一样的输出。我想大部分马上就可以猜出——这说明寄存器可以存住我们想要让它存储的比特，在需要的时候释放取出

​	寄存器送出的数可以被送向算术逻辑单元，或者算术逻辑部件（Arithmetic Logic Unit，ALU）。它是专门负责运算的电路，可以计算加法、减法或者乘法，也可做逻辑运算。也就是说，我们稍后学习到的汇编这门编程语言以及其他一切更加高级的语言都是在这里完成的！

​	处理器内部有一个控制器，在指令的执行过程中，它负责给各个部件发送控制信号，使各个部件在某个正确的时间点上执行某个动作。同时，它还负责决定在某个时间点上哪个部件有权使用总线，以免彼此发生冲突。

​	**16 位寄存器可以存放2 个字节，这称为1 个字（word）**，各个数位的编号分别是0～15，其中0～7 是低字节，8～15 是高字节。实际上，“字”的概念出现得很早，也并非指16 个比特。只是到了后来，才特指16个二进制位的长度。32 位寄存器可以存放4 个字节，这称为1 个双字（double word），各个数位的编号分别是0～31，其中0～15 是低字，16～31 是高字。尽管图中没有画出，但是64 位寄存器可以容纳更多的比特，也就是8 个字节，或者4 个字。

​	内存中的每字节都对应着一个地址，第1 个字节的地址是0000H，第2 个字节的地址是0001H，第3 个字节的地址是0002H，其他以此类推。注意，这里采用的是十六进制表示法。作为一个例子，因为这个内存的容量是65536 字节，所以最后一个字节的地址是FFFFH。

​	8086 处理器内部有**8 个16 位的通用寄存器**，分别被命名为AX、BX、CX、DX、SI、DI、BP、SP。“通用”的意思是，它们之中的大部分都可以根据需要用于多种目的。因为这8 个寄存器都是16 位的，所以通常用于进行16 位的操作。比如，可以在这8 个寄存器之间互相传送数据，它们之间也可以进行算术逻辑运算；也可以在它们和内存单元之间进行16 位的数据传送或者算术逻辑运算。同时，如图2-7 所示，这8 个寄存器中的前4 个，即AX、BX、CX 和DX，又各自可以拆分成两个8 位的寄存器来使用，总共可以提供8 个8位的寄存器AH、AL、BH、BL、CH、CL、DH 和DL。这样一来，当需要在寄存器和寄存器之间，或者寄存器和内存单元之间进行8 位的数据传送或者算术逻辑运算时，使用它们就很方便。

## 什么是指令

​	**处理器的设计者用某些数来指示处理器所进行的操作，这称为指令（Instruction）**，或者叫机器指令，因为只有处理器才认得它们。前面已经说了，处理器内部有寄存器和负责运算的部件，控制器“分析”一个个指令，然后确定在哪个时间点让哪些部件进行工作。比如，指令F4H 表示让处理器停机，当处理器取到并执行这条指令后，就停止工作。指令是集中存放在内存里的，一条接着一条，处理器的工作是自动按顺序取出并加以执行。

​	处理器是自动化的器件，在给出了起始地址之后，它将从这个地址开始，自动地取出每条指令并加以执行。只要每条指令都正确无误，它就能准确地知道下一条指令的地址。这就意味着，完成某个工作的所有指令，必须集中在一起，处于内存的某个位置，形成一个段，叫做代码段。事情是明摆着的，要是指令并没有一条挨着一条存放，中间夹杂了其他非指令的数据，处理器将因为不能识别而出错。为了做某件事而编写的指令，它们一起形成了我们平时所说的程序。程序总要操作大量的数据，这些数据也应该集中在一起，位于内存中的某个地方，形成一个段，叫做数据段。注意，我们并没有改变内存的物理性质，并不是真的把它分成几块。段的划分是逻辑上的，从本质上来说，是如何看待和组织内存中的数据。段在内存中的位置并不重要，因为处理器是可控的，我们可以让它从内存的任何位置开始取指令并加以执行。

## 为什么8086存在段寄存器


​	为了让你写的程序在卖给别人之后，可以在内存中的任何地方正确执行，就只能在编写程序的时候使用相对地址或者逻辑地址了，而不能使用真实的物理地址。当程序加载时，这些相对地址还要根据程序实际被加载的位置重新计算。在任何时候，**程序的重定位都是非常棘手的事情**。当然，也有好几种解决的办法。在8086 处理器上，这个问题特别容易解决，因为该处理器在访问内存时使用了分段机制，我们可以借助该机制。

​	为了在硬件一级提供对“段地址：偏移地址”内存访问模式的支持，处理器至少要提供两个段寄存器，分别是代码段寄存器（Code Segment，CS）和数据段寄存器（Data Segment，DS）。对CS 内容的改变将导致处理器从新的代码段开始执行。同样，在开始访问内存中的数据之前，也必须首先设置好DS 寄存器，使之指向数据段。除此之外，最重要的是，当处理器访问内存时，它把指令中指定的内存地址看成是段内的偏移地址，而不是物理地址。这样，一旦处理器遇到一条访问内存的指令，它将把DS 中的数据段起始地址和指令中提供的段内偏移相加，来得到访问内存所需要的物理地址。前面讲了如何从逻辑地址转换到物理地址，以使得程序的运行和它在内存中的位置无关。这种策略在很多处理器中得到了支持，包括8086处理器。但是，由于8086 自身的局限性，它的做法还要复杂一些。8086 内部有8 个16 位的通用寄存器，分别是AX、BX、CX、DX、SI、DI、BP、SP。其中，前四个寄存器中的每一个，都还可以当成两个8 位的寄存器来使用，分别是AH、AL、BH、BL、CH、CL、DH、DL。图2-12 8086 处理器内部组成框图在进行数据传送或者算术逻辑运算的时候，使用算术逻辑部件（ALU）。比如，将AX 的内容和CX 的内容相加，结果仍在AX 中，那么，在相加的结果返回到AX 之前，需要通过一个叫数据暂存器的寄存器中转。处理器能够自动运行，这是控制器的功劳。

​	为了加快指令执行速度，8086 内部有一个6 字节的指令预取队列，在处理器忙着执行那些不需要访问内存的指令时，指令预取部件可以趁机访问内存预取指令。这时，多达6 个字节的指令流可以排队等待解码和执行。8086 内部有4 个段寄存器。其中，CS 是代码段寄存器，DS 是数据段寄存器，ES 是附加段（Extra Segment）寄存器。附加段的意思是，它是额外赠送的礼物，当需要在程序中同时使用两个数据段时，DS 指向一个，ES 指向另一个。可以在指令中指定使用DS 和ES 中的哪一个，

​	如果没有指定，则默认是使用DS。SS 是栈段寄存器，以后会讲到，而且非常重要。IP 是指令指针（Instruction Pointer）寄存器，它只和CS 一起使用，而且只有处理器才能直接改变它的内容。当一段代码开始执行时，CS 指向代码段的起始地址，IP 则指向段内偏移。这样，由CS 和IP 共同形成逻辑地址，并由总线接口部件变换成物理地址来取得指令。然后，处理器会自动根据当前指令的长度来改变IP 的值，使它指向下一条指令。当然，如果在指令的执行过程中需要访问内存单元，那么，处理器将用DS 的值和指令中提供的偏移地址相加，来形成访问内存所需的物理地址。8086 的段寄存器和IP 寄存器都是16 位的，如果按照原先的方式，把段寄存器的内容和偏移地址直接相加来形成物理地址的话，也只能得到16 位的物理地址。麻烦的是，8086 却提供了20根地址线。换句话说，它提供的是20 位的物理地址。提供20 位地址线的原因很简单，16 位的物理地址只能访问64KB 的内存，地址范围是0000H～FFFFH，共65536 个字节。这样的容量，即使是在那个年代，也显得捉襟见肘。注意，这里提到了一个表示内存容量的单位“KB”。为了方便，我们通常使用更大的单位来描述内存容量，比如千字节（KB）、兆字节（MB）和吉字节（GB），它们之间的换算关系如下：所以，65536 个字节就是64KB，而20 位的物理地址则可以访问多达1MB 的内存，地址范围从00000H 到FFFFFH。问题是，16 位的段地址和16 位的偏移地址相加，只能形成16 位的物理地址，怎么得到这20位的物理地址呢？为了解决这个问题，8086 处理器在形成物理地址时，先将段寄存器的内容左移4 位（相当于乘以十六进制的10，或者十进制的16），形成20 位的段地址，然后再同16 位的偏移地址相加，得到20 位的物理地址。比如，对于逻辑地址F000H:052DH，处理器在形成物理地址时，将段地址F000H 左移4 位，变成F0000H，再加上偏移地址052DH，就形成了20 位的物理地址F052DH。这样，因为段寄存器是16 位的，在段不重叠的情况下，最多可以将1MB 的内存分成65536个段，段地址分别是0000H、0001H、0002H、0003H，……，一直到FFFFH。在这种情况下，如图2-13 所示，每个段正好16 个字节，偏移地址从0000H 到000FH。

## 计算机的上电与复位

​	计算机的加电和复位在处理器众多的引脚中，有一个是RESET，用于接受复位信号。每当处理器加电，或者RESET 引脚的电平由低变高时[1] ，处理器都会执行一个硬件初始化，以及一个可选的内部自测试（Build-in Self-Test，BIST），然后将内部所有寄存器的内容初始到一个预置的状态。比如，对于Intel 8086 来说，复位将使代码段寄存器（CS）的内容为0xFFFF，其他所有寄存器的内容都为0x0000，包括指令指针寄存器（IP）。8086 之后的处理器并未延续这种设计，但毫无疑问，无论怎么设计，都是有目的的。处理器的主要功能是取指令和执行指令，加电或者复位之后，它就会立刻尝试去做这样的工作。不过，在这个时候，内存中还没有任何有意义的指令和数据，它该怎么办呢？

​	在揭开谜底之前，我们先来看看内存的特点。为了节约成本，并提高容量和集成度，在内存中，每个比特的存储都是靠一个极其微小的晶体管，外加一个同样极其微小的电容来完成的。可以想象，这样微小的电容，其泄漏电荷的速度当然也非常快。所以，个人计算机中使用的内存需要定期补充电荷，这称为刷新，所以这种 存 储 器 也 称 为 **动 态 随 机 访 问 存 储 器 （ Dynamic Random AccessMemory，DRAM）**。随机访问的意思是，访问任何一个内存单元的速度和它的位置（地址）无关。举个例子来说，从头至尾在一盘录音带上找某首歌曲，它越靠前，找到它所花的时间就越短。但内存就不一样，读写地址为0x00001 的内存单元，和读写地址为0xFFFF0 的内存单元，所需要的时间是一样的。在内存刷新期间，处理器将无法访问它。这还不是最麻烦的，最麻烦的是，在它断电之后，所有保存的内容都会统统消失。所以，每当处理器加电之后，它无法从内存中取得任何指令。

​	Intel 8086 可以访问1MB 的内存空间，地址范围为0x00000 到0xFFFFF。出于各方面的考虑，计算机系统的设计者将这1MB 的内存空间从物理上分为几个部分。8086 有20 根地址线，但并非全都用来访问DRAM，也就是内存条。事实上，这些地址线经过分配，大部分用于访问DRAM，剩余的部分给了只读存储器ROM 和外围的板卡，如图4-2 所示。图4-2 8086 系统的内存空间分配与DRAM 不同，只读存储器（Read Only Memory，ROM）不需要刷新，它的内容是预先写入的，即使掉电也不会消失，但也很难改变。这个特点很有用，比如，可以将一些程序指令固化在ROM 中，使处理器在每次加电时都自动执行。处理器醒来后不能饿着，这是很重要的。在以Intel 8086 为处理器的系统中，ROM 占据着整个内存空间顶端的64KB，物理地址范围是0xF0000～0xFFFFF，里面固化了开机时要执行的指令；DRAM 占据着较低端的640KB，地址范围是0x00000～0x9FFFF；中间还有一部分，分给了其他外围设备，这个以后再说。因为8086 加电或者复位时，CS=0xFFFF，IP=0x0000，所以，它取的第一条指令位于物理地址0xFFFF0，正好位于ROM 中，那里固化了开机时需要执行的指令。处理器取指令执行的自然顺序是从内存的低地址往高低地址推进。如果从0xFFFF0 开始执行，这个位置离1MB 内存的顶端（物理地址0xFFFFF）只有16 个字节的长度，一旦IP 寄存器的值超过0x000F，比如IP=0x0011，那么，它与CS 一起形成的物理地址将因为溢出而变成0x00001，这将回绕到1MB 内存的最低端。所以，ROM 中位于物理地

​	因此，目标位置的物理地址是0xfe05b。一旦执行这条指令，处理器将开始从指定的“段: 偏移”处开始重新取指令执行。

​	BIOS这块ROM 芯片中的内容包括很多部分，主要是进行硬件的诊断、检测和初始化。所谓初始化，就是让硬件处于一个正常的、默认的工作状态。最后，它还负责提供一套软件例程，让人们在不必了解硬件细节的情况下从外围设备（比如键盘）获取输入数据，或者向外围设备（比如显示器）输出数据。设备当然是很多的，所以这块ROM 芯片只针对那些最基本的、对于使用计算机而言最重要的设备，而它所提供的软件例程，也只包含最基本、最常规的功能。正因为如此，这块芯片又叫基本输入输出系统（Base Input & Output System，BIOS）ROM。当它完成自己的使命后，最后所要做的，就是从辅助存储设备读取指令数据，然后转到那里开始执行。基本上，这相当于接力赛中的交接棒。

## 硬盘及其工作原理

​	历史上，有多种辅助存储设备，比如软盘、光盘、硬盘、U 盘等，相对于内存，它们就是人们常说的“外存”，即外存储器（设备）。从软盘（Floppy Disk）启动计算机，这已经是过去的事了。软盘的尺寸比烟盒稍大一点，但是比较薄，采用塑料作为基片，上面是一层磁性物质，可以用来记录二进制位。这种塑料介质比较柔软，所以称为软盘。在数据记录原理上和软盘很相似的设备是硬盘（Hard Disk，HDD），而且它们几乎是同一个时代的产物。但是，与软盘不同，硬盘是多盘片、密封、高转速的，采用铝合金作为基片，并在表面涂上磁性物质来记录二进制位。这就使得它的盘片具有较高的硬度，故称为硬盘。

​	附着在盘片表面的扁平锥状物，就是用于在盘片上读写数据的磁头。为了进一步搞清楚硬盘的内部构造，图4-4 给出了更为详细的图示。硬 盘 可 以 只 有 一 个 盘 片 （ 这 称 为 单碟），也可能有好几个盘片。但无论如何，它们都串在同一个轴上，由电动机带动着一起高速旋转。一般来说，转速可以达到每分钟3600 转或者7200转，有的能达到一万多转，这个参数就是我们常说的“转/分钟”（Round PerMinute，RPM）。

​	每个磁头不是单独移动的。相反，它们都通过磁头臂固定在同一个支架上，由步进电动机带动着一起在盘片的中心和边缘之间来回移动。也就是说，它们是同进退的。步进电动机由脉冲驱动，每次可以旋转一个固定的角度，即可以步进一次。可以想象，当盘片高速旋转时，磁头每步进一次，都会从它所在的位置开始，绕着圆心“画”出一个看不见的圆圈，这就是磁道（Track）。磁道是数据记录的轨迹。因为所有磁头都是联动的，故每个盘面上的同一条磁道又可以形成一个虚拟的圆柱，称为柱面（Cylinder）。磁道，或者柱面，也要编号。编号是从盘面最边缘的那条磁道开始，向着圆心的方向，从0开始编号。柱面是一个用来优化数据读写的概念。初看起来，用硬盘来记录数据时，应该先将一个盘面填满后，再填写另一个盘面。实际上，移动磁头是一个机械动作，看似很快，但对处理器来说，却很漫长，这就是寻道时间。为了加速数据在硬盘上的读写，最好的办法就是尽量不移动磁头。这样，当0 面的磁道不足以容纳要写入的数据时，应当把剩余的部分写在1 面的同一磁道上。如果还写不下，那就继续把剩余的部分写在2 面的同一磁道上。换句话说，在硬盘上，数据的访问是以柱面来组织的。实际上，磁道还不是硬盘数据读写的最小单位，磁道还要进一步划分为扇区（Sector）。磁道很窄，也看不见，但在想象中，它仍呈带状，占有一定的宽度。将它划分许多分段之后，每一部分都呈扇形，这就是扇区的由来。每条磁道能够划分为几个扇区，取决于磁盘的制造者，但通常为63个。而且，每个扇区都有一个编号，与磁头和磁道不同，扇区的编号是从1 开始的。扇区与扇区之间以间隙（空白）间隔开来，每个扇区以扇区头开始，然后是512 个字节的数据区。扇区头包含了每个扇区自己的信息，主要有本扇区的磁道号、磁头号和扇区号，用来供硬盘定位机构使用。现代的硬盘还会在扇区头部包括一个指示扇区是否健康的标志，以及用来替换该扇区的扇区地址。用于替换扇区的，是一些保留和隐藏的磁道。尽管我们使用硬盘的历史很长，但它一直没能退出舞台，这主要是因为它总能通过不断提高自己的容量来打败那些竞争者。

​	20 世纪90 年代初，40MB 的硬盘算是常见的，能拥有200MB 的硬盘很让人羡慕。看看现在，500GB 的硬盘也不算稀罕，而且价钱也很便宜。前面说到，当ROM-BIOS 完成自己的使命之前，最后要做的一件事是从外存储设备读取更多的指令来交给处理器执行。现实的情况是，绝大多数时候，对于ROM-BIOS 来说，硬盘都是首选的外存储设备。硬盘的第一个扇区是0 面0 道1 扇区，或者说是0 头0 柱1 扇区，这个扇区称为主引导扇区。如果计算机的设置是从硬盘启动，那么，ROMBIOS 将 读 取 硬 盘 主 引 导 扇 区 的 内 容 ， 将 它 加 载 到 内 存 地 址0x0000:0x7c00 处（也就是物理地址0x07C00），然后用一个jmp 指令跳到那里接着执行：为什么偏偏是0x7c00 这个地方？还不太清楚。反正当初定下这个方案的家伙已经被人说了很多坏话，我也就不准备再多说什么了。通常，主引导扇区的功能是继续从硬盘的其他部分读取更多的内容加以执行。像Windows 这样的操作系统，就是采用这种接力的方法一步一步把自己运行起来的。