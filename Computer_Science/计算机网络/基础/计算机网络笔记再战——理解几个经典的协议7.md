# 理解几个经典协议——HTTP章

## 前言

​	笔者继续推进这个部分的内容是出于对后续笔者打算使用Web作点协作的应用程序所需要的。这里笔者需要理解一下HTTP协议，方便自己排查分析问题。

## 所以，啥是HTTP

​	显然，一个具备一定计算机常识的人，都知道我们在浏览器输入URL（统一资源定位器，也就是告知我们需要请求的资源的地址）的时候，我们以客户端（请求服务的一方）的身份，请求服务器（实现提供服务的一方）。

​	那么，我在之前的博客就提到了，在计算机互联网世界中，想要做到这个事情，就必须双方约定好一门协议。这个协议，就是我们的主角HTTP协议。

​	现代的万维网体系，也就是World Wide Web，实际上是由三个子模块搭建起来的——

- SGML（StandardGeneralized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）
- 作为文档传递协议的 HTTP 
- 指定文档所在地址的 URL（UniformResource Locator，统一资源定位符）。

## HTTP也是有多个版本的

​	一般我们可以见到的协议是HTTP1.0，HTTP1.1和HTTP2.0协议，这里如果你直接对他们的RFC文档，请参考笔者的参考资料章节

## URI

​	我们的一个主角是URI（统一资源标识符），URL（Uniform Resource Locator，统一资源定位符）。URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。

​	查询我们的RFC2396，我们的文档约定了URI中，我们的每一个单词的含义。

- Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http: 或 ftp:）也更容易。
- Resource：资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。
- Identifier：表示可标识的对象。也称为标识符。

​	所以，URI一句话就能说完：某个协议方案表示的资源的定位标识符

### URI的格式

#### 绝对的URI

```
协议://主机名[:端口]/路径/[?查询参数][#片段]
```

- **协议**：指定访问资源所使用的协议，如 http、https、ftp 等。
- **主机名**：资源所在的主机名或 IP 地址。
- **端口**（可选）：指定访问资源的端口号，默认情况下使用协议的默认端口（如 HTTP 的 80 端口）。
- **路径**：资源在服务器上的路径。
- **查询参数**（可选）：以 `?` 开头，包含键值对，用于向服务器传递参数。
- **片段**（可选）：以 `#` 开头，通常用于指定资源的某个部分。

## 所以，HTTP...

​	现在我们聚焦在HTTP上。

- HTTP就是一个用于客户端和服务器端之间的通信协议，其中，必然存在一方客户端一方服务端的情况
- 所以，服务于CS架构的HTTP，其请求必定由客户端发出，而服务器端回复响应

​	一个经典的HTTP1.1的请求报文长这个样子

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Connection: keep-alive
```

​	我们一个一个看：

- `GET`：请求方法，表示客户端希望获取资源。
- `/index.html`：请求目标，表示客户端请求的资源路径。
- `HTTP/1.1`：使用的 HTTP 协议版本。

​	第一行就是这三个要素组成的，表达了请求访问服务器的类型，也就是请求方法。

​	下一部分就是**请求头（Headers）**

- `Host: www.example.com`：指定请求的目标主机。
- `User-Agent: Mozilla/5.0`：标识客户端类型（浏览器或工具）。
- `Accept: text/html,...`：指定客户端能够接收的响应内容类型。
- `Accept-Language: en-US,en`：指定客户端优先接收的语言。
- `Connection: keep-alive`：指示客户端希望保持连接。

​	在下一部分就是我们的请求内容了，实际上对于GET没有，但是作为提交的POST和PUT有。

### HTTP不保存状态

​	HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

​	但是伴随着我们的互联网发展，大量的场景却要求我们有记忆，Cookie技术就是这样的补丁，笔者后续补充

### HTTP的请求方法

| 方法    | 说明                                                         | 支持的 HTTP 协议版本 |
| :------ | :----------------------------------------------------------- | :------------------- |
| GET     | 获取资源（GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。） | 1.0、1.1             |
| POST    | 传输实体主体（用来传输实体的主体）                           | 1.0、1.1             |
| PUT     | 传输文件（就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。） | 1.0、1.1             |
| HEAD    | 获得报文首部（用于确认URI 的有效性及资源更新的日期时间等。） | 1.0、1.1             |
| DELETE  | 删除文件（DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。） | 1.0、1.1             |
| OPTIONS | 询问支持的方法                                               | 1.1                  |
| TRACE   | 追踪路径                                                     | 1.1                  |
| CONNECT | 要求用隧道协议连接代理                                       | 1.1                  |
| LINK    | 建立和资源之间的联系                                         | 1.0                  |
| UNLINK  | 断开连接关系                                                 | 1.0                  |

## Cookie小论

​	Cookie 技术是一种**用于在客户端（通常是浏览器）和服务器之间保持状态的机制**。它本身就是用来把我们的HTTP记忆化，它的基本原理是服务器在响应客户端请求时，通过 HTTP 响应头中的 `Set-Cookie` 字段将一小段数据发送到客户端，客户端会将这些数据保存起来。当客户端再次向同一服务器发送请求时，会自动通过 HTTP 请求头中的 `Cookie` 字段将这些数据发送回服务器。这样，服务器就可以识别客户端的状态或身份，从而实现会话管理、用户偏好设置、购物车信息存储等功能。



## 参考资料

> HTTP1.0协议的RFC文档：[rfc1945.txt.pdf](https://www.rfc-editor.org/pdfrfc/rfc1945.txt.pdf)
>
> HTTP1.1协议的RFC文档：[rfc2616.txt.pdf](https://www.rfc-editor.org/pdfrfc/rfc2616.txt.pdf)
>
> HTTP2.0协议的RFC文档：[Enscript Output](https://www.rfc-editor.org/pdfrfc/rfc7540.txt.pdf)