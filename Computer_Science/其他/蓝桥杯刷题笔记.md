# 蓝桥杯刷题笔记

## 1.求解后若干位数的方法

​		以求解斐波那契数列为例，当我们想要查看后几位数字的时候，可以使用 模运算 来求取后几位数字！我们这个斐波那契的快速求解函数是

```C
long long getLastNum(int pos){
    
    int x1 = 1;
    int x2 = 1;
    int res = 0;
    
    for(int i = 2; i < n ; i++){
        res = x1 + x2;
        
        x1 = x2;
         
        x2 = res;
        
        res %= 100000;
    }
    
    return res;
}
```

​		这样我们就取到了后五位数了！

2. ## 排序与组合

​		现在看一个题目：

**本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。**

​		小蓝最近学习了一些排序算法，其中冒泡排序让他印象深刻。

​		在冒泡排序中，每次只能交换相邻的两个元素。

​		小蓝发现，如果对一个字符串中的字符排序，只允许交换相邻的两个字符， 则在所有可能		的排序方案中，冒泡排序的总交换次数是最少的。

​		例如，对于字符串 lan 排序，只需要 11 次交换。对于字符串qiao 排序，总共需要 44 次交换。

​		小蓝找到了很多字符串试图排序，他恰巧碰到一个字符串，需要 100 次交 换，可是他忘了吧这个字符串记下来，现在找不到了。

​		请帮助小蓝找一个只包含小写英文字母且没有字母重复出现的字符串，对 该串的字符排序，正好需要 100 次交换。如果可能找到多个，请告诉小蓝最短的那个。如果最短的仍然有多个，请告诉小蓝字典序最小的那个。

​		注意到，我们发现，为了尽可能短，需要我们让字符串尽可能的逆序！



​		于是，结合完全逆序数公式：对于给定的长度 $n$
$$
L = \frac{n \times (n-1)}{2}
$$
​		快速计算一下，发现是 15 时最小。这样，我们直接：

```C
"abcdefghigklmno" // 标准排列
```

​		然后完全逆序：

```C
"onmlkjihgfedcba"
```

​		但是这个的逆序数是105，不符合题意，需要调整，为了使逆序数最小，那就需要我们交换第一个和第六个，从而减小5 个逆序！

```C++
cout << "jonmlkihgfedcba";
```

## DP 1

![img](https://img-blog.csdnimg.cn/2fe8b81aaf044dd481c5819dbff6ca54.png)

```

#include <bits/stdc++.h>
using namespace std;
 
static int dp[1000][1000];
static int mp[1000][1000];

int main()
{
	int N;
	cin >> N;
	for(int i = 0; i< N;i++){
		for(int j = 0; j< N;j++){
			scanf("%d",&mp[i][j]);
		}
	}
	
	dp[0][0] = mp[0][0];
	for(int i = 1; i< N;i++){
		
		dp[i][0]  = dp[i-1][0]+mp[i][0];
		
	}
	
	for(int i = 1;i < N;i++){
		
		dp[0][i] = dp[0][i-1] + mp[0][i];
		
	}
	
	for(int i = 0;i < N; i++){
		for(int j = 0;j < N; j++){
			
			dp[i][j] = max(dp[i-1][j],dp[i][j-1])+mp[i][j];
			
			
		}
	}
	cout << dp[N-1][N-1];	
}

```

