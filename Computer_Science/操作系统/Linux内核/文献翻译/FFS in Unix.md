# FFS in Unix

[FFS.pdf (berkeley.edu)](https://people.eecs.berkeley.edu/~brewer/cs262/FFS.pdf)

​	这是一个介绍的是关于Unix文件系统革新的文章。

## 旧文件系统

​	早在贝尔实验室时期下的Unix文件系统是简单的——文件系统被用作是以组织磁盘的1种数据结构而诞生的它把每一个硬盘划分成一个或者多个的分区每个或者这些个分区上依次建立一个文件系统（注意这时是没有子文件系统一说的）。我们拿一个空闲链表来维护空闲的区域 。

​	在这个传统的文件系统当中每一个文件可以被独立的标识为是一个目录还是一个具体的字符块文件我们使用一个数据结构来描述他们：那就是inode。对于一个具体的文件inode会存储磁盘上属于这个文件范畴的块的编号。对应于那些特别大的文件——inode自身构成一个类于多孩子树一样的东西（高级inode有最多128个低级inode孩子。。。递归直到最底层的inode，那些确实在维护块号的inode），每一个底层的inode维护的块大小是固定的——512B

## 新文件系统

​	新文件系统是这样组织的！每一个或者硬盘可以有多个文件系统。一个文件系统是被他的超级块所描述。这个超级块放在文件系统的头部，因为超级快是有关键的数据，所以他会被多次拷贝（放到下面我要提到的cylinder group里）以防止这些关键信息的丢失造成灾难性的后果

​	这样的一些工作只会在文件系统被创立时才会产生！里头的数据中关于文件系统自身信息的描述并不会发生改变！一个描述文件系统的文件系统块是4096字节，而事实上这些文件系统块的大小可以是4096字节的2的整数倍或者最小就是4096字节！

​	在新的文件系统里硬盘被划分为一个或者多个叫做扇区组的东西。一个扇区组是由一个或者多个连续的扇区组成的！每一个这样的扇区组的前列都会有一些薄记信息来进行一定的维护。这些薄记里就有着超级块的备份拷贝，这些inodes结构体。还有一个位图来描述剩余可用的空间，还有其他更多详细的相关信息！其传统的政策是分配一个inode来维护磁盘组中每2048字节的空间大小！

### 存储优化

​	新文件系统的信息叫旧文件系统的信息有一个巨大的优化就是存储上的利用率提升了在旧的文件系统中无论这个文件有多小它都必须浪费一定的空间用一个block来存储，空间存在一定的浪费。

​	为了缓解这样的浪费我们会把一个一个扇区分为两个四个或者是八个的分片，而每一个这样的分片都是可寻址的！一般而言每一个分片的大小是一个硬盘分区的大小也就是512比特。在这里我们仍然会使用位图来描述分片哪些分片是空闲的！

​	所以在这个新的文件系统里，为这个文件分配硬盘的存储空间是遵循以下步骤的：

1. 如果这里有足够的空间来维护这个被新追加的文件那么这个足够的空间就会直接被写入这些可用的空间中
2. 如果这个文件你并没有包含被分片了的块或者说最后一块的剩余空间写不下这些全新的数据如果这个块已经被分配了或者说是被完全分配的那么这个空间将会被填充一些新的数据。如果还有剩那么一个完整的块将会被分配，然后写入这个新的数据，这个过程将会来回往复的持续。直到少于一个完整的块的新数据还被剩余没有被写入，那么接下来这些少于一个快的新数据将会分配以恰好容纳这些新数据的分片数量的空间，随后将这些新数据写入这组分片数量后我们结束文件的追加写入（也就是说那些没有被分片的会将会直接分配以新的足够容纳的块加上最后几个零散的扇区以存放新追加的数据）
3. 这个文件已经有了一个或者多个这样的分片，那么这个新的数据大小加上原先已经有了在分片中就数据的大小的和大于了一个完整的块！那么一个新的块将会被分配，这些分片的内容将会被拷贝到这个全新的块的起始，以及剩下的内容将会填充新数据！在之后大于一个块的余下数据这个过程跟我们在2中所描述的完全一致！

### 文件系统可以被配置

​	这里简短的说一下因为旧的文件系统中所有的参数是被写死的而在新的文件系统中程序员可以根据自身的需求进行一定的参数优化比如说最小块的大小如何一个inode可以维护多大的空间等等 

### 分布优化

​	文件系统的布局政策被分为两个截然不同的部分。在顶层则是全局的一些策略，在底下这一层则是关于每一个扇区分组的一些策略！这两套方法共同来提升文件系统的性能以减少磁盘搜寻所需最小数量。

​	我们操纵的就是管理我们如何分配数据结构，怎样分配数据结构来进行文件系统的优化。

​	一个我们可以操纵的资源那就是inode,inode被用来记描述文件也可以用来描述目录我们尽可能的把所有的inode的分在同一个扇区组内这样我们就可以减少磁盘搜寻次数也就是一次搜寻就可以拿到所有的inode进而管理到所有的文件

​	另一个呢就是数据块也就是inode指向的对象，我们尽可能会把这些数据会紧凑地放在一起！办法是如下的：

1. 首先它会优先尝试使用下一个临近的块，这个块应当不用怎样磁盘的旋转就可以找到（同一个扇区，旋转时间几乎不记）
2. 如果在同一个扇区内没有剩余的块那么我们会去搜寻同一扇区组内空闲的块
3. 如果整个扇区组都满了我们呢会用哈希表映射临近的扇区组去那个组里寻找空余的块
4. 如果这个办法已失效了我们则会在全局寻找空闲的块 

## 性能

​	可以参考文献

