## 理解并发，同步，异步，互斥，阻塞，非阻塞的理解

### 并发 (Concurrency)

​	针对单核CPU的说，实际上就是利用一些机制，让本来单核的CPU可以近似同时的运行多个任务，使得宏观上看起来像是同时进行。对于多核CPU，我们才有真正意义上的并发，这里更多的被称之为并行。

### 同步（逻辑串行的执行）

**同步**是指当一个任务需要依赖另一个任务的结果时，它会**等待**另一个任务完成并返回结果后，自己才继续执行。在同步模式下，任务的执行顺序是确定的。

- **特点：** 任务之间**顺序执行**，一个任务依赖另一个任务的结果并等待。
- **例子：** 你去咖啡店点咖啡。你告诉店员你的需求，然后**站在那里等待**店员把咖啡做好了交给你，你再离开。

### 异步 (逻辑并行的执行)

**异步**是指当一个任务发起一个操作后，它**不需要等待**该操作的完成，而是立即继续执行自己的其他任务。当被调用的操作完成后，会通过回调、消息、事件等机制通知发起者。

- **特点：** 任务之间**独立执行**，发起者不等待被调用者返回结果。
- **例子：** 你去咖啡店点咖啡。你告诉店员你的需求，然后店员给你一个取餐牌，你就可以**去旁边找座位等**，不用一直站在柜台前。咖啡做好了，店员会叫号或通过其他方式通知你来取。

### 互斥 (Mutual Exclusion)

**互斥**是指在多任务环境中，当多个任务共享同一个资源时，为了避免数据不一致或损坏，**任何时刻只允许一个任务访问该共享资源**。

- **特点：** 对共享资源的**独占访问**。
- **实现：** 通常通过**互斥锁 (Mutex)** 来实现。
- **例子：** 咖啡店里只有一台咖啡机。同一时间只能有一个店员使用这台咖啡机来制作咖啡，其他店员必须等待。

### 阻塞 (Blocking)

**阻塞**是指当一个任务（进程或线程）在执行某个操作时，如果该操作条件不满足（例如，等待I/O完成、等待锁释放、等待数据到达），那么该任务会**暂停执行**，放弃CPU，直到条件满足才能继续。

- **特点：** 任务**暂停**，释放CPU。
- **例子：** 你点完咖啡后，店员告诉你咖啡机坏了，需要维修。你**只能站在那里等**待咖啡机修好才能继续制作咖啡。

### 非阻塞 (Non-Blocking)



**非阻塞**是指当一个任务在执行某个操作时，如果操作条件不满足，它会**立即返回**，不会暂停执行。它会继续执行其他任务，并在稍后重新尝试该操作，或者通过轮询、事件通知等方式获取结果。

- **特点：** 任务**不暂停**，不释放CPU，立即返回。
- **例子：** 你点完咖啡后，店员告诉你咖啡机坏了。你**不用等在那里**，你可以选择先去看看菜单上的其他商品，或者去隔壁书店逛逛，过一会儿再回来问咖啡机修好了没有。

## 什么是线程同步和互斥

#### 线程同步 (Thread Synchronization)

​	基于我们刚刚讨论的同步，实际上就是将进程的同步下放到线程上，为了协调不同线程的执行顺序，确保它们按预期协作，并正确地访问共享资源，从而避免数据不一致或其他错误。它的目的是控制多个线程的**执行流程**，使其能够协同工作。

​	线程的同步更多是读写同一个共享变量或资源时，如果没有适当的同步机制，就可能发生竞态条件 (Race Condition)，导致数据损坏或逻辑错误。

**线程同步的主要目的：**

- **数据一致性：** 确保共享数据在多线程访问下的正确性。
- **协作：** 确保线程按照特定顺序或在特定条件下执行。

#### 线程互斥 (Thread Mutual Exclusion)

**线程互斥**是线程同步的一种特殊且非常重要的形式。它特指在任意时刻，**只允许一个线程访问某个共享资源（临界区）**，其他尝试访问该资源的线程必须等待，直到当前占有资源的线程释放它。

互斥是解决竞态条件最直接、最基本的方法之一。它保证了对临界资源的独占性访问，防止多个线程同时修改同一份数据而导致混乱。

**互斥与同步的关系：**

- **互斥是同步的一种实现手段或特殊形式。** 互斥主要是为了解决对共享资源的**竞争访问**问题，确保数据正确性。
- **同步的范围更广。** 除了互斥，同步还包括线程间的**协作**，例如一个线程等待另一个线程完成某个任务（如生产者-消费者模型中，消费者等待生产者生产数据）。

**可以把同步理解为“协调”或“合作”，而互斥理解为“排他性访问”。** 互斥通常是实现同步的重要组成部分。

------



## 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？



同步和阻塞之间存在紧密但非完全等同的关系。很多情况下，实现同步会**导致**线程阻塞，但并非所有同步机制都必然涉及阻塞，也不是所有阻塞都为了同步。

#### 同步不一定阻塞吗

虽然很多同步机制（如互斥锁、信号量、条件变量）在线程等待共享资源或满足特定条件时会导致线程阻塞，但也有一些同步方法是**非阻塞的**。

**非阻塞同步的例子：**

1. **自旋锁 (Spinlock)：** 当线程尝试获取自旋锁时，如果锁被占用，线程不会立即阻塞，而是会**忙等待**（循环检查锁是否可用），直到锁可用。这种方式在锁持有时间非常短的情况下效率更高，因为它避免了上下文切换的开销，但如果锁被长时间占用，会浪费CPU周期。
2. **原子操作 (Atomic Operations)：** 利用硬件指令实现对共享变量的原子性操作，例如`CAS (Compare And Swap)`。这些操作通常是无锁的，不会导致线程阻塞，因为它们在单个不可中断的CPU指令内完成。
3. **读写锁 (Read-Write Lock)：** 允许多个线程同时读取，但在写入时才互斥。读线程不会因为其他读线程的存在而阻塞。

所以，我们可以通过**阻塞**的方式来实现同步，但同步并非只有阻塞这一种实现方式。

#### 阻塞也不一定是为了同步

一个线程的阻塞可能是为了实现同步，但也可能是由于其他原因，与同步无关。

**阻塞不一定是为了同步的例子：**

1. **I/O阻塞：** 当线程进行文件读写、网络通信等I/O操作时，如果数据尚未准备好或设备繁忙，线程会进入阻塞状态，等待I/O操作完成。这与多线程间的共享资源访问（同步）无关，而是与底层设备操作的特性相关。
2. **睡眠 (Sleep)：** 线程主动调用`sleep()`函数，会进入阻塞状态一段时间。这纯粹是为了暂停自身执行，与等待其他线程或共享资源无关。
3. **等待子进程：** 父进程调用`wait()`或`waitpid()`等待子进程结束时，父进程会阻塞，直到子进程终止。这是一种进程间的协调，但通常不将其视为线程同步的范畴。

**总结：**

- **同步**是一个广义的概念，旨在协调多线程的执行和对共享资源的访问。它**可以**通过阻塞来实现，但也有非阻塞的实现方式。
- **阻塞**是指线程暂停执行并放弃CPU。它**可以**是同步机制的一部分，但也可以是由于I/O操作、主动睡眠等其他原因引起的，这些情况与多线程间的同步通常无关。

```
                  任务调度层面
               +-----------------+
               |    并发         |  (宏观并行)
               +-----------------+
                      /   \
                     /     \
                  同步    异步
                 (有依赖，等待)  (无依赖，不等待)
                      |       |
                可能导致       可能通过
                      |       |
                 阻塞      非阻塞 (或异步通知)
                  /       \
                 /         \
            主要用于       也用于 I/O 或
            控制对共享       主动等待等
            资源的访问
                 |
               互斥 (独占访问共享资源的一种同步手段)
```

## 孤儿进程、僵尸进程、守护进程的概念

#### 孤儿进程 (Orphan Process)

当一个**父进程在它的子进程之前终止**时，子进程就会成为**孤儿进程**。

- **特点：** 孤儿进程不会被系统立即终止。
- **归宿：** 在类Unix系统中，所有孤儿进程都会被**`init`进程 (PID 1)** 收养。`init`进程会负责收集孤儿进程的退出状态，避免它们变成僵尸进程。`init`进程是系统启动的第一个进程，是所有进程的祖先。
- **影响：** 孤儿进程通常不会对系统造成负面影响，因为有`init`进程负责清理。

#### 僵尸进程 (Zombie Process)

当一个**子进程终止后，但其父进程还没有调用`wait()`或`waitpid()`系统调用来获取其终止状态**，那么这个子进程就会变成**僵尸进程**。

- **状态：** 僵尸进程已经完成了执行，不再占用CPU时间或大部分内存资源，但其**进程描述符 (Process Descriptor)** 仍然保留在进程表中，等待父进程来收取其退出状态。
- **危害：** 僵尸进程本身危害不大，但如果存在大量僵尸进程（尤其是它们的父进程没有正确处理它们），它们会持续占用进程表中的条目。虽然它们不占用实际内存和CPU，但**进程表的容量是有限的**。如果进程表被僵尸进程耗尽，系统就无法创建新的进程，导致系统资源耗尽。
- **标识：** 在`ps`命令的输出中，僵尸进程通常显示为`Z`或`defunct`状态。

#### 守护进程 (Daemon Process)

**守护进程**是一种在后台运行，不受任何终端控制的特殊进程。它们通常在系统启动时被创建，并在系统关闭时终止。守护进程独立于控制终端，没有交互式界面，主要用于执行系统任务，如网络服务、日志记录等。

- **特点：**
  - **脱离控制终端：** 不与任何终端关联，即使终端关闭也不会终止。
  - **后台运行：** 不会显示在前台。
  - **生命周期长：** 通常从系统启动运行到系统关闭。
  - **通常以root用户身份运行：** 以便访问特权资源。
  - **通常在系统启动脚本中启动。**
- **用途：** Web服务器 (Nginx, Apache)、数据库服务 (MySQL, PostgreSQL)、SSH服务、cron定时任务等。

------



### 1.3.2 如何创建守护进程



创建守护进程（Daemonize）通常涉及一系列特定的步骤，以确保进程完全脱离控制终端并在后台稳定运行。以下是创建守护进程的典型步骤：

1. **创建子进程，终止父进程：**
   - 调用`fork()`。如果`fork()`成功且返回非零值（父进程），则父进程直接退出。这确保了父进程的终止，使得子进程不再是会话组长，为后续脱离控制终端做准备。
2. **在子进程中调用 `setsid()`：**
   - 子进程调用`setsid()`。这个系统调用会创建一个新的会话，并使当前进程成为该会话的**会话组长**和**进程组长**。
   - 同时，它会**脱离当前控制终端**。这是守护进程的关键一步。
3. **再次创建子进程，终止父进程（可选但推荐）：**
   - 再次调用`fork()`。如果`fork()`成功且返回非零值（父进程，即上一步中的子进程），则该父进程退出。
   - 这样做的目的是确保守护进程不是会话组长。因为会话组长可以重新获取控制终端，而二次`fork`后的孙子进程不再是会话组长，从而彻底杜绝了重新获得控制终端的可能性。
4. **改变当前工作目录到根目录 `/`：**
   - 调用`chdir("/")`。这样做是为了避免守护进程锁定文件系统中的某个目录，防止该目录被卸载。
5. **重设文件模式创建掩码 (umask)：**
   - 调用`umask(0)`。这会清除文件模式创建掩码，确保守护进程创建的文件拥有预期的权限，而不是受到调用者`umask`的限制。
6. **关闭所有打开的文件描述符：**
   - 遍历`0`到`sysconf(_SC_OPEN_MAX)`（或一个较大的固定值）范围内的所有文件描述符，并调用`close()`关闭它们。这包括标准输入 (stdin)、标准输出 (stdout) 和标准错误 (stderr)。
   - 守护进程不应与任何终端交互，所以这些文件描述符应该关闭。
7. **将标准输入、输出和错误重定向到 `/dev/null`：**
   - 通常，使用`open("/dev/null", O_RDWR)`打开`/dev/null`，然后使用`dup2()`将文件描述符`0` (stdin)、`1` (stdout) 和`2` (stderr) 重定向到这个打开的`/dev/null`。
   - 这确保了守护进程在尝试进行I/O时不会出错，并且任何输出都会被丢弃。
8. **（可选）实现日志记录：**
   - 守护进程通常需要记录运行状态、错误等信息，可以重定向到日志文件或使用系统日志服务（如syslog）。
9. **（可选）处理信号：**
   - 设置信号处理器，特别是忽略`SIGHUP`（挂断信号，会话组长收到后发送给会话中的所有进程）、`SIGTERM`（终止信号）等，以便守护进程能够平稳运行和终止。

**总结一个典型的C语言实现框架：**

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/stat.h>
#include <syslog.h> // For logging

void daemonize() {
    pid_t pid;

    // 1. 创建子进程，终止父进程
    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) { // 父进程退出
        exit(EXIT_SUCCESS);
    }

    // 2. 在子进程中调用 setsid()
    // 创建新会话，脱离控制终端
    if (setsid() < 0) {
        exit(EXIT_FAILURE);
    }

    // 3. （可选）再次创建子进程，终止父进程
    // 确保守护进程不是会话组长，防止它重新获取控制终端
    signal(SIGHUP, SIG_IGN); // 忽略SIGHUP信号
    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }
    if (pid > 0) { // 第二个父进程退出
        exit(EXIT_SUCCESS);
    }

    // 4. 改变当前工作目录到根目录
    if (chdir("/") < 0) {
        exit(EXIT_FAILURE);
    }

    // 5. 重设文件模式创建掩码
    umask(0);

    // 6. 关闭所有打开的文件描述符
    // _SC_OPEN_MAX 是系统允许的最大文件描述符数量
    for (int fd = sysconf(_SC_OPEN_MAX); fd >= 0; fd--) {
        close(fd);
    }

    // 7. 将标准输入、输出和错误重定向到 /dev/null
    open("/dev/null", O_RDWR); // stdin (fd 0)
    dup2(0, 1);                 // stdout (fd 1)
    dup2(0, 2);                 // stderr (fd 2)

    // （可选）初始化系统日志
    openlog("mydaemon", LOG_PID, LOG_DAEMON);
    syslog(LOG_NOTICE, "Daemon started.");
}

int main() {
    daemonize();

    // 守护进程的主要逻辑
    while (1) {
        // 执行守护任务，例如：
        syslog(LOG_INFO, "Daemon is running...");
        sleep(5); // 每5秒执行一次
    }

    closelog();
    return 0;
}
```

#### 正确处理僵尸进程的方法

僵尸进程的产生是子进程退出而父进程未回收其状态导致的，因此，正确处理僵尸进程的核心就是**确保父进程及时调用`wait()`或`waitpid()`**。

以下是几种常用的处理僵尸进程的方法：

1. **使用 `wait()` 或 `waitpid()` (最直接的方法)：**

   - **父进程显式等待：** 在子进程结束后，父进程调用`wait()`或`waitpid()`来等待子进程的终止，并回收其资源。

     - **`wait()`：** 阻塞父进程，直到任意一个子进程终止。
     - **`waitpid(pid, &status, options)`：** 可以等待特定的子进程，也可以使用`WNOHANG`选项使其非阻塞（如果子进程未终止则立即返回0）。

   - **适用场景：** 当父进程需要在子进程结束后才能继续执行时，或者子进程数量可控，可以方便地逐个等待。

   - **示例：**

     ```
     pid_t pid = fork();
     if (pid == 0) { // 子进程
         // do child work
         exit(0);
     } else if (pid > 0) { // 父进程
         int status;
         waitpid(pid, &status, 0); // 阻塞等待子进程
         // 子进程已回收
     }
     ```

2. **注册 `SIGCHLD` 信号处理函数：**

   - 当子进程终止时，系统会向其父进程发送`SIGCHLD`信号。父进程可以捕获这个信号，并在信号处理函数中调用`wait()`或`waitpid()`来回收子进程。

   - **优点：** 异步处理，父进程不需要阻塞等待子进程，可以继续执行自己的任务。

   - **缺点：** 信号处理函数有其局限性，例如在信号处理函数中不能执行可重入函数之外的操作。如果多个子进程同时退出，`SIGCHLD`信号可能被合并，导致一个`wait()`无法回收所有僵尸进程。因此，在信号处理函数中通常使用循环来调用`waitpid`，并设置`WNOHANG`选项。

   - **示例：**

     ```
     #include <signal.h>
     #include <sys/wait.h>
     
     void sig_chld_handler(int signo) {
         // 使用循环来回收所有僵尸子进程，防止信号合并导致漏回收
         while (waitpid(-1, NULL, WNOHANG) > 0);
     }
     
     int main() {
         // 注册SIGCHLD信号处理函数
         signal(SIGCHLD, sig_chld_handler);
     
         pid_t pid = fork();
         if (pid == 0) { // 子进程
             // do child work
             exit(0);
         } else if (pid > 0) { // 父进程
             // 父进程继续执行其他任务，子进程退出时会自动触发信号处理函数进行回收
             sleep(100);
         }
         return 0;
     }
     ```

3. **父进程忽略 `SIGCHLD` 信号：**

   - 通过将`SIGCHLD`信号的处理方式设置为`SIG_IGN`，可以告诉系统当子进程终止时，内核自动回收子进程的资源，而不需要父进程显式调用`wait()`。

   - **优点：** 最简单，无需编写额外的`wait()`代码。

   - **缺点：** 父进程将无法获取子进程的退出状态。

   - **适用场景：** 当父进程不关心子进程的退出状态时。

   - **示例：**

     ```
     #include <signal.h>
     
     int main() {
         // 忽略SIGCHLD信号
         signal(SIGCHLD, SIG_IGN);
     
         pid_t pid = fork();
         if (pid == 0) { // 子进程
             // do child work
             exit(0);
         } else if (pid > 0) { // 父进程
             // 父进程继续执行其他任务，子进程退出时会被自动回收
             sleep(100);
         }
         return 0;
     }
     ```

4. **二次 `fork` (创建守护进程时的常用策略)：**

   - 在创建守护进程时，常用两次`fork`。第一次`fork`后父进程退出，使得第一次创建的子进程（即守护进程本身）成为孤儿进程，被`init`进程收养。
   - 然后，这个被`init`收养的进程再进行第二次`fork`，并让它自己退出，留下一个孙子进程。这个孙子进程的父进程就是`init`进程。
   - 这样，当孙子进程退出时，它会成为`init`进程的僵尸子进程，并由`init`进程负责回收，从而避免了原始父进程（你的程序）创建僵尸进程的问题。
   - **适用场景：** 主要用于创建守护进程，因为守护进程通常不关心其子进程的退出状态，并且需要完全脱离控制终端和父进程。

选择哪种方法取决于具体的应用需求和对子进程退出状态的关注程度。对于大多数服务器程序，使用`SIGCHLD`信号处理函数并在其中循环调用`waitpid`是比较健壮和常用的方法。