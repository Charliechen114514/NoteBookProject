# 7.19（2）

## 现代C++

### 学习现代核心语言功能

在过去的几十年里，随着C++11的开发和发布，以及后来的新版本：C++14、C++17、C++20和C++23，C++语言经历了一场重大变革。这些新标准引入了新概念，简化和扩展了现有的语法和语义，并全面改变了我们编写代码的方式。与我们以前所知道的相比，C++11看起来和感觉上都是一种新语言，使用这些新标准编写的代码被称为现代C++代码。本章将从C++11开始介绍一些语言特性，这些特性可以帮助您完成许多编码例程。然而，语言的核心远远超出了本章所讨论的主题，本书的其他章节也讨论了许多其他特征。本章包含的配方如下：

- 尽可能使用auto创建类型别名和别名模板
- 理解统一初始化
- 理解各种形式的非静态成员
- 初始化控制
- 查询对象对齐
- 使用作用域枚举
- 对虚拟方法使用override和final
- 使用基于范围的for循环在范围上迭代
- 为自定义类型启用基于范围的for循环
- 使用显式构造函数和转换运算符避免隐式转换
- 使用未命名命名空间而非静态全局
- 使用内联命名空间
- 进行符号版本控制
- 使用结构化绑定处理多返回值
- 使用类模板参数推断简化代码
- 使用下标运算符访问集合中的元素

让我们从学习自动类型推断开始。尽可能使用auto自动类型推导是现代C++中最重要和最广泛使用的功能之一。新的C++标准使得在各种上下文中使用auto作为类型的占位符成为可能，让编译器推断出实际的类型。在C++11中，auto可用于声明局部变量，并用于具有尾随返回类型的函数的返回类型。在C++14中，auto可以用于函数的返回类型，而不指定尾随类型，也可以用于Lambda表达式中的参数声明。在C++17中，它可用于声明结构化绑定，本章末尾将对此进行讨论。在C++20中，它可以用所谓的缩写函数模板来简化函数模板语法。在C++23中，它可以用于对prvalue副本执行显式强制转换。未来标准版本可能会将auto的使用扩展到更多的情况。C++11和C++14中引入的auto的使用有几个重要的好处，所有这些都将在《它是如何工作的》一书中讨论。。。部分。开发人员应该意识到这一点，并尽可能使用auto。安德烈·亚历山德雷斯库（Andrei Alexandrescu）为此创造了一个实际的术语，并由赫伯·萨特（Herb Sutter）推广——几乎总是自动（AAA）(https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/).如何操作…在以下情况下，考虑使用auto作为实际类型的占位符：当你不想提交到特定类型时，用auto name=expression的形式声明局部变量：

```
auto i=42;//整数
auto d=42.5;//double
auto s=“text”;//char const*
auto v={1,2,3};//std:：initializer_list<int>当您需要提交到特定类型时，使用auto name=type id{expression}形式声明局部变量：
auto b=new char[10]{0};//char*
auto s1=std:：string{“text”};//std:：string
auto v1=std:：vector<int>{1,2,3};//std:：vector<int>
auto p=std:：make_shared<int>（42）;
```

以auto-name=lambda表达式的形式声明命名的lambda函数，除非需要将lambda传递或返回给函数：

```
auto upper = [](char const c){return toupper(c);}
```

声明lambda参数和返回值：

```
auto add=[]（auto const a，auto const b）{return a+b；}；
```

​	当你不想提交到特定类型时，要声明一个函数返回类型：

```
template<typename F，typename t>
auto apply(F&& f，T value){return F(value);}
```

#### 它是如何工作的。。。

自动说明符基本上是实际类型的占位符。使用auto时，编译器会从以下实例中推断出实际类型：

当使用auto声明变量时，根据用于初始化变量的表达式类型。

当auto用作函数返回类型的占位符时，从函数的尾随返回类型或返回表达式类型开始。

在某些情况下，有必要承诺特定类型。例如，在第一个例子中，编译器将s的类型推断为char const*。如果目的是有一个std:：string，那么必须明确指定类型。同样，v的类型被推断为：initializer_list<int>，因为它绑定到auto而不是特定类型；在这种情况下，规则说推导出的类型是td:：initializer_list<T>，在我们的例子中T是int。然而，意图可能是有一个std:：vector<int>。在这种情况下，必须在赋值的右侧明确指定类型。使用自动说明符而不是实际类型有一些重要好处；以下是最重要的列表：不可能让变量保持未初始化状态。这是开发人员在声明变量和指定实际类型时经常犯的错误。然而，对于auto来说，这是不可能的，因为auto需要初始化变量才能推断类型。使用已定义的值初始化变量很重要，因为未初始化的变量会导致未定义的行为。使用auto可确保您始终使用预期的类型，并且不会发生隐式转换。考虑以下示例，其中我们检索局部变量的向量大小。在第一种情况下，变量的类型是int，尽管size（）方法返回size_t。这意味着将发生从size_t到int的隐式转换。但是，使用auto作为类型将推断出正确的类型，即size_t:

```
auto v=std:：vector<int>{1,2,3}；//隐式转换，可能丢失数据
int size1=v.size（）；//好的
auto size2=v.size();//格式错误（gcc中的警告，clang&VC++中的错误）auto-size3=int{v.size()}；
```

​	使用auto可以促进良好的面向对象实践，例如将接口置于实现之上。这在面向对象编程（OOP）中很重要，因为它提供了在不同实现之间进行更改的灵活性、代码的模块化以及更好的可测试性，因为它很容易模拟对象。指定的类型数量越少，代码就越通用，对未来的更改也越开放，这是面向对象编程的基本原则。这意味着更少的打字（一般来说）和更少的关注我们无论如何都不关心的实际类型。通常情况下，即使我们明确指定了类型，我们实际上并不关心它。一个非常常见的情况是迭代器，但还有更多。当你想在一个范围内迭代时，你并不关心致畸物的实际类型。您只对迭代器本身感兴趣；因此，使用自动保存键入（可能很长）名称所花费的时间，并帮助您专注于实际代码而不是类型名称。在以下示例中，在firstfor循环中，我们显式使用迭代器的类型。这是大量的文本打字；长语句实际上会降低代码的可读性，您还需要知道类型名称，而您实际上并不关心它。带有自动说明符的第二个循环看起来更简单，可以省去键入和关心实际类型的麻烦：

```
std::map<int, std::string> m;
for(std::map<int, std::string>::const_iterator it = m.cbegin(); it != m.cend(); ++it)
{ 
	/*...*/ 
}

for (auto it = m.cbegin(); it != m.cend(); ++it){ /*...*/ 
```

​	使用auto声明变量提供了一种一致的编码风格，类型始终在右侧。如果你动态地分配对象，你需要在赋值的左侧和右侧都写类型，例如，int*p=new int（42）。使用auto时，仅在右侧指定一次类型。但是，使用auto时会有一些问题：auto说明符只是类型的占位符，而不是consumptive/volatile和引用说明符。如果你需要一个st/volatile和/或一个引用类型，那么你需要明确地指定它们。在以下示例中，get（）成员函数offoo返回对int的引用；当从返回值初始化变量x时，编译器推断的类型是int，而不是int&。因此，对x所做的任何更改都不会传播到foo.x_。为了做到这一点，我们应该使用auto&

```c++
#include <stdio.h>
#include <iostream>

class Foo
{
private:
    int x;
public:
    Foo(int const value = 0): x{value}{}
    int& get(){return x;}
};
int main(int, char**){
    Foo f(32);
    auto res = f.get();
    res = 100;
    std::cout << f.get() << std::endl;
}
```

​	不能对不可移动的类型使用自动：

```
auto nope = std::atomic<int>(42); //error
```

​	不能将auto用于多单词类型，如long long、long double或struct foo。然而，在第一种情况下，可能的解决方法是使用文字或类型别名；此外，使用Clang和GCC（但不是MSVC），可以将类型名称放在括号中，（long long）{42}。对于第二种情况，C++只支持使用这种形式的struct/class以兼容C，无论如何都应该避免:

```
auto l1 = long long{ 42 }; // error
using llong = long long;
auto l2 = llong{ 42 }; // OK
auto l3 = 42LL; // OK
auto l4 = (long long){ 42 }; // OK with gcc/clang
```

​	如果你使用了auto说明符，但仍然需要知道类型，那么在大多数IDE中，你可以通过将光标放在变量上来实现。然而，如果你离开IDE，那就不可能了，了解实际类型的唯一方法是自己从初始化表达式中推断出来，这可能意味着在代码中搜索函数返回类型。auto可用于指定函数的返回类型。在C++11中，这需要在函数声明中使用尾随返回类型。在C++14中，这一点已经放宽，返回值的类型由编译器从返回表达式中推断出来。如果有多个返回值，它们应该具有相同的类型：

```
auto func1(int const val) -> int
{ 
	return 2*i; 
}// C++14
auto func2(int const i)
{ 
	return 2*i; 
}
```

​	如前所述，auto不保留const/volatile和引用限定符。这会导致auto作为函数返回类型的占位符出现问题。为了解释这一点，让我们考虑前面的foo.get（）示例。这一次，我们有一个名为proxy_get（）的包装函数，它引用foo，调用get（），并返回get（）返回的值，即int&。但是，编译器会将proxy_get（）的返回类型推断为int，而不是int&。尝试将该值赋给int&失败，返回错误：

```
class foo{ 
int x_;
public: 
	foo(int const x = 0) :x_{ x } {} 
	int& get() { return x_; }
};

auto proxy_get(foo& f) { return f.get(); }
auto f = foo{ 42 };
auto& x = proxy_get(f); // cannot convert from 'int' to 'int &'
```

要解决这个问题，我们需要实际返回auto&。然而，模板和完美转发返回类型存在问题，而不知道它是值还是引用。C++14中这个问题的解决方案是decltype（auto），它将正确推断类型：

```
decltype(auto) proxy_get(foo& f){ return f.get(); }
auto f = foo{ 42 };
decltype(auto) x = proxy_get(f);
```

decltype说明符用于检查实体或表达式的声明类型。当声明类型很麻烦或根本无法用标准符号声明时，它最有用。这方面的示例包括声明lambda类型和依赖于模板参数的类型。最后一个可以使用auto的重要情况是使用lambdas。从C++14开始，lambda返回类型和lambda参数类型都可以是auto。这样的lambda被称为泛型lambda，因为lambda定义的闭包类型有一个模板化的调用运算符。下面显示了一个泛型clambda，它接受两个auto参数，并返回将operator+应用于实际类型的结果：

```
auto ladd = [] (auto const a, auto const b) { return a + b; }
```

编译器生成的函数对象具有以下形式，其中调用运算符是一个函数模板：

```
template<typename T, typename U> auto operator () (T const a, U const b) const { return a+b; }} L;
```

此lambda可用于添加任何定义了运算符+的内容，如以下代码段所示：

```
#include <string>
#include <iostream>

struct 
{
    template<typename T, typename U>
    constexpr auto operator()(T a, U b){return a + b;}
}L;

std::string operator""s(const char* h, size_t w){
    return {h};
}


int main()
{
    auto res = L("Come "s , "On!"s);
    std::cout << res;
}
```

