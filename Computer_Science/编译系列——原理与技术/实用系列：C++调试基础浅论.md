# 实用系列：C++调试基础浅论1

## 快速的说一说：什么是调试

​	事情是这样的，笔者最近在帮助一个兄弟，他在从编写demo程序到小型项目中就遇到了定位程序问题的困扰，这就意味着：他需要仔细的学习如何调试程序，来完成自己的调试目的。主要而言，还是去观察自己的系统到底在每一步的状态如何，问题出在了哪一个函数上。基于此，我们才有了调试的概念。

## 所以，什么是调试？

​	从工程角度讲，**调试就是让程序在受控环境下运行，观测状态与行为，定位并解释偏离预期的根因**。它既包括交互式的“打断点、单步、看变量”，也包括**事后分析**（根据崩溃转储/日志还原现场）。能否把**源代码语义**与**机器指令/内存**可靠地对应起来，是调试是否高效的分水岭——这依赖**调试符号**。DWARF（Unix/Linux 等常见）与 PDB（Windows/MSVC）就是两大主流符号格式。

​	基于此，你可能会理解，我们的构建，至少在一般的情况下，为什么会分出来Debug和Release的构建，这里，我们不再详细的区分他们到底哪些地方不一样，单纯从调试的侧面而言，Debug的构建也就是调试构建显然多了一些符号方便调试。具体的说，就是：包含在编译输出中的额外信息，目的是将机器码位置映射回源代码，更方便调试器显示源文件、函数名、变量名、行号等。

​	一般而言，我们常长讨论的调试符号至少需要包含这些内容：

- **符号名（Symbol Names）**：包含函数名、全局变量名等；
- **源文件与行号映射**：用于断点设定和调用栈反向追踪；
- **类型信息**（变量数据类型、结构/类、范围等）；
- **作用域与位置**：变量作用域（如局部或全局）、变量存储位置（寄存器、内存偏移）等；
- **宏定义**（如使用 `-g3` 时）等高级调试信息。

​	这些内容中我们一般可能会保存在我们的**符号文件**，他把“哪一行代码、哪个变量”映射到“哪段指令、哪个地址”，让调试器能显示源文件/行号、局部变量名、调用栈等；没有它，只能看汇编与地址。Windows 平台上，这个文件是 **.pdb**；MSVC/WinDbg/VS 调试器都会用到。

​	对于Linux/Unix操作系统，常见的 **DWARF** 以段/节方式随可执行文件或独立文件提供，供 gdb/lldb 等解析。所以不管怎么说，我们如果想要学习调试的底层原理，都需要再进一步的学习DWARF和PDB，当然这个不是我们的重点。

## 调试器

​	调试需要依靠调试器，这个我想大家都没什么意见。笔者用过的调试器就有gdb、lldb和Visual Studio自己家带有的调试器部分。

- **断点**：在指定源行/函数/地址暂停；可加条件、命中次数触发等。
- **单步**：step into/over/out 控制粒度；**运行到光标**、**继续运行**。
- **观察现场**：查看/修改**变量、寄存器、内存**；打印表达式；看**调用栈/栈帧**。
- **数据断点（硬件监视点/Watchpoint）**：当内存地址被读/写时暂停，适合追踪“是谁改了这块内存”。
- **异常/信号断点**：抛异常或收到 SIGSEGV 等时自动停下。

## 事后调试（Post-mortem）：崩溃之后怎么查

- **Windows**：由系统或应用生成 **Dump/Minidump**，包含线程、寄存器、调用栈、部分内存等。用 VS/WinDbg 加载 minidump 进行还原分析。
- **Unix/Linux**：启用 **core dump** 后，用 gdb/lldb 载入 *程序二进制 + core 文件* 进行还原分析（场景类似 Windows 的 dump）。
- 生产环境建议配合**符号服务器**集中管理各版本 PDB/二进制，避免“现场版本对不上导致看不懂栈”的窘境。

之后的系列笔者会尝试补充DWARF格式学习和其他部分的补充