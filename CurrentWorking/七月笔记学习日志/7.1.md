# 暑期学习7.1

## Linux Kernel Debugging

### Chapter I Base

​	什么是bug呢？Bug指的是在代码中发现的一处错误，而软件工程师的任务往往则是找到并且修复这些错误。修复这些错误的前提是找出他们。大部分错误都有这样的一些特点，他们不容易被察觉到，直到有一些事件发生这些bug被暴露出来。检查报告的基本办法就是实行单元测试进行覆盖性的测试，把软件每一种可能遇到的情况模拟进行排查，看是否符合我们的预期。一旦找到这些bug，我们的工作就是找到什么真正的根本的导致了这些bug以及我们应该如何恰当彻底的修复它，总而言之，寻找并排查bug的基本流程是通过测试发现bug，并且真正的解决它
​	一个正在工作的Linux系统，一般最小需要一个bootloader一个内核和一个根文件系统印象.
​	我们把部署到外界世界的系统倾向于称呼他叫生产系统和这个内核叫生产内核对于内核的配置，毫无疑问的是对整个项目的关键，也就是对内核的配置,构建,测试,调试以及部署.

​	对于企业级别的大型的项目，我们往往会部署到一些知名的稳定的发行板上，而对于那些运行在嵌入式设备上的Lennex，我们则是会使用最基础的主线内核，并且专门的定制化他从而发挥硬件设备的最大优势与兼容这些硬件的限制，算力条件的等。
​	一些调试的小技巧，首先要学会假设，也就是说我们可以平凡的使用断言来验证我们的假设，其次不要被这些复杂代码的路径，索尼惑，我们应当先从大的入手排查一些可能存在的问题，随后再去仔细思考底层的一些细节。值得注意的是调试所花费的精力往往是写他的两倍。所以在入手写代码之前，请务必构建好一个良好的框架，而不是事后出事后频繁的调试，在修改在我们书写调试或者构件代码的时候，要尽可能让代码变得简洁，而不是复杂，最后写一些调试案例的时候要尽可能覆盖所有的情况，而不是逃避他们。

### 优先级倒置

#### Issue 1

​	在嵌入式多任务实时操作系统（**real time multitask operating system**）中，为了实现多个线程同时运行（这是从一段时间上来说的，在单CPU系统中某一时刻只能有一个任务即线程运行）需要OS实现一种多个任务之间切换的机制（即任务的调度算法）。实时操作系统中常见的调度算法是优先级调度，给每个任务（线程）分配一个优先级。

​	优先级按任务需要执行的紧急状况来划分，一般优先级数值越低越先被OS调度执行。比如现有任务A和任务B，任务A比任务B更需要执行（即对系统来说任务A比任务B更紧急），可以给任务A分配优先级为1，给任务B分配优先级2(当然分配给任务A和B的优先级也可以是其它的数值，只要保证A的优先级数值比B的小即可)。

​    在多任务实时操作系统中，不可避免的是多个任务要访问相同的资源。为了避免出现多个任务同时访问共享资源造成系统混乱，需要一种同步机制来保证不会出现多个任务同时访问共享资源（即必须保证一个任务对共享资源操作完成后，才能然其他的线程来访问该资源）。同步原语中的互斥体（mutex）就是为了解决该问题而引入的（也就是既要允许多个线程访问共享资源，又要保证不会出现多个线程对共享资源的同时访问）。

​	先说互斥体：**互斥体实现了“互相排斥”（mutual exclusion）同步的简单形式（所以名为互斥体(mutex)）。互斥体禁止多个线程同时进入受保护的代码“临界区”（critical section）。因此，在任意时刻，只有一个线程被允许进入这样的代码保护区。任何线程在进入临界区之前，必须获取（acquire）与此区域相关联的互斥体的所有权。如果已有另一线程拥有了临界区的互斥体，其他线程就不能再进入其中。这些线程必须等待，直到当前的属主线程释放（release）该互斥体。什么时候需要使用互斥体呢？互斥体用于保护共享的易变代码，也就是，全局或静态数据。这样的数据必须通过互斥体进行保护，以防止它们在多个线程同时访问时损坏。**

​	互斥体的引入，带来了一个潜在的风险：那就是Priority Inversion。为了解释优先级倒置，首先假设现在有三个任务A， B， C（优先级分别是：３,２,１）；他们的优先级关系是：Ａ ＜Ｂ＜Ｃ并且Ａ和Ｃ需要访问共享资源。　

​	优先级倒置：当一个优先级任务通过同步机制（入mutex）访问共享资源时，如果该mutex已被一个低优先级任务（任务Ａ）占用（lock）,而这个低优先级任务正在访问共享资源时（unlock 互斥体之前）可能又被其他一些中等优先级的任务（任务Ｂ）抢先了（即任务Ｂ现在正在运行）．而如果此时，任务Ｃ（优先级比任务Ｂ高）除了需要的共享资源外运行任务Ｃ的条件都满足了（即现在任务Ｃ需要运行，但是被任务Ｂ阻塞了）。这样系统的实时性得不到保证，这就是优先级倒置问题。

　　产生原因：不同优先级线程对共享资源的访问的同步机制。优先级为１和３的线程Ｃ和线程Ａ需要访问共享资源，优先级为２的线程Ｂ不访问该共享资源。当Ａ正在访问共享资源时，Ｃ等待互斥体，但是此时Ａ被Ｂ抢先了，导致Ｂ运行Ｃ阻塞。即优先级低的线程Ｂ运行，优先级高的Ｃ被阻塞。

​	解决方法：

- 方法1：将程序代码进行适当的组织安排，避免优先级倒置的发生（确保互斥体不被处于不同优先级的线程所共享）。
- 方法2：优先级置顶协议（priority ceiling protocol）:占有互斥体的线程在运行时的优先级比任何其他可以回去该互斥体的线程的优先级都要高。使用优先级置顶协议时，每个互斥体都被分配一个优先级，该优先级通常与所有可以拥有该互斥体的线程中的最高优先级相对应。当优先级较低的线程占有互斥体后，该线程的优先级被提升到该互斥体的优先级。
- 方法3：优先级继承协议（Priority Inheritance Protocol）:将占有互斥体的线程优先级提升到所有正在等待该互斥体的线程优先级的最高值。

#### Issue 2

在多进程、多线程并发的环境里，从概念上看，有多个进程或者多个线程在同时执行，具体到单个CPU级别，实际上任何时刻只能有一个进程或者线程处于执行状态；因此OS需要决定哪个进程执行，哪些进程等待，也就是进程的调度。
一、调度的目标
1、首先要区分程序使用CPU的三种模式：IO密集型、计算密集型和平衡型。对于IO密集型程序来说，响应时间非常重要；对于CPU密集型来说，CPU的周转时间就比较重要；对于平衡型程序来说，响应和周转之间的平衡是最重要的。
2、CPU的调度就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种公平的机制。
3、对于实时系统来说，调度的目标就是要达到截止时间前完成所应该完成的任务和提供性能的可预测性。

二、调度算法

1、FCFS（First come first serve)，或者称为FIFO算法，先来先处理。这个算法的优点是简单，实现容易，并且似乎公平；缺点在于短的任务有可能变的非常慢，因为其前面的任务占用很长时间，造成了平均响应时间非常慢。

2、时间片轮询算法，这是对FIFO算法的改进，目的是改善短程序（运行时间短）的响应时间，其方法就是周期性地进行进程切换。这个算法的关键点在于时间片的选择，时间片过大，那么轮转就越接近FIFO，如果太小，进程切换的开销大于执行程序的开销，从而降低了系统效率。因此选择合适的时间片就非常重要。选择时间片的两个需要考虑的因素：一次进程切换所使用的系统消耗以及我们能接受的整个系统消耗、系统运行的进程数。
  时间片轮询看上起非常公平，并且响应时间非常好，然而时间片轮转并不能保证系统的响应时间总是比FIFO短，这很大程度上取决于时间片大小的选择，以及这个大小与进程运行时间的相互关系。

3、STCF算法（Short time to complete first)，顾名思义就是短任务优先算法。这种算法的核心就是所有的程序都有一个优先级，短任务的优先级比长任务的高，而OS总是安排优先级高的进程运行。
  STCF又分为两类：非抢占式和抢占式。非抢占式STCF就是让已经在CPU上运行的程序执行到结束或者阻塞，然后在所有的就绪进程中选择执行时间最短的来执行；而抢占式STCF就不是这样，在每进来一个新的进程时，就对所有进程（包括正在CPU上执行的进程）进行检查，谁的执行时间短，就运行谁。

  STCF总是能提供最优的响应时间，然而它也有缺点，第一可能造成长任务的程序无法得到CPU时间而饥饿，因为OS总是优先执行短任务；其次，关键问题在于我们怎么知道程序的运行时间，怎么预测某个进程需要的执行时间？通常有两个办法：使用启发式方法估算（例如根据程序大小估算），或者将程序执行一遍后记录其所用的CPU时间，在以后的执行过程中就可以根据这个测量数据来进行STCF调度。

4、优先级调度，STCF遇到的问题是长任务的程序可能饥饿，那么优先级调度算法可以通过给长任务的进程更高的优先级来解决这个问题；优先级调度遇到的问题可能是短任务的进程饥饿，这个可以通过动态调整优先级来解决。实际上动态调整优先级（称为权值）+时间片轮询的策略正是linux的进程调度策略之一的 SCHED_OTHER分时调度策略,它的调度过程如下：

（1）创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)。

（2）将根据每个任务的nice值确定在cpu上的执行时间(counter)。

（3）如果没有等待资源，则将该任务加入到就绪队列中。

（4）调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。

（5）此时调度程序重复上面计算过程，转到第4步。

（6）当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步。

linux还有两个实时进程的调度策略：FIFO和RR,实时进程会立即抢占非实时进程。

5、显然，没有什么调度算法是毫无缺点的，因此现代OS通常都会采用混合调度算法。例如将不同的进程分为几个大类，每个大类有不同的优先级，不同大类的进程的调度取决于大类的优先级，同一个大类的进程采用时间片轮询来保证公平性。

6、其他调度算法，保证调度算法保证每个进程享用的CPU时间完全一样；彩票调度算法是一种概率调度算法，通过给进程“发彩票”的多少，来赋予不同进程不同的调用时间，彩票调度算法的优点是非常灵活，如果你给短任务发更多“彩票”，那么就类似STCF调度，如果给每个进程一样多的“彩票”，那么就类似保证调度；用户公平调度算法，是按照每个用户，而不是按照每个进程来进行公平分配CPU时间，这是为了防止贪婪用户启用了过多进程导致系统效率降低甚至停顿。

7、实时系统的调度算法，实时系统需要考虑每个具体任务的响应时间必须符合要求，在截止时间前完成。
（1）EDF调度算法，就是最早截止任务优先（Earliest deadline first)算法，也就是让最早截止的任务先做。当新的任务过来时，如果它的截止时间更靠前，那么就让新任务抢占正在执行的任务。EDF算法其实是贪心算法的一种体现。如果一组任务可以被调度（也就是所有任务的截止时间在理论上都可以得到满足），那么EDF可以满足。如果一批任务不能全部满足（全部在各自的截止时间前完成），那EDF满足的任务数最多，这就是它最优的体现。EDF其实就是抢占式的STCF，只不过将程序的执行时间换成了截止时间。EDF的缺点在于需要对每个任务的截止时间做计算并动态调整优先级，并且抢占任务也需要消耗系统资源。因此它的实际效果比理论效果差一点。

（2）RMS调度算法，EDF是动态调度算法，而RMS（rate monotonic scheduling)算法是一种静态最优算法；该算法在进行调度前先计算出所有任务的优先级，然后按照计算出来的优先级进行调度，任务执行中间既不接收新任务，也不进行优先级调整或者CPU抢占。因此它的优点是系统消耗小，缺点就是不灵活了。对于RMS算法，关键点在于判断一个任务组是否能被调度，这里有一个定律，如果一个系统的所有任务的CPU利用率都低于ln2，那么这些任务的截止时间均可以得到满足，ln2约等于0.693147，也就是此时系统还剩下有30%的CPU时间。这个证明是Liu和Kayland在1973年给出的。

三、优先级反转
1、什么是优先级反转？
  优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。

2、解决方案：
（1）设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。

（2）优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。
  这里还有一个八卦，1997年的美国的火星探测器（使用的就是vxworks)就遇到一个优先级反转问题引起的故障。简单说下，火星探测器有一个信息总线，有一个高优先级的总线任务负责总线数据的存取，访问总线都需要通过一个互斥锁（共享资源出现了）；还有一个低优先级的，运行不是很频繁的气象搜集任务，它需要对总线写数据，也就同样需要访问互斥锁；最后还有一个中优先级的通信任务，它的运行时间比较长。平常这个系统运行毫无问题，但是有一天，在气象任务获得互斥锁往总线写数据的时候，一个中断发生导致通信任务被调度就绪，通信任务抢占了低优先级的气象任务，而无巧不成书的是，此时高优先级的总线任务正在等待气象任务写完数据归还互斥锁，但是由于通信任务抢占了CPU并且运行时间比较长，导致气象任务得不到CPU时间也无法释放互斥锁，本来是高优先级的总线任务也无法执行，总线任务无法及时执行的后果被探路者认为是一个严重错误，最后就是整个系统被重启。Vxworks允许优先级继承，然而遗憾的工程师们将这个选项关闭了。

（3）第三种方法就是使用中断禁止，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。 

### 各种menu config

```
"make config"      Plain text interface.

"make menuconfig"  Text based color menus, radiolists & dialogs.

"make nconfig"     Enhanced text based color menus.

"make xconfig"     Qt based configuration tool.

"make gconfig"     GTK+ based configuration tool.

"make oldconfig"   Default all questions based on the contents of
                   your existing ./.config file and asking about
                   new config symbols.

"make olddefconfig"
                   Like above, but sets new symbols to their default
                   values without prompting.

"make defconfig"   Create a ./.config file by using the default
                   symbol values from either arch/$ARCH/defconfig
                   or arch/$ARCH/configs/${PLATFORM}_defconfig,
                   depending on the architecture.

"make ${PLATFORM}_defconfig"
                   Create a ./.config file by using the default
                   symbol values from
                   arch/$ARCH/configs/${PLATFORM}_defconfig.
                   Use "make help" to get a list of all available
                   platforms of your architecture.

"make allyesconfig"
                   Create a ./.config file by setting symbol
                   values to 'y' as much as possible.

"make allmodconfig"
                   Create a ./.config file by setting symbol
                   values to 'm' as much as possible.

"make allnoconfig" Create a ./.config file by setting symbol
                   values to 'n' as much as possible.

"make randconfig"  Create a ./.config file by setting symbol
                   values to random values.

"make localmodconfig" Create a config based on current config and
                      loaded modules (lsmod). Disables any module
                      option that is not needed for the loaded modules.

                      To create a localmodconfig for another machine,
                      store the lsmod of that machine into a file
                      and pass it in as a LSMOD parameter.

                      Also, you can preserve modules in certain folders
                      or kconfig files by specifying their paths in
                      parameter LMC_KEEP.

              target$ lsmod > /tmp/mylsmod
              target$ scp /tmp/mylsmod host:/tmp

              host$ make LSMOD=/tmp/mylsmod \
                      LMC_KEEP="drivers/usb:drivers/gpu:fs" \
                      localmodconfig

                      The above also works when cross compiling.

"make localyesconfig" Similar to localmodconfig, except it will convert
                      all module options to built in (=y) options. You can
                      also preserve modules by LMC_KEEP.

"make kvm_guest.config"   Enable additional options for kvm guest kernel
                          support.

"make xen.config"   Enable additional options for xen dom0 guest kernel
                    support.

"make tinyconfig"  Configure the tiniest possible kernel.
```

### 如何现代的编译内核

[How to compile a Linux kernel in the 21st century | Opensource.com](https://opensource.com/article/19/8/linux-kernel-21st-century)

Image by: Opensource.com

In computing, **a kernel is the low-level software that handles communication with hardware and general system coordination.** Aside from some initial firmware built into your computer's motherboard, when you start your computer, the kernel is what provides awareness that it has a hard drive and a screen and a keyboard and a network card. It's also the kernel's job to ensure equal time (more or less) is given to each component so that your graphics and audio and filesystem and network all run smoothly, even though they're running concurrently.

The quest for hardware support, however, is ongoing, because the more hardware that gets released, the more stuff a kernel must adopt into its code to make the hardware work as expected. It's difficult to get accurate numbers, but the Linux kernel is certainly among the top kernels for hardware compatibility. Linux operates innumerable computers and mobile phones, embedded system on a chip (SoC) boards for hobbyist and industrial uses, RAID cards, sewing machines, and much more.

Back in the 20th century (and even in the early years of the 21st), it was not unreasonable for a Linux user to expect that when they purchased a very new piece of hardware, they would need to download the very latest kernel source code, compile it, and install it so that they could get support for the device. Lately, though, you'd be hard-pressed to find a Linux user who compiles their own kernel except for fun or profit by way of highly specialized custom hardware. It generally isn't required these days to compile the Linux kernel yourself.

Here are the reasons why, plus a quick tutorial on how to compile a kernel when you need to.

#### Update your existing kernel

Whether you've got a brand new laptop featuring a fancy new graphics card or WiFi chipset or you've just brought home a new printer, your operating system (called either GNU+Linux or just Linux, which is also the name of the kernel) needs a driver to open communication channels to that new component (graphics card, WiFi chip, printer, or whatever). It can be deceptive, sometimes, when you plug in a new device and your computer *appears* to acknowledge it. But don't let that fool you. Sometimes that *is* all you need, but other times your OS is just using generic protocols to probe a device that's attached.

For instance, your computer may be able to identify your new network printer, but sometimes that's only because the network card in the printer is programmed to identify itself to a network so it can gain a DHCP address. It doesn't necessarily mean that your computer knows what instructions to send to the printer to produce a page of printed text. In fact, you might argue that the computer doesn't even really "know" that the device is a printer; it may only display that there's a device on the network at a specific address and the device identifies itself with the series of characters *p-r-i-n-t-e-r*. The conventions of human language are meaningless to a computer; what it needs is a driver.

Kernel developers, hardware manufacturers, support technicians, and hobbyists all know that new hardware is constantly being released. Many of them contribute drivers, submitted straight to the kernel development team for inclusion in Linux. For example, Nvidia graphic card drivers are often written into the [Nouveau](https://nouveau.freedesktop.org/wiki/) kernel module and, because Nvidia cards are common, the code is usually included in any kernel distributed for general use (such as the kernel you get when you download [Fedora](http://fedoraproject.org/) or [Ubuntu](http://ubuntu.com/). Where Nvidia is less common, for instance in embedded systems, the Nouveau module is usually excluded. Similar modules exist for many other devices: printers benefit from [Foomatic](https://wiki.linuxfoundation.org/openprinting/database/foomatic) and [CUPS](https://www.cups.org/), wireless cards have [b43, ath9k, wl](https://wireless.wiki.kernel.org/en/users/drivers) modules, and so on.

Distributions tend to include as much as they reasonably can in their Linux kernel builds because they want you to be able to attach a device and start using it immediately, with no driver installation required. For the most part, that's what happens, especially now that many device vendors are now funding Linux driver development for the hardware they sell and submitting those drivers directly to the kernel team for general distribution.

Sometimes, however, you're running a kernel you installed six months ago with an exciting new device that just hit the stores a week ago. In that case, your kernel may not have a driver for that device. The good news is that very often, a driver for that device may exist in a very recent edition of the kernel, meaning that all you have to do is update what you're running.

Generally, this is done through a package manager. For instance, on RHEL, CentOS, and Fedora:

```bash
$ sudo dnf update kernel
```

On Debian and Ubuntu, first get your current kernel version:

```bash
$ uname -r
4.4.186
```

Search for newer versions:

```bash
$ sudo apt update
$ sudo apt search linux-image
```

Install the latest version you find. In this example, the latest available is 5.2.4:

```bash
$ sudo apt install linux-image-5.2.4
```

After a kernel upgrade, you must [reboot](https://opensource.com/article/19/7/reboot-linux) (unless you're using kpatch or kgraft). Then, if the device driver you need is in the latest kernel, your hardware will work as expected.

#### Install a kernel module

Sometimes a distribution doesn't expect that its users often use a device (or at least not enough that the device driver needs to be in the Linux kernel). **Linux takes a modular approach to drivers, so distributions can ship separate driver packages that can be loaded by the kernel even though the driver isn't compiled into the kernel itself.** This is useful, although it can get complicated when a driver isn't included in a kernel but is needed during boot, or when the kernel gets updated out from under the modular driver. The first problem is solved with an **initrd** (initial RAM disk) and is out of scope for this article, and the second is solved by a system called **kmod**.

The kmod system ensures that when a kernel is updated, all modular drivers installed alongside it are also updated. If you install a driver manually, you miss out on the automation that kmod provides, so you should opt for a kmod package whenever it is available. For instance, while Nvidia drivers are built into the kernel as the Nouveau driver, the official Nvidia drivers are distributed only by Nvidia. You can install Nvidia-branded drivers manually by going to the website, downloading the **.run** file, and running the shell script it provides, but you must repeat that same process after you install a new kernel, because nothing tells your package manager that you manually installed a kernel driver. Because Nvidia drives your graphics, updating the Nvidia driver manually usually means you have to perform the update from a terminal, because you have no graphics without a functional graphics driver.



![Nvidia configuration application](https://opensource.com/sites/default/files/uploads/nvidia.jpg)

However, if you install the Nvidia drivers as a kmod package, updating your kernel also updates your Nvidia driver. On Fedora and related:

```bash
$ sudo dnf install kmod-nvidia
```

On Debian and related:

```bash
$ sudo apt update
$ sudo apt install nvidia-kernel-common nvidia-kernel-dkms nvidia-glx nvidia-xconfig nvidia-settings nvidia-vdpau-driver vdpau-va-driver
```

This is only an example, but if you're installing Nvidia drivers in real life, you must also blacklist the Nouveau driver. See your distribution's documentation for the best steps.

#### Download and install a driver

Not everything is included in the kernel, and not everything *else* is available as a kernel module. In some cases, you have to download a special driver written and bundled by the hardware vendor, and other times, you have the driver but not the frontend to configure driver options.

Two common examples are HP printers and [Wacom](https://linuxwacom.github.io/) illustration tablets. If you get an HP printer, you probably have generic drivers that can communicate with your printer. You might even be able to print. But the generic driver may not be able to provide specialized options specific to your model, such as double-sided printing, collation, paper tray choices, and so on. [HPLIP](https://developers.hp.com/hp-linux-imaging-and-printing) (the HP Linux Imaging and Printing system) provides options to manage jobs, adjust printing options, select paper trays where applicable, and so on.

HPLIP is usually bundled in package managers; just search for "hplip."



![HPLIP in action](https://opensource.com/sites/default/files/uploads/hplip.jpg)

Similarly, drivers for Wacom tablets, the leading illustration tablet for digital artists, are usually included in your kernel, but options to fine-tune settings, such as pressure sensitivity and button functionality, are only accessible through the graphical control panel included by default with GNOME but installable as the extra package **kde-config-tablet** on KDE.

There are likely some edge cases that don't have drivers in the kernel but offer kmod versions of driver modules as an RPM or DEB file that you can download and install through your package manager.

#### Patching and compiling your own kernel

Even in the futuristic utopia that is the 21st century, there are vendors that don't understand open source enough to provide installable drivers. Sometimes, such companies provide source code for a driver but expect you to download the code, patch a kernel, compile, and install manually.

This kind of distribution model has the same disadvantages as installing packaged drivers outside of the kmod system: an update to your kernel breaks the driver because it must be re-integrated into your kernel manually each time the kernel is swapped out for a new one.

This has become rare, happily, because the Linux kernel team has done an excellent job of pleading loudly for companies to communicate with them, and because companies are finally accepting that open source isn't going away any time soon. But there are still novelty or hyper-specialized devices out there that provide only kernel patches.

Officially, there are distribution-specific preferences for how you should compile a kernel to keep your package manager involved in upgrading such a vital part of your system. There are too many package managers to cover each; as an example, here is what happens behind the scenes when you use tools like **rpmdev** on Fedora or **build-essential** and **devscripts** on Debian.

First, as usual, find out which kernel version you're running:

```bash
$ uname -r
```

In most cases, it's safe to upgrade your kernel if you haven't already. After all, it's possible that your problem will be solved in the latest release. If you tried that and it didn't work, then you should download the source code of the kernel you are running. Most distributions provide a special command for that, but to do it manually, you can find the source code on [kernel.org](https://www.kernel.org/).

You also must download whatever patch you need for your kernel. Sometimes, these patches are specific to the kernel release, so choose carefully.

It's traditional, or at least it was back when people regularly compiled their own kernels, to place the source code and patches in **/usr/src/linux**.

Unarchive the kernel source and the patch files as needed:

```bash
$ cd /usr/src/linux
$ bzip2 --decompress linux-5.2.4.tar.bz2
$ cd  linux-5.2.4
$ bzip2 -d ../patch*bz2
```

The patch file may have instructions on how to do the patch, but often they're designed to be executed from the top level of your tree:

```bash
$ patch -p1 < patch*example.patch
```

Once the kernel code is patched, you can use your old configuration to prepare the patched kernel config:

```bash
$ make oldconfig
```

The **make oldconfig** command serves two purposes: it inherits your current kernel's configuration, and it allows you to configure new options introduced by the patch.

You may need to run the **make menuconfig** command, which launches an ncurses-based, menu-driven list of possible options for your new kernel. The menu can be overwhelming, but since it starts with your old config as a foundation, you can look through the menu and disable modules for hardware that you know you do not have and do not anticipate needing. Alternately, if you know that you have some piece of hardware and see it is not included in your current configuration, you may choose to build it, either as a module or directly into the kernel. In theory, this isn't necessary because presumably, your current kernel was treating you well but for the missing patch, and probably the patch you applied has activated all the necessary options required by whatever device prompted you to patch your kernel in the first place.

Next, compile the kernel and its modules:

```bash
$ make bzImage
$ make modules
```

This leaves you with a file named **vmlinuz**, which is a compressed version of your bootable kernel. Save your old version and place the new one in your **/boot** directory:

```bash
$ sudo mv /boot/vmlinuz /boot/vmlinuz.nopatch
$ sudo cat arch/x86_64/boot/bzImage > /boot/vmlinuz
$ sudo mv /boot/System.map /boot/System.map.stock
$ sudo cp System.map /boot/System.map
```

So far, you've patched and built a kernel and its modules, you've installed the kernel, but you haven't installed any modules. That's the final build step:

```bash
$ sudo make modules_install
```

The new kernel is in place, and its modules are installed.

The final step is to update your bootloader so that the part of your computer that loads before the kernel knows where to find Linux. The GRUB bootloader makes this process relatively simple:

```bash
$ sudo grub2-mkconfig
```

#### Real-world compiling

Of course, nobody runs those manual commands now. Instead, refer to your distribution for instructions on modifying a kernel using the developer toolset that your distribution's maintainers use. This toolset will probably create a new installable package with all the patches incorporated, alert the package manager of the upgrade, and update your bootloader for you.

#### Kernels

Operating systems and kernels are mysterious things, but it doesn't take much to understand what components they're built upon. The next time you get a piece of tech that appears to not work on Linux, take a deep breath, investigate driver availability, and go with the path of least resistance. Linux is easier than ever—and that includes the kernel.

### 上文翻译

​	在计算机领域，**内核是处理与硬件通信和一般系统协调的底层软件。**除了计算机主板上内置的一些初始固件外，当你启动计算机时，内核向上提供一种抽象，让应用层软件知道计算机有硬盘、屏幕、键盘和网卡。内核的工作还包括确保每个组件都有相同的运行时间（或多或少），以便图形、音频、文件系统和网络都能顺利运行，它们可以是同时运行的。

​	不过，对硬件支持的追求是持续性的，因为发布的硬件越多，内核就必须在代码中采用越多的东西，才能使硬件按预期运行。虽然很难获得准确的数字，但 Linux 内核在硬件兼容性方面肯定是名列前茅的。Linux 操作着无数的电脑和手机、业余爱好者和工业用途的嵌入式系统芯片（SoC）板、RAID 卡等等。

在 20 世纪（甚至 21 世纪初），Linux 用户在购买新硬件时，需要下载最新的内核源代码、编译并安装，以便获得设备支持。但最近，你很难找到一个自己编译内核的 Linux 用户，除非是为了好玩或通过高度专业化的定制硬件获利。现在，一般不需要自己编译 Linux 内核了。

以下是编译内核的原因，以及如何在需要时编译内核的快速教程。

#### 更新内核的现代方法

​	无论你是买了一台全新的笔记本电脑，配备了炫目的新显卡或 WiFi 芯片组，还是刚把一台新打印机带回家，你的操作系统（称为 GNU+Linux 或简称 Linux，也是内核的名称）都需要一个驱动程序来打开与新组件（显卡、WiFi 芯片、打印机或其他）的通信通道。有时，当你插入一个新设备时，你的电脑*似乎*承认了它，这可能具有欺骗性。但千万别被骗了。有时这就是你所需要的，但有时你的操作系统只是使用通用协议来探测已连接的设备。

​	例如，你的电脑可能能够识别你的新网络打印机，但有时这只是因为打印机中的网卡被编程为识别自己的网络，以便获得 DHCP 地址。这并不一定意味着你的电脑知道向打印机发送什么指令才能打印出一页文本。事实上，你可能会说，计算机甚至并不真正 "知道 "该设备是一台打印机；它可能只是显示网络上有一台设备在一个特定的地址上，而该设备用一系列字符*p-r-i-n-t-e-r*来标识自己。人类的语言习惯对计算机来说毫无意义，它需要的是一个驱动程序。

​	内核开发人员、硬件制造商、技术支持人员和业余爱好者都知道，新硬件在不断推出。他们中的许多人都会直接向内核开发团队提交驱动程序，以便将其纳入 Linux。例如，Nvidia 显卡驱动程序通常被写入[Nouveau](https://nouveau.freedesktop.org/wiki/)内核模块，而且，由于 Nvidia 显卡很常见，这些代码通常会被包含在任何发布的通用内核中（如下载[Fedora](http://fedoraproject.org/) 或[Ubuntu](http://ubuntu.com/)时获得的内核）。在 Nvidia 不常用的地方，例如嵌入式系统中，Nouveau 模块通常被排除在外。许多其他设备也有类似的模块：打印机有 [Foomatic](https://wiki.linuxfoundation.org/openprinting/database/foomatic) 和 [CUPS](https://www.cups.org/) 模块，无线网卡有 [b43, ath9k, wl](https://wireless.wiki.kernel.org/en/users/drivers) 模块，等等。

​	发行版倾向于在其 Linux 内核构建中尽可能多地包含这些模块，因为它们希望你能够连接设备并立即开始使用，而无需安装驱动程序。这在大多数情况下都会发生，尤其是现在许多设备供应商都在为他们销售的硬件提供 Linux 驱动程序开发资金，并将这些驱动程序直接提交给内核团队进行发布。

​	但有时，你运行的是六个月前安装的内核，而一周前刚上市的新设备令人兴奋。在这种情况下，你的内核可能没有该设备的驱动程序。好在很多时候，最近版本的内核中可能就有该设备的驱动程序，这意味着你只需更新正在运行的内核即可。

​	一般来说，这可以通过软件包管理器完成。例如，在 RHEL、CentOS 和 Fedora 上：

```
sudo dnf update kernel
```

​	对于Debian和 Ubuntu 上，首先需要查看的是系统内核的版本：

```
$ uname -r
6.5.0-41-generic
```

​	下一步就是查找更新的源：

```
$ sudo apt update
$ sudo apt search linux-image
```

​	我们看看结果如何

```
linux-image-5.15.0-76-lowlatency/jammy-updates,jammy-security 5.15.0-76.83 amd64
linux-image-6.8.0-1008-azure/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-6.8.0-1008-azure-fde/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-6.8.0-1008-nvidia/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-azure-edge/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-azure-fde-edge/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-nvidia-6.8/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-nvidia-hwe-22.04-wip/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-uc-6.8.0-1008-nvidia/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
linux-image-unsigned-5.15.0-76-lowlatency/jammy-updates,jammy-security 5.15.0-76.83 amd64
linux-image-unsigned-6.8.0-1008-azure/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
  Linux kernel image for version 6.8.0 on 64 bit x86 SMP
linux-image-unsigned-6.8.0-1008-nvidia/jammy-updates,jammy-security 6.8.0-1008.8~22.04.1 amd64
  Linux kernel image for version 6.8.0 on 64 bit x86 SMP
```

​	我们可以找最新的6.8的内核

```
sudo apt install linux-image-6.8.0
```

​	下载完成，下一步就是简单的重启就行。

#### 安装内核模块

​	有时，发行版并不希望用户经常使用某个设备（或者至少不希望设备驱动程序出现在 Linux 内核中）。Linux 采用模块化方式处理驱动程序，因此发行版可以提供单独的驱动程序包，即使驱动程序没有编译到内核中，内核也可以加载这些驱动程序包。这很有用，不过当内核中不包含驱动程序，但在启动过程中需要使用，或者内核从模块化驱动程序下更新时，情况就会变得复杂。第一个问题由 initrd（初始 RAM 磁盘）解决，不在本文讨论范围之内，第二个问题由名为 kmod 的系统解决。

​	下面，我们一个 Nvidia 驱动程序作为例子：

​	kmod 系统能确保内核更新时，同时安装的所有模块化驱动程序也得到更新。如果你手动安装驱动程序，就会错过 kmod 提供的自动化功能，因此只要有 kmod 软件包，你就应该选择安装。例如，虽然 Nvidia 驱动程序作为 Nouveau 驱动程序内置于内核中，但 Nvidia 官方驱动程序仅由 Nvidia 发布。你可以通过访问网站、下载 .run 文件并运行其提供的 shell 脚本来手动安装 Nvidia 品牌的驱动程序，但在安装新内核后，你必须重复同样的过程，因为没有任何信息会告诉你的软件包管理器你手动安装了内核驱动程序。由于显卡由 Nvidia 驱动，手动更新 Nvidia 驱动程序通常意味着你必须在终端上执行更新，因为没有正常运行的显卡驱动程序就没有显卡。

![Nvidia configuration application](https://opensource.com/sites/default/files/uploads/nvidia.jpg)

​	当然，我们如果下载的是Nvidia的模块驱动，我们可以直接以挂载module的方式，在更新系统的时候把驱动更新了。

​	Fedora系列的：

```
$ sudo dnf install kmod-nvidia
```

​	在Debian系列的

```
sudo apt update
$ sudo apt install nvidia-kernel-common nvidia-kernel-dkms nvidia-glx nvidia-xconfig nvidia-settings nvidia-vdpau-driver vdpau-va-driver
```

​	当然这仅仅只是一个例子，但是如果你正在下载英伟达显卡驱动，你必须将Nouveau的驱动拉入黑名单。更加具体的需要查看你的发行版的文档，以获取最佳的安装步骤。

#### 下载，并且安装一个驱动

​	并非所有东西都包含在内核中，也并非所有其他东西都可以作为内核模块使用。在某些情况下，你必须下载由硬件供应商编写和捆绑的特殊驱动程序，而在其他情况下，你有驱动程序却没有配置驱动程序选项的前端。

​	惠普打印机和 Wacom 绘图板就是两个常见的例子。如果你买的是惠普打印机，那么你可能拥有可以与打印机通信的通用驱动程序。你甚至可以打印。但通用驱动程序可能无法提供针对你的型号的专门选项，如双面打印、拼版、纸盘选择等。HPLIP（HP Linux 成像和打印系统）提供了管理作业、调整打印选项、选择适用纸盘等选项。

​	HPLIP 通常捆绑在软件包管理器中；只需搜索 "hplip "即可。

​	![HPLIP in action](https://opensource.com/sites/default/files/uploads/hplip.jpg)

​	同样，Wacom 平板电脑（数字艺术家的主要插画平板电脑）的驱动程序通常包含在内核中，但微调设置的选项（如压力灵敏度和按钮功能）只能通过 GNOME 默认包含的图形控制面板访问，但在 KDE 中可作为额外软件包 kde-config-tablet 安装。

​	可能还有一些相对罕见的情况——内核中没有驱动程序，但以 RPM 或 DEB 文件的形式提供 kmod 版本的驱动模块，你可以通过软件包管理器下载并安装。

#### 编译`(Compiling)`或给kernel打补丁`(Patching)`

​	即使在未来乌托邦的 21 世纪，也有一些厂商对开放源代码的理解不够深刻，无法提供可安装的驱动程序。有时，这些公司会提供驱动程序的源代码，但希望你下载代码、修补内核、编译并手动安装。

​	这种发布模式与在 kmod 系统外安装打包驱动程序有同样的缺点：内核更新会破坏驱动程序，因为每次更换新内核时，都必须手动将其重新集成到内核中。

​	令人欣慰的是，这种情况已经很少见了，因为 Linux 内核团队已经做得很好，他们大声恳求公司与他们沟通，而且公司也终于接受了开源不会很快消失的事实。但仍有一些新奇或超专业的设备只提供内核补丁。

​	官方对如何编译内核有特定的发行版偏好，以便让软件包管理器参与升级系统中如此重要的部分。软件包管理器种类繁多，无法一一列举；举例来说，以下是 Fedora 上的 rpmdev 或 Debian 上的 build-essential 和 devscripts 等工具的幕后工作。

​	一般的步骤如下：

```
uname -r
```

​	在大多数情况下，如果您还没有升级内核，那么升级内核是安全的。毕竟，你的问题有可能在最新版本中得到解决。如果你尝试了，但没有成功，那么你应该下载你正在运行的内核的源代码。大多数发行版都为此提供了专门的命令，但要手动下载，你可以在 kernel.org 上找到源代码。

​	您还必须下载内核所需的补丁。有时，这些补丁与内核版本有关，因此要谨慎选择。

​	将源代码和补丁文件放在 /usr/src/linux 中是一种传统做法，至少在人们经常编译自己的内核时是这样。

​	根据需要解压缩内核源代码和补丁文件：

```
$ cd /usr/src/linux
$ bzip2 --decompress linux-5.2.4.tar.bz2
$ cd  linux-5.2.4
$ bzip2 -d ../patch*bz2
```

​	这里的补丁文件可能会有若干指引步骤来指导你如何来给内核。打补丁，但是通常的他们会被设计。在你的代码层次数上的顶层开始执行。

```
$ patch -p1 < patch*example.patch
```

​	一旦你的内核代码被打上了补丁，你可以尝试用你电脑的旧的配置文件来准备对内核配置进行补丁。

```
$ make oldconfig
```

​	**make oldconfig**指令完成两个重要的目的，它继承了你当前内核的配置，以及它允许你去配置新的选项，这些新的选项则是通过补丁而被引入的。

​	你也有可能需要运行**make menuconfig** ，他们是受这样的一些包进行支持的 ：ncurses-based, menu-driven等。菜单可能会让人应接不暇，但由于它是以你的旧配置为基础启动的，你可以查看菜单，禁用那些你知道自己没有、预计也不需要的硬件模块。另外，如果你知道自己拥有某些硬件，但发现当前配置中不包含这些硬件，你可以选择将其作为模块或直接内置到内核中。从理论上讲，这并不是必须的，因为如果没有丢失的补丁，你当前的内核应该是不错的，而且你应用的补丁可能已经激活了所有必要的选项，不管是什么设备促使你首先为内核打上补丁。

​	接下来，编译内核及其模块：

```
$ make bzImage
$ make modules
```

​	采取如此的行动将会给你生成一个这样的文件，它是可以被启动内核的文件的压缩版本。我们保留旧的内核压缩版本，然后把新的内核压缩文件放到`/boot`目录下

```
$ sudo mv /boot/vmlinuz /boot/vmlinuz.nopatch
$ sudo cat arch/x86_64/boot/bzImage > /boot/vmlinuz
$ sudo mv /boot/System.map /boot/System.map.stock
$ sudo cp System.map /boot/System.map
```

​	目前为止你已经给内核打上补丁，并且将之完成构建以及相关的模块，你已经成功的安装了内核，但是你并没有安装模块，所以我们需要做最后的步骤。

```
$ sudo make modules_install
```

​	在新的内核已经就位以及它的模块也被安装完成，最后一步就是更新我们的bootloader，这样的话我们的电脑将会加载这些新的内核。这一步就是告知GRUB启动器内核的位置。

```
$ sudo grub2-mkconfig
```

#### 实际编译

​	当然，现在没人会执行这些手动命令。取而代之的是，你可以参考发行版的说明，使用发行版维护者使用的开发者工具集修改内核。该工具集可能会创建一个包含所有补丁的新安装包，提醒软件包管理器进行升级，并为你更新引导加载器。

#### 内核

​	操作系统和内核是很神秘的东西，但要了解它们是基于什么组件构建的并不难。下一次，当你得到一项似乎无法在 Linux 上运行的技术时，深吸一口气，调查驱动程序的可用性，然后选择阻力最小的途径。Linux 比以往任何时候都要简单，包括内核。

### Questions

> I need to add the boot parameter `foo=bar` to my kernel. How can I do this once for testing, and permanently if testing was a success?

#### To temporarily add a boot parameter to a kernel

1. Start your system and wait for the GRUB menu to show (if you don't see a GRUB menu, press and hold the left Shift key right after starting the system).
2. Now highlight the kernel you want to use, and press the e key. You should be able to see and edit the commands associated with the highlighted kernel.
3. Go down to the line starting with `linux` and add your parameter `foo=bar` to its end.
4. Now press Ctrl + x to boot.

#### To make this change permanent

1. From a terminal (or after pressing Alt + F2) run:

   ```
    gksudo gedit /etc/default/grub
   ```

   (or use `sudo nano` if `gksudo` or `gedit` are not available) and enter your password.

2. Find the line starting with `GRUB_CMDLINE_LINUX_DEFAULT` and append `foo=bar` to its end. For example:

   ```
    GRUB_CMDLINE_LINUX_DEFAULT="quiet splash foo=bar"
   ```

   Save the file and close the editor.

3. Finally, start a terminal and run:

   ```
    sudo update-grub
   ```

   to update GRUB's configuration file (you probably need to enter your password).

On the next reboot, the kernel should be started with the boot parameter. To permanently remove it, simply remove the parameter from `GRUB_CMDLINE_LINUX_DEFAULT` and run `sudo update-grub` again.

To verify your changes, you can see exactly what parameters your kernel booted with by executing `cat /proc/cmdline`.

