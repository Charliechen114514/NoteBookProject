# ARM架构薄记小记1——ARM架构的快速介绍

​	笔者最近正在简单的了解一下ARM架构，特别是ARM CortexA架构的部分，这里，笔者想要薄记的问题有这样一些，也算是简单记录一下自己学习ARM架构的记录。

> 问题1：ARM架构的历史是如何的，以此我们可以洞察ARM架构设计的一些动机
>
> 问题2：我们知道，ARM架构中常见的架构是ARMv7到ARMv9，这些架构有发生怎样的变化？每一个架构的一些纲领性的东西是什么？
>
> 问题3：我们都知道，架构架构，几个最最核心的组成部分就是指令和寄存器的部分（当然还有其他的部分，但是笔者正在进一步学习，这里先不谈论）

​	下面的博客是笔者自己的整理

## 前提

​	这里需要做一个区分：ARM处理器和ARMvN（截止到2025年3月22日，ARM架构有9代，从ARMv1到ARMv9）。

​	ARM 处理器型号（如 ARM7、ARM9、ARM11 等）和 ARM 架构版本（如 ARMv4、ARMv5、ARMv6 等）之间的关系可以理解为 **具体实现与抽象规范** 的关系。

​	首先，以ARMv打头的是——ARM 架构版本，这是ARM 公司定义的一套指令集架构（ISA，Instruction Set Architecture）规范。它规定了处理器的指令集、寄存器、内存模型、异常处理等核心设计。换而言之，这是蓝图：

   - 是抽象的规范，不涉及具体的硬件实现。
- 每个架构版本会引入新的特性或改进（如新增指令、支持更高的地址空间、改进性能等）。

​	只以ARM大头的，是ARM 处理器型号（ARMX），ARM 处理器型号（如 ARM7、ARM9、ARM11 等）是基于 ARM 架构版本的具体硬件实现。它们是 ARM 公司或授权厂商设计的实际处理器核心。这个就是基于蓝图设计出来的具体的处理器了：同一架构版本可以有多个处理器型号（例如，ARM7 和 ARM9 都基于 ARMv4，但性能和应用场景不同）。

再强调：

   - **ARM 处理器型号** 是基于 **ARM 架构版本** 的具体实现。
   - 一个 **ARM 架构版本** 可以有多个 **ARM 处理器型号**。
   - 一个 **ARM 处理器型号** 只能基于一个 **ARM 架构版本**。

​	这样，我们就可以列举一个表格了

| ARM 处理器型号 | 基于的 ARM 架构版本 |
| -------------- | ------------------- |
| ARM1           | ARMv1               |
| ARM2 和 ARM3   | ARMv2               |
| ARM6           | ARMv3               |
| ARM7           | ARMv4               |
| ARM9           | ARMv5               |
| ARM11          | ARMv6               |
| Cortex-A7      | ARMv7               |
| Cortex-A53     | ARMv8               |

注意的是，ARM4和ARM5是内部测试的版本，没有在市场上进行大规模的流通，他们属于ARMv3架构，但是这里就不枚举了

## ARM架构的历史

### 从Acorn到ARM

​	ARM架构的起源可以追溯到英国剑桥的一家小型计算机公司——Acorn Computers。1978年12月5日，Chris Curry和Hermann Hauser共同创立了Acorn Computers的前身Cambridge Processor Unit Ltd.（CPU Ltd.），旨在开发微型计算机。 在成立初期，Acorn专注于开发基于MOS Technology 6502处理器的计算机系统。他们推出了Acorn System系列计算机，主要面向工程和实验室用户。其中，Acorn System 1是一款小巧的微型计算机，由两块电路板组成，一块包含LED显示器、键盘和磁带接口，另一块包含CPU等其他计算机部件。

​	1981年，英国广播公司（BBC）计划推出一档关于计算机的教育节目，并希望推出一款与之配套的计算机。Acorn抓住这一机会，迅速开发出BBC Micro计算机。这款计算机在英国教育市场取得了巨大成功，销量超过120万台，奠定了Acorn在计算机行业的地位。然而，随着计算机技术的快速发展，Acorn意识到需要开发性能更强的处理器来满足未来需求。当时，市场上的16位处理器要么性能不足，要么价格高昂。因此，Acorn决定自主研发一种新的处理器架构。他们的研发团队从加州大学伯克利分校获得了关于精简指令集计算机（RISC）的研究成果，认为这种架构可以满足他们的设计要求。 

​	在此基础上，Acorn的计算机科学家Sophie Wilson和Steve Furber开始设计自己的RISC处理器。经过多年的努力，他们于1985年4月26日完成了第一代32位处理器ARM1的设计和制造。ARM1处理器仅包含约25,000个晶体管，设计简洁高效，虽然没有乘法器，但在性能和功耗方面表现出色。1987年，Acorn推出了基于ARM2处理器的个人计算机——Acorn Archimedes。这款计算机被认为是首款基于RISC架构的生产级个人电脑，展示了ARM架构在实际应用中的潜力。 

​	随着ARM架构的成功，Acorn于1990年与苹果和VLSI Technology合作，成立了Advanced RISC Machines（ARM）公司，专注于ARM架构的开发和推广。这标志着ARM从Acorn的内部项目发展为独立的商业实体，开启了ARM架构在全球范围内的广泛应用之路。 

### 早期架构：从ARM2到ARM7（从ARMv1到ARMv4）

​	伴随ARM逐步占领移动端市场，ARM架构的演化也逐步进入了一个非常迅猛的时器：特别的：ARM2至ARM6处理器的演进，标志着ARM从初创阶段逐步迈向成熟的关键时期。

​	ARM2处理器是ARM公司推出的首款商业化处理器，采用了精简指令集计算（RISC）架构，**具有32位数据总线和26位地址总线，能够支持16MB的内存寻址。**其指令集设计简洁高效，包含了约44条指令，所有指令均为固定的32位长度，这种设计简化了指令解码过程，提高了处理器的执行效率。此外，ARM2采用了**三级流水线设计**，包括取指、译码和执行阶段，使得处理器能够在每个时钟周期内完成一条指令的执行。这种高效的流水线设计，使得ARM2在性能上表现出色，同时功耗也保持在较低水平。这种高性能、低功耗的特性，使得ARM2在当时的市场上脱颖而出，广泛应用于Acorn公司的Archimedes系列计算机中，奠定了ARM在嵌入式系统领域的基础。

​	在ARM2取得成功后，ARM公司继续研发，推出了ARM3处理器。ARM3在ARM2的基础上进行了多项改进，最显著的提升是引入了4KB的片上缓存（Cache），用于存储指令和数据。缓存的引入，大幅减少了处理器对外部内存的访问次数，提高了指令执行速度，降低了内存访问延迟。此外，ARM3还对流水线进行了优化，使其能够更有效地处理指令，提高了整体性能。这些改进，使得ARM3在性能和功耗之间取得了更好的平衡，进一步巩固了ARM在嵌入式系统市场的地位。

​	随着技术的不断进步和市场需求的变化，ARM公司于**1990年代初推出了ARM6处理器。ARM6是ARM架构的一个重要里程碑，因为它引入了支持虚拟内存管理的内存管理单元（MMU）**，使得ARM处理器能够运行复杂的操作系统，如Unix和早期的Linux版本。MMU的引入，使得处理器能够进行内存地址转换和保护，提高了系统的稳定性和安全性。此外，ARM6采用了改进的流水线设计，进一步提高了指令执行的效率。这些特性，使得ARM6不仅在嵌入式系统中得到应用，还开始进入更广泛的计算领域，标志着**ARM从专用处理器向通用处理器的转变**。在ARM6的基础上，ARM公司继续研发，推出了ARM7处理器。ARM7在架构上进行了多项改进，包括更高效的流水线设计和更大的缓存容量，使得处理器的性能和功耗表现更加出色。此外，**ARM7还引入了Thumb指令集，这是一种16位长度的指令集，与传统的32位ARM指令集相比，Thumb指令集能够有效减少代码的存储空间，提高指令的执行效率。**这种创新，使得ARM7在资源受限的嵌入式系统中表现出色，广泛应用于移动设备、消费电子和工业控制等领域。

​	这里谈到的，是ARMv1到ARMv4架构，虽然现在我们使用的更多是ARMv7 - ARMv9架构，

#### ARMv1

​	ARMv1架构是ARM（Advanced RISC Machine）家族的首个版本，标志着ARM处理器从概念走向现实的关键一步。作为ARM架构的起点，ARMv1为后续版本的发展奠定了基础。尽管ARMv1架构只在原型机ARM1上实现，未被广泛应用于商业产品，但其设计理念和技术特点对后来的ARM架构产生了深远影响。

​	我们说，起点起点，起在什么地方呢？当然是设计了最基本的要素：

1. **指令集设计**：ARMv1采用了精简的指令集设计，指令长度固定为32位，指令种类少且执行速度快。这种设计简化了处理器的解码过程，提高了执行效率。
2. **寄存器组**：ARMv1架构包含16个32位通用寄存器（R0-R15），其中R15用作程序计数器（PC）。丰富的寄存器设计减少了对内存的访问次数，提升了处理器性能。
3. **寻址空间**：ARMv1提供了26位的寻址空间，支持64MB的内存寻址范围。这在当时的嵌入式系统中已足够满足需求。
4. **数据处理能力**：ARMv1支持基本的数据处理指令，但不包含乘法指令。这一限制在后续版本中得到了改进。
5. **负载/存储架构**：采用负载/存储架构，数据处理指令只能在寄存器之间操作，内存访问通过专门的加载和存储指令完成。这种设计简化了指令集，提高了执行效率。

​	我上面的表格中，可以看到：ARMv1架构的唯一实现是ARM1原型处理器。ARM1主要用于验证RISC理念在实际处理器设计中的可行性，并为后续版本的开发提供了宝贵的经验。虽然ARM1未被广泛应用于商业产品，但其成功验证了RISC架构的优势，为ARM处理器的未来发展铺平了道路。

​	别看ARMv1简单（虽然我觉的一点不简单QAQ），但是它证明了精简指令集在提高处理器性能和效率方面的可行性，为RISC架构的推广提供了有力支持，也是后续派生版本的根本，其核心理念和设计思路在后续版本中得以延续和发扬。作为开始打算在嵌入式根深的发展，ARMv1的设计理念强调低功耗和高效率，这些特点非常适合嵌入式系统的需求，为ARM处理器在嵌入式领域的广泛应用奠定了基础。

#### ARMv2

​	ARMv2架构是ARM公司在1986年推出的第二代精简指令集计算机（RISC）架构。作为ARM架构的早期版本，ARMv2在前一代的基础上进行了多项改进和增强，为后续ARM架构的发展奠定了坚实的基础。在1986年推出了ARMv2架构。基于ARMv2架构的首款商用处理器是ARM2，这标志着ARM架构正式进入商用领域。

​	我们上面提到，ARMv1开山之作，ARMv2架构延续了RISC的设计理念，强调指令集的精简和高效执行。与ARMv1相比，ARMv2在以下几个方面进行了改进：

1. **指令集扩展**：ARMv2增加了对32位乘法指令的支持，使处理器能够更高效地执行乘法运算。这一改进对于需要大量数值计算的应用场景，如图形处理和信号处理，提供了性能提升。
2. **协处理器支持**：ARMv2引入了协处理器指令，允许与外部协处理器进行交互。这使得处理器可以扩展功能，例如浮点运算或其他专用计算任务，提高了系统的灵活性和性能。
3. **寻址空间**：尽管ARMv2仍采用26位寻址空间，但通过优化设计，提高了内存访问的效率，为后续架构的寻址空间扩展奠定了基础。

​	ARMv2架构的技术细节体现了RISC设计的核心思想，即通过精简指令集和统一的指令长度，简化处理器的设计和实现，提高指令的执行效率。以下是ARMv2的一些关键技术特性：

- **指令长度**：所有指令均为32位长度，确保了指令解码的简洁性和执行的一致性。
- **寄存器组**：提供了16个通用寄存器（R0-R15），其中R15作为程序计数器（PC）。这种设计提供了充足的寄存器供程序使用，减少了对内存的访问，提高了执行效率。
- **条件执行**：大多数指令都可以根据条件执行，这减少了分支指令的数量，有助于提高指令流水线的效率。
- **协处理器接口**：通过引入协处理器接口，ARMv2处理器可以与外部协处理器协同工作，扩展了处理器的功能。例如，可以通过协处理器实现浮点运算，加速特定计算任务。

#### ARMv3

​	ARMv3架构是ARM公司在时隔四年后的1990年推出的第三代架构，标志着ARM处理器在功能和性能上的重要飞跃。与之前的ARMv1和ARMv2架构相比，ARMv3引入了多项关键改进，使其在计算能力和应用范围上有了显著提升。ARMv3架构开始允许将寻址空间从26位扩展至32位，即支持4GB的寻址空间。这一改进解决了之前架构在内存寻址上的限制，为处理更大规模的数据和应用提供了可能。

​	ARMv3架构引入了片上高速缓存（Cache）和内存管理单元（MMU）。高速缓存的加入提高了处理器的数据访问速度，减少了对主存的依赖，从而提升了整体性能。MMU的引入使处理器具备了虚拟内存管理能力，增强了系统的稳定性和安全性。我们的ARMv3还增加了写缓冲（Write Buffer）功能。写缓冲的存在使得处理器在写操作时可以更高效地处理数据，减少了等待时间，提高了数据写入的效率。九二一说是进一步改进了我们的ARM架构，让他慢慢从一个专用于纯粹嵌入式的架构转向了通用架构

#### ARMv4

​	1993年，ARMv4诞生了。

​	ARMv4架构引入了Thumb指令集，这是一种16位的指令集，与传统的32位ARM指令集相比，Thumb指令集具有更高的代码密度。这意味着在相同的存储空间内，Thumb指令集可以存放更多的指令，从而提高了存储效率，降低了内存需求。对于资源受限的嵌入式系统而言，这一特性尤为重要。此外，Thumb指令集在执行时会被解码回32位的ARM指令，这确保了指令的执行效率，同时兼顾了代码密度和性能。上面这段话就是：

- **代码密度**：Thumb 指令集的指令长度仅为 16 位，比标准的 32 位 ARM 指令更紧凑，从而减少了代码占用的存储空间。
- **功耗优化**：由于指令长度更短，Thumb 指令集可以减少内存访问次数，从而降低功耗。
- **性能平衡**：虽然 Thumb 指令集的性能略低于标准的 ARM 指令集，但在许多嵌入式应用中，代码密度和功耗的优化更为重要。

​	到ARMv4, ARM终于完全支持 32 位地址空间，取代了早期 ARMv3 架构的 26 位地址空间。这个里程碑式的进步无需多言，任何一个学过操作系统和计算机架构的朋友都知道，这意味着我们的寻址能力达到了标准的32位，可以跟其他处理器平起平坐了。

​	ARMv4架构在指令集方面进行了优化，**增加了对乘法指令的支持**。在之前的架构中，乘法运算需要通过多条指令来实现，这不仅增加了代码的复杂性，还降低了执行效率。而在ARMv4中，新增的乘法指令使得处理器可以直接执行乘法运算，大大提高了运算速度，特别是在需要大量数值计算的应用中，这一改进显得尤为重要。

​	ARMv4架构还增强了异常处理机制，引入了更为灵活的中断处理方式。这使得处理器在面对外部事件或异常情况时，能够更快速地响应，提高了系统的实时性和可靠性。对于需要高可靠性的嵌入式系统，如工业控制、医疗设备等领域，这一改进提供了更强的保障。

​	在存储系统方面，ARMv4架构支持更大的地址空间，能够寻址更大的内存容量。这使得处理器可以支持更复杂的应用和更大的数据集，拓展了ARM处理器的应用范围。同时，ARMv4还改进了缓存机制，优化了存储访问效率，进一步提升了系统性能。最重要的是——有MMU了，使得操作系统可以实现虚拟内存管理和内存保护。换而言之，在这个处理器上可以跑Linux了（虽然这个时候Linux诞生没多久）

### 快速发展:从ARM9到ARM11

​	下一步，我们开始聊下ARMv5到ARMv6的阶段了，对应的处理器就是从ARM9到ARM11

#### ARMv5

​	1997年，我们有了ARMv5。ARMv5架构引入了Thumb指令集的增强版本。Thumb指令集最早在ARMv4T架构中引入，旨在通过使用16位定长指令来提高代码密度，从而减少内存占用，降低功耗。在ARMv5中，Thumb指令集得到了进一步优化，增强了处理器的执行效率，同时保持了高代码密度的优势。

​	ARMv5架构在处理器的流水线设计上进行了改进。通过优化流水线结构，ARMv5处理器实现了更高的指令吞吐量，减少了指令执行的延迟。这种改进使得处理器在执行复杂计算任务时表现更加出色，满足了当时嵌入式应用对性能的更高要求。

​	ARMv5的一个重大的突破就是引入信号处理的支持，架构中有了对DSP（数字信号处理）指令的支持，使得处理器能够高效地执行数字信号处理任务，如音频和视频处理，这对于多媒体应用的发展具有重要意义。通过集成DSP功能，ARMv5处理器在不增加额外硬件的情况下，提供了更强大的处理能力，降低了系统的整体成本。

​	在存储系统方面，ARMv5架构改进了缓存和存储管理功能。通过引入更高级的缓存控制机制，ARMv5处理器能够更有效地利用缓存，提高数据访问速度，减少内存瓶颈。这对于需要频繁数据访问的应用，如实时操作系统和多媒体应用，提供了性能保障。安全性方面，ARMv5架构开始关注处理器的安全特性。虽然在这一阶段，安全功能尚未成为主要焦点，但ARMv5为后续架构引入更高级的安全特性奠定了基础。这些早期的尝试为ARM处理器在安全敏感领域的应用铺平了道路。

​	也就是说，ARM架构在这个时期走向了严谨，准备冲击更加高端的媒体市场（大家都知道DSP在音视频媒体处理的地位）

#### ARMv6

​	2002年，ARMv6诞生，它的一个核心特性是对 **Thumb-2 指令集** 的支持。Thumb-2 是 Thumb 指令集的扩展，结合了 16 位和 32 位指令的优点。与传统的 Thumb 指令集相比，Thumb-2 提供了更高的代码密度和更好的性能。它允许开发者在同一代码中混合使用 16 位和 32 位指令，从而在保持低功耗的同时实现更高的执行效率。这一特性使得 ARMv6 架构在资源受限的嵌入式系统中更具竞争力，同时也为复杂的应用程序提供了更好的支持。

​	另一个重要的改进是 **SIMD（单指令多数据）指令集** 的引入。SIMD 技术允许处理器在单个指令周期内对多个数据执行相同的操作，从而显著加速多媒体和数据密集型任务的处理。ARMv6 架构中的 SIMD 指令集被称为 **ARM SIMD**，它为图像处理、音频解码和视频编码等应用提供了强大的硬件支持。SIMD的出现，显然意味着ARM处理器可以内置的处理音视频流。ARM处理器正式具备了可以在音视频领域竞争的资格。

​	ARMv6 架构还引入了 **多核支持** 的能力。随着多核处理器的普及，ARMv6 架构通过改进缓存一致性和总线协议，为多核系统的设计提供了更好的支持。这一特性使得 ARMv6 架构能够有效地处理多任务并行执行的需求，从而提高了系统的整体性能和响应速度。多核支持不仅适用于高性能计算设备，还为嵌入式系统提供了更高的灵活性和可扩展性。

​	MMU是ARMv4引入的，在这里，ARMv6 架构对 **内存管理单元（MMU）** 进行了优化。新的 MMU 支持更大的地址空间和更高效的分页机制，从而提高了虚拟内存管理的效率。此外，ARMv6 架构还引入了 **TrustZone 技术**，这是一种硬件级别的安全解决方案。TrustZone 将处理器的运行环境分为安全世界和非安全世界，从而为敏感数据和应用提供了更高的保护。这一特性使得 ARMv6 架构在金融、医疗和政府等安全敏感领域得到了广泛应用。

​	此外，异常处理被接着改进：新的异常处理机制支持更快的上下文切换和更灵活的中断处理，从而提高了系统的实时性和可靠性。此外，ARMv6 架构还引入了 **低功耗状态** 和 **动态电压频率调节（DVFS）** 技术，这些技术使得处理器能够根据负载动态调整功耗和性能，从而延长了移动设备的电池寿命。

### 走向移动时代——我们的重头戏ARMv7到今天的ARMv9

​	终于到大伙熟悉的架构了。从这里，我们开始有了Cortex系列（笔者看来是对ARM11后处理器的命名），我们都知道，ARM走到这里，已经成为了遍布各个领域的重要的处理器了，为了特化处理器，让它在不同性质的领域上发挥最好的竞争优势，我们有了三个重要的划分：

#### A,R,M三个分支的发展

##### **Cortex-A系列：应用处理器**

Cortex-A系列处理器主要面向需要运行复杂操作系统和用户应用程序的场景。这些处理器通常支持ARM、Thumb和Thumb-2指令集，旨在提供高性能的计算能力，适用于需要丰富操作系统支持的应用领域，如智能手机、平板电脑和高端嵌入式设备。Cortex-A系列处理器通常配备内存管理单元（MMU）、浮点单元和高级缓存系统，以满足高性能和多任务处理的需求。例如，Cortex-A15处理器提供强大的多核处理能力，适合需要高计算性能的应用。比如说，笔者现在在玩的IXM6ULL就是Cortex-A系列的，背靠的指令集就是ARMv7A

##### **Cortex-R系列：实时处理器**

Cortex-R系列处理器专为实时应用设计，强调高性能和低延迟响应。这些处理器广泛应用于硬盘控制器、汽车电子系统和无线通信基带处理等领域。Cortex-R系列通常不包含MMU，但配备了内存保护单元（MPU）和高效的缓存系统，以确保实时任务的快速响应和高可靠性。

##### **Cortex-M系列：微控制器内核**

Cortex-M系列处理器主要面向各类嵌入式应用，强调低功耗、低成本和高效能。这些处理器广泛应用于消费电子、工业控制和物联网设备等领域。Cortex-M系列处理器通常支持ARM Thumb指令集，并集成了嵌套向量中断控制器（NVIC），以实现快速的中断响应和高效的中断管理。例如，Cortex-M4处理器在数字信号处理和控制应用中表现出色，适合需要高效能和低功耗的场景。大家最熟悉的STM32系列就是典型的Cortex-M系列的处理器，特别的，F1系列（嘿！你肯定有几块的STM32F103C8T6，或者是初入正点原子买的STM32F13ZET6）是Cortex-M3系列的，F4则是Cortex-M4系列的。

#### ARMv7

​	2005年，伴随着移动计算和多媒体应用的需求逐渐走向历史的舞台，其需求毫无疑问的在进行爆发层级的增长，ARM抓住了这个历史机遇，推出了ARMv7。这个架构是大家至今都在研究和学习的重要架构。STM32采用的架构就是ARMv7-M。

​	ARMv7 架构的一个核心特性是对 **Thumb-2 指令集** 的全面支持。Thumb-2 是 Thumb 指令集的扩展，结合了 16 位和 32 位指令的优点。与传统的 Thumb 指令集相比，Thumb-2 提供了更高的代码密度和更好的性能。它允许开发者在同一代码中混合使用 16 位和 32 位指令，从而在保持低功耗的同时实现更高的执行效率。这一特性使得 ARMv7 架构在资源受限的嵌入式系统中更具竞争力，同时也为复杂的应用程序提供了更好的支持。这个我相信大家在学习STM32的时候会有所耳闻。

​	另一方面，我们的ARMv7对多媒体处理进行了进一步的增强：这就是**NEON 技术** 的引入。NEON 是 ARMv7 架构中的高级 SIMD（单指令多数据）引擎，专门为多媒体和数据密集型任务设计。NEON 支持 128 位宽的向量操作，能够在一个指令周期内处理多个数据元素，从而显著加速图像处理、音频解码和视频编码等应用。例如，在播放高清视频时，NEON 技术可以将解码速度提升数倍，同时降低功耗。这一特性使得 ARMv7 架构在智能手机、平板电脑和数字电视等多媒体设备中得到了广泛应用。

​	我们在V6的时候就说到了多核的问题。ARMv7 架构通过改进缓存一致性和总线协议，为多核系统的设计提供了更好的支持。这一特性使得 ARMv7 架构能够有效地处理多任务并行执行的需求，从而提高了系统的整体性能和响应速度。多核支持不仅适用于高性能计算设备，还为嵌入式系统提供了更高的灵活性和可扩展性。例如，基于 ARMv7 架构的双核和四核处理器被广泛应用于智能手机和平板电脑，为用户提供了流畅的多任务处理和游戏体验。

​	ARMv7 架构对 **内存管理单元（MMU）** 进行了进一步优化。新的 MMU 支持更大的地址空间和更高效的分页机制，从而提高了虚拟内存管理的效率。此外，ARMv7 架构还引入了 **大物理地址扩展（LPAE）** 技术，使得处理器能够支持超过 4GB 的物理内存。这一特性为高性能计算设备（如服务器和工作站）提供了更好的支持。

​	安全性被进一步提升了。通过 **TrustZone 技术**，ARMv7 架构将处理器的运行环境分为安全世界和非安全世界，从而为敏感数据和应用提供了更高的保护。TrustZone 技术广泛应用于移动支付、数字版权管理和企业安全解决方案中，为用户数据的安全性提供了硬件级别的保障。

#### ARMv8

​	2011年，ARMv8架构诞生了。ARMv8 架构的一个核心特性是 **64 位计算能力**。与 32 位架构相比，64 位架构支持更大的内存寻址空间（理论上可达 16EB），从而能够处理更大规模的数据集和更复杂的应用程序。此外，64 位架构还引入了更多的通用寄存器（从 16 个增加到 32 个），这显著提高了指令执行的效率和并行处理能力。64 位计算能力使得 ARMv8 架构在高性能计算、服务器和数据中心等领域得到了广泛应用。换而言之，ARM也有64位的处理器了，这就是AArch64，之前的就是AArch32的指令集了。**AArch64 和 AArch32 双执行状态** 的支持。AArch64 是 ARMv8 架构的 64 位执行状态，而 AArch32 是兼容 ARMv7 架构的 32 位执行状态。这种双状态设计使得 ARMv8 处理器能够同时运行 64 位和 32 位应用程序，从而实现了平滑的过渡和兼容性。例如，在智能手机中，操作系统和核心应用可以运行在 64 位模式下，而一些旧的 32 位应用仍然可以在 32 位模式下运行。

​	至于ARMv8 架构的应用范围非常广泛。基于 ARMv8 架构的处理器（如 Cortex-A53、Cortex-A57 和 Cortex-A72）被广泛应用于智能手机、平板电脑、服务器、网络设备和汽车电子等领域。例如，苹果公司的 iPhone 5s 是首款采用基于 ARMv8 架构的 64 位处理器的智能手机，这标志着 ARM 处理器在移动计算领域的全面崛起。此外，ARMv8 架构还在数据中心和高性能计算领域得到了广泛应用，例如亚马逊的 Graviton 处理器就是基于 ARMv8 架构设计的。

#### ARMv9

​	2021年，也就是4年前，ARMv9呼之欲出。ARMv9增强了ARMv8 的AArch64。与 ARMv8 架构相比，ARMv9 在 64 位计算的基础上进一步优化了指令集和处理器微架构，从而提高了指令执行的效率和并行处理能力。例如，ARMv9 引入了 **SVE2（可扩展向量扩展 2）** 技术，这是一种高级 SIMD 指令集扩展，支持更灵活的向量操作和更高的并行处理能力。SVE2 技术使得 ARMv9 处理器能够更高效地处理人工智能、机器学习和多媒体任务，从而为未来的智能设备提供了强大的计算支持。

​	另一个不能不谈的改进是 **机密计算架构（CCA）** 的引入。CCA 是 ARMv9 架构中的一项革命性安全特性，旨在为敏感数据和应用提供更高的保护。CCA 通过将处理器的运行环境分为多个安全域，使得每个域都能够独立运行和保护自己的数据。这种设计不仅提高了系统的安全性，还为云计算和边缘计算提供了更好的支持。例如，在云计算环境中，CCA 可以确保不同用户的数据和应用程序相互隔离，从而防止数据泄露和恶意攻击。

​	ARMv9 架构还引入了 **矩阵扩展（Matrix Extension）** 技术，这是一种专门为人工智能和机器学习任务设计的硬件加速技术。矩阵扩展技术通过优化矩阵运算的硬件实现，显著提高了深度学习模型的训练和推理速度。例如，在图像识别和自然语言处理任务中，矩阵扩展技术可以将计算速度提升数倍，同时降低功耗。这一特性使得 ARMv9 架构在人工智能和机器学习领域得到了广泛应用。

​	在内存管理方面，ARMv9 架构对 **内存管理单元（MMU）** 进行了进一步优化。新的 MMU 支持更大的地址空间和更高效的分页机制，从而提高了虚拟内存管理的效率。此外，ARMv9 架构还引入了 **内存标签扩展（MTE）** 技术，这是一种硬件级别的内存安全特性，旨在防止内存相关的安全漏洞（如缓冲区溢出和悬空指针）。MTE 技术通过为每个内存块分配唯一的标签，使得处理器能够检测和防止非法的内存访问，从而提高了系统的安全性和可靠性。

​	ARMv9 架构还加强了 **实时性和可预测性**。通过引入新的异常处理机制和中断控制器，ARMv9 架构能够更高效地处理实时任务和中断请求。例如，在自动驾驶和工业控制系统中，ARMv9 处理器可以确保关键任务的实时执行，从而提高系统的响应速度和可靠性。此外，ARMv9 架构还引入了 **低功耗状态** 和 **动态电压频率调节（DVFS）** 技术的进一步优化，这些技术使得处理器能够根据负载动态调整功耗和性能，从而延长了移动设备和物联网设备的电池寿命。

## Final

​	问题三这些深入了指令集细节的内容，笔者放到后一篇博客中谈论！

# Reference

​	非常非常感谢这些了不起的互联网分享精神的大佬们，笔者不少的材料参考了这样的一些文章：

### ARM架构的历史

> [ARM起源史：一家英国小公司如何发明了ARM并改变了世界 - 知乎](https://zhuanlan.zhihu.com/p/350627290)
>
> [ARM故事：起源、历程和发展-云社区-华为云](https://bbs.huaweicloud.com/blogs/262835)
>
> [艾康电脑 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/艾康電腦)

### ARM架构的发展历程：架构特点侧

[ARM 高性能处理器早期发展史_arm架构发展史-CSDN博客](https://blog.csdn.net/weixin_43126417/article/details/143077170)

[尝试梳理下ARM处理器的发展历史-CSDN博客](https://blog.csdn.net/weiqifa0/article/details/126397539)

[韦东山深度剖析ARM架构核心原理与实践 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/emacs_8780325/blog/17246566)

[arm架构发展历程介绍 - ARM - 电子发烧友网](https://www.elecfans.com/emb/arm/20171113578470.html)

[ARM 处理器版本介绍及其主要区别 – ARMFUN](https://www.armfun.cn/?p=166)

### 区分ARMv几和ARM几

[ARM系列处理器和架构 - 知乎](https://zhuanlan.zhihu.com/p/160762138)