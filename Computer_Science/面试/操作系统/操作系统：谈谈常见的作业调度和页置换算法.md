# 操作系统：谈谈常见的作业调度和页置换算法（附缺页中断 + 作业概念）

## 先说说什么是作业

在操作系统中，**作业（Job）**是用户向计算机系统提交的一整套任务集合，是系统调度和执行的基本单位。
 它不仅仅是一段可执行程序，还包含了运行所需的各种信息，例如：

1. **程序代码**：需要执行的指令序列。
2. **数据**：运行时所需的输入数据、初始变量值等。
3. **作业控制信息**：运行条件（优先级、时间限制）、资源需求（CPU、内存、外设）、作业名等。

作业是一个比“进程”更高层的概念。

- **作业**：用户提交的工作任务集合，进入系统后由作业调度决定何时进入内存执行。
- **进程**：作业被调入内存并分配资源后，在CPU上执行时的动态实体。

所以，作业调度其实是**外存（后备队列） → 内存（就绪队列）**的选择过程，而进程调度是**内存中的就绪进程 → CPU**的分配过程。

## 作业调度算法（六大类）

​	作业调度是指操作系统根据一定策略，从外存的后备作业队列中选择作业装入内存，并为其分配所需资源，以便投入运行。咱们这里要聊的就是六个基本的作业调度思想，现代的操作系统如Linux采用的是更加复杂的机制（比如说CFS）

​	**最简单的一种调度策略是先来先服务（FCFS），谁先到谁先执行。**这种策略实现非常简单，也很公平，但它对长作业有利，对短作业不够友好，因为短作业可能长时间排队等待。

​	为了改善这一点，人们提出了**短作业优先（SJF）策略**，即优先调度运行时间最短的作业。这种方法在平均等待时间和系统吞吐率上表现出色，但它要求预知作业的运行时间，这在实际系统中并不总是容易做到。此外，SJF对长作业不利，可能造成长作业饥饿。

​	为了兼顾公平与效率，**响应比高者优先（HRRN）应运而生**。它通过一个公式计算响应比：响应比等于（等待时间加运行时间）除以运行时间。这样，等待时间长的作业，即使运行时间较长，也会逐渐提升优先级，从而避免长期饥饿。

​	另一类方法是**优先级调度**。为作业分配不同优先级，高优先级先运行。这种方法灵活性高，可以保障关键任务优先执行，但如果不调整优先级，低优先级作业可能永远得不到机会。

​	在分时系统中，**时间片轮转（RR）**是一种非常常见的策略。它将CPU时间分成固定的时间片，按照队列顺序依次分配给各个作业。这样每个作业都有机会运行，公平性很高。但时间片设置过大会退化为先来先服务，设置过小则会造成频繁的上下文切换，增加系统开销。

​	为了进一步优化响应时间与吞吐量，**多级反馈队列调度（MFQ）**结合了时间片轮转和优先级调度的思想，通过动态调整作业所在的队列，实现对不同类型作业的差异化处理。

## 补充一下CFS调度器

​	值得一提的是，Linux内核的C写的非常OOP，我们的调度算法实际上被抽象成一个sched_class了，这里说的更加准确的应该是CFS Sched Class的算法。

### CFS 是什么

CFS 是 Linux 内核自 2.6.23 版本起引入的默认进程调度器，用于取代早期的 O(1) 调度器。它的目标是尽可能**公平地分配 CPU 时间**给所有可运行进程，并且能在不同优先级之间平衡公平性与响应性。

CFS 的核心理念是：**每个进程应该获得与其权重成比例的 CPU 时间，不多也不少。**

------

### 核心原理要点

#### ① 虚拟运行时间（vruntime）

- CFS 为每个进程维护一个 **虚拟运行时间**，记录该进程相对公平地使用了多少 CPU。
- 进程运行时间越多，`vruntime` 增长得越快；优先级越高（权重越大）的进程，`vruntime` 增长得越慢（即“时间更便宜”）。
- 调度器每次选择 `vruntime` 最小的进程运行。

公式（简化）：

```
vruntime += 实际运行时间 × NICE_0_LOAD / 进程权重
```

------

#### ② 红黑树（RB-Tree）

- 所有可运行进程按 `vruntime` 排序，存放在一棵红黑树中。
- 红黑树的中序遍历结果就是按 `vruntime` 排序的进程队列。
- 树的**最左节点**就是 `vruntime` 最小的进程，也就是下一个要调度的对象。
- 红黑树查找、插入、删除的时间复杂度都是 O(log N)。

------

#### ③ 时间片不是固定的

- CFS 并不为进程分配固定时间片，而是根据 **调度周期（sched_latency）** 动态分配。
- `sched_latency` 表示在理想情况下，让所有可运行进程都至少运行一次所需的总时间。
- 单个进程的时间片大致为：

```
time_slice ≈ sched_latency × (进程权重 / 所有权重总和)
```

这样进程数增多时，单个进程的时间片会变短。

------

#### ④ 负载权重（Nice 值影响）

- Linux 通过 Nice 值（-20~19）调整进程权重。
- Nice 越低（优先级高），权重越大，`vruntime` 增长越慢，获得的 CPU 时间比例更高。

------

#### ⑤ 抢占机制

- 当新进程进入就绪队列，如果它的 `vruntime` 小于当前运行进程的 `vruntime`，调度器可能立即抢占当前进程，让更“亏”的进程运行。

------

#### ⑥ 多核调度与负载均衡

- 每个 CPU 核都有自己的 CFS 运行队列（红黑树）。
- Linux 会周期性进行**负载均衡**，将任务从繁忙的 CPU 迁移到空闲 CPU，以保持各核心负载接近。

------

#### ⑦ 睡眠与唤醒补偿

- 如果进程长时间睡眠（等待 IO），`vruntime` 不会增加，唤醒后它的 `vruntime` 会比其他进程小，从而优先运行，实现对 IO 密集型进程的响应性优化。

------

### 3. 总结关键字（面试速记）

> **虚拟运行时间** 衡量公平性
>  **红黑树** 存储排序
>  **最左节点** 最先运行
>  **调度周期** 动态时间片
>  **Nice 值** 控制权重
>  **抢占机制** 让亏的先跑
>  **多核负载均衡** 保持平衡
>  **睡眠补偿** 提升响应性

## 页置换算法

如果作业调度关注的是CPU的分配，那么页置换算法则属于内存管理范畴。当进程访问一个不在内存的页面时，**会触发缺页中断。如果此时物理内存已满，就需要选择一个页面置换出去，为新页面腾出空间。**

理论上，最优置换算法（OPT）表现最好，它会淘汰**未来最长时间内不会被访问的页面**，缺页率最低。（但是你知道的，我们没法预测未来的事情不是吗？）然而，操作系统无法预知未来的访问序列，因此OPT只能作为衡量其他算法的理想基准。

​	实际中，**最简单的方法是先进先出（FIFO），即淘汰最早进入内存的页面。这种策略容易实现，但存在Belady异常，即在某些访问序列下，增加内存反而会让缺页率升高。**

​	为了更接近OPT，**人们设计了最近最少使用算法（LRU）**。它淘汰最长时间没有被访问的页面，假设过去很久没用的页面未来也不太可能被用到。LRU在性能上接近OPT，但实现起来需要硬件支持，例如为每个页面维护访问时间戳，或者用链表记录访问顺序，这些都会带来额外开销。

​	为了降低实现成本，**时钟算法（Clock）被提出**，它是LRU的近似实现。操作系统将**页面组织成一个环形队列，并为每个页面维护一个使用位**。置换时，如果遇到**使用位为1的页面，就先将其清零并跳过**；如果为0，就淘汰它。这种方法实现简单，效果也不错。（实际上是第二次机会的算法）

​	还有一种策略是最少使用频率算法（LFU），它根据页面被访问的次数决定淘汰谁，访问次数最少的页面优先被换出。这种方法适合访问模式稳定的场景，但有一个问题：某些页面可能在过去频繁使用，现在却不再需要，但它们因为历史访问次数高而长期驻留内存。

### 补充：什么是缺页中断？

​	整个问题我们需要层层递进的回答。

​	第一步，缺页中断是什么？ 缺页中断是指进程在访问虚拟内存中的某一页时，该页并不在物理内存中，CPU 在执行该指令时会触发异常，交由操作系统内核处理，将所需页面从外存（通常是磁盘）调入内存，然后恢复进程执行。它是虚拟内存系统实现按需调页（demand paging）的核心机制。

​	第二步，什么时候发生的？一句话，我们搜寻页表但是发现他不在内存中。

> 页表项（PTE, Page Table Entry）**存在**，而且标记了这个虚拟页是**合法的**（例如属于进程的代码段、数据段、堆、栈等地址空间）。（换而言之，V被标记为合法）
>
> 但是页表项里的 **Present 位（P 位）= 0**，表示该虚拟页**当前没有映射到物理页帧**（可能还在磁盘上，或者尚未分配物理内存）。
>
> 因此 CPU 在地址转换时会发现该页表项有效但 P=0，就会触发 **Page Fault** 异常，由操作系统去做“调页”动作。

​	我们可以展开出来三种最常见的常见。

1. 首次访问某个合法的虚拟页面，但该页尚未被调入内存（例如延迟加载代码页或数据页）。
2. 访问的页面之前被换出到磁盘（swap out）后，需要重新换入。
3. 访问共享库或内存映射文件的某一页，该页尚未映射到物理内存。

​	缺页中断产生了，下一个问题就是，操作系统总是要处理的吧！这里就是Linux的`do_page_fault`来看看成分如何了。

1. CPU 检测到访问的虚拟地址无对应物理页，触发 page fault 异常。（P=0）
2. 硬件将控制权交给内核，内核根据缺页异常号和虚拟地址查找页表。
3. 如果该虚拟地址是合法的（进程地址空间内且有访问权限），则判断页面不在内存的原因。
4. 选择一个空闲物理页，如果内存已满，则通过**页置换算法**（如 LRU、Clock、FIFO）换出某一页到磁盘。
5. 从磁盘（可能是 swap 区，或文件）读入所需页面到物理内存。
6. 更新页表，标记该虚拟页已在内存。
7. 恢复到触发缺页的指令重新执行。

## 逻辑关系图

```
                [ 用户提交的作业队列（外存） ]
                          │
                          ▼
                  ┌────────────────┐
                  │   作业调度算法 │
                  │ FCFS / SJF /   │
                  │ HRRN / Priority│
                  │ RR / MFQ 等    │
                  └────────────────┘
                          │   选择作业进入内存
                          ▼
                [ 内存中的就绪进程队列 ]
                          │
                          ▼
                  ┌────────────────┐
                  │   进程调度算法 │
                  │ （短进程优先、 │
                  │ 时间片轮转等） │
                  └────────────────┘
                          │
                          ▼
                       [ CPU 执行 ]
                          │
             ┌────────────┴────────────┐
             ▼                         ▼
    [ 访问内存页面 ]          [ 触发缺页中断 ]
                                      │
                                      ▼
                         ┌──────────────────┐
                         │  页置换算法       │
                         │  OPT / FIFO /     │
                         │  LRU / Clock / LFU│
                         └──────────────────┘
                                      │
                           换出旧页，装入新页
                                      │
                                      ▼
                                继续执行程序

```

