# Windows内核理解1（基于Inside Windows NT）

## 前言

​	笔者之前基本上快速和大致的梳理了下Windows上位机应用编程的基本内容后，决定效仿自己学习Linux的流程一致，仔细的看一看Windows的一些内核机制。Windows自己的内核机制非常的复杂，但是起点笔者在翻阅《Inside Windows NT》这本书的时候发现，我们仍然要从最基本的概念入手，这里也就顺手补充一下Windows中操作系统的概念和一些特殊的点。一步一步看下来Windows内核

## 从进程开始说起

​	操作系统中，我们怎么也绕不过去的话题就是进程。广义的定义上，进程是操作系统分配资源给予被执行作业的最小分配实体。咱们知道，我们在Windows的桌面上单击我们的可执行程序的图标，分配的就是一个进程容器执行他。

​	在 Windows 里，**进程（process）是一个为程序提供执行环境的容器**：它拥有自己的虚拟地址空间、已加载的可执行映像与 DLL、到系统资源的句柄集合、安全上下文（访问令牌）、一个或多个线程等。**被调度的不是进程而是线程**；线程在进程的地址空间中运行并消耗 CPU。微软官方“Processes and Threads”文档对“进程包含什么”与“线程负责执行、由内核调度”的关系有明确描述。这个部分也是笔者的参考之处。	

## 进程包含什么？

#### 私有的虚拟地址空间（Virtual Address Space, VAS）

​	这个我认为任何一位学习了Linux或者是操作系统的朋友都会觉得没什么稀奇的，虚拟地址为每个用户态进程都抽象了一台虚拟的完整的内存卡，实际上一个应用程序就好像独占了我们的计算机。一个 64 位进程在 64 位 Windows 上拥有高达 **128 TB** 量级的用户态地址空间范围；32 位进程通常可用 **2 GB**（或在特定配置下 3 GB）。这些范围与“进程间隔离”的内存模型是内存管理的基础。（好像能够理解，Linux32位操作系统的分配是1GB内核和3GB的内存，啊哈，很好理解，Windows还要塞一个GUI子系统嘛！）

#### **工作集（Working Set）**

进程虚拟地址空间中，**当前驻留在物理内存**的一小部分称为工作集，这是观测“此刻进程真正在 RAM 里”内存占用的关键概念。

#### **常见内存内容**

映像节（EXE/DLL 的代码与数据段）、各线程的栈、进程堆（见下节）、以及通过 `VirtualAlloc/VirtualFree` 等 API 直接保留/提交的区域。

#### 可执行映像与模块列表（Image & Modules）

进程会把主可执行文件（.exe）以及依赖的 DLL 映射进地址空间；**进程环境块 PEB** 持有加载器数据 `Ldr`（`PEB_LDR_DATA`），维护**已加载模块列表**，并保存**进程参数**（见下一小节）。

#### 进程参数（命令行、环境块、当前目录等）

**命令行与进程参数**：PEB 的 `ProcessParameters` 指向 `RTL_USER_PROCESS_PARAMETERS`，其中包含进程的**命令行**、工作目录、窗口状态等信息。

**环境变量（Environment Block）**：每个进程继承并维护自己的**环境字符串块**，通过 Win32 “Environment variables” 文档与相关 API（如 `GetEnvironmentStrings` / `SetEnvironmentVariable`）可见

#### 句柄表与对象（Handles & Objects）

Windows 通过**对象（object）与句柄（handle）来管理内核与系统资源（文件、事件、进程、线程、同步体、注册表键、GDI/USER 对象等）。应用不能直接触碰对象本体，而是通过\句柄间接访问；**每个句柄在系统维护的句柄表中有条目**。句柄是进程语义下的标识，通常**只在创建它的进程里有意义**

#### 安全上下文（Security Context）

​	这部分内容笔者不妨在这里，咱们只需要知道进程的安全上下文保证了我们可以安全的执行我们的代码，确保我们拥有正确的权限即可。

#### 线程（Threads）

**线程是 CPU 的调度实体**；一个进程至少有一个线程，更多工作通常通过额外线程完成。线程共享进程的地址空间与大多数资源，但有**独立的栈**与线程本地数据结构。

#### 堆（Heaps）

每个进程都有一个**默认进程堆**（`GetProcessHeap` 可取到），并且可以通过 `HeapCreate` 创建**多个私有堆**；分配/释放通过 `HeapAlloc/HeapFree` 等完成，Windows 还支持**低碎片堆（LFH）**策略以降低碎片。

#### 标识、优先级与会话

- **进程 ID（PID）**：系统为每个进程分配唯一 PID，用于管理与诊断（任务管理器/工具显示）。
- **优先级类（priority class）与线程优先级**共同影响调度倾向（线程最终被调度）。该关系见“Processes and Threads”总览。
- **会话（Session）**：PEB 中包含 `SessionId` 字段，指示进程所属的终端会话；这在多会话环境（例如远程会话）下尤其重要。

------

### 把上面的核心点提出来

1. 独立的虚拟地址空间（包含代码/数据段、栈、堆、映射区等；其驻留集叫工作集）；
2. 已加载的映像与 DLL 列表（PEB->Ldr 维护）；
3. 进程参数（命令行、环境块、工作目录等，PEB->ProcessParameters 提供）；
4. 句柄集合（通过对象管理+句柄表访问各种内核/用户对象）；
5. 安全上下文（访问令牌、完整性级别、可选 AppContainer）；
6. 一个或多个线程（调度单位，每个线程有自己的栈，并共享进程资源）；
7. 默认堆与可选私有堆；
8. PID、优先级类、会话 ID 等元数据。

## Windows的线程和纤程

### **核心概念：线程、纤程的关系**

咱们首先看看定义，知道他是什么很重要！

1. **线程（Thread）**: 是进程内的一个执行单元，是CPU调度的基本单位。一个进程可以包含多个线程，它们共享进程的资源（如内存空间、文件句柄），但每个线程有自己独立的**栈（Stack）**、**寄存器集合（Register Set）\**和\**线程局部存储（Thread Local Storage, TLS）**。
2. **纤程（Fiber）**: 也被称为“用户态线程”，它比线程更轻量级。多个纤程可以运行在**一个**线程之上。纤程的调度完全由应用程序在用户态下控制，操作系统内核对此一无所知。

现在，我们想我们捋清楚了Windows进程管理体系了：进程下分了线程作为真正的内核级别调度单位，纤程进一步的在用户态作为了快速的切换函数执行所在的位置的一个抽象实体。

### **线程 (Thread) - 内核调度的执行单元**

线程是操作系统能够进行CPU调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。Windows是一个支持多线程的操作系统，它通过一种**抢占式多任务（Preemptive Multitasking）**的机制来调度线程。这意味着操作系统内核（Kernel）决定哪个线程在何时运行多长时间（称为时间片或量子，Quantum），并且可以在任何时候中断一个正在运行的线程，以便让另一个线程运行，即使用户代码没有主动放弃CPU。

1. **数据结构**:
   - **ETHREAD (Executive Thread Block)**: 这是一个位于内核空间但部分暴露给Windows子系统的数据结构。它包含了线程的大部分信息，如线程ID、所属进程、线程的I/O请求列表等。
   - **KTHREAD (Kernel Thread Block)**: 这是ETHREAD的第一个成员，是内核调度器真正需要的部分。它包含了纯粹用于调度的信息，如线程的优先级、状态（运行、就绪、等待等）、栈指针、CPU寄存器上下文等。当线程被切换出去时，它的CPU寄存器状态会被保存在KTHREAD中。
2. **创建与销毁**:
   - 通过调用Win32 API `CreateThread()` 或C/C++运行时库函数 `_beginthreadex()` 来创建一个新的线程。
   - 创建线程时，操作系统会在内核中分配并初始化ETHREAD和KTHREAD结构，并为线程分配一个用户态栈和一个内核态栈。
   - 线程执行完毕或被 `ExitThread()`、`TerminateThread()` 终止。
3. **调度 (Scheduling)**:
   - **调度者**: Windows内核调度器。
   - **机制**: 抢占式。调度器根据线程的**优先级（Priority）**和**状态（State）**来决定下一个要运行的线程。高优先级的就绪线程会抢占低优先级线程的CPU。同优先级的线程会轮流运行（Round-Robin）。
   - **上下文切换 (Context Switch)**: 当调度器决定切换线程时，会发生一次上下文切换。这个过程大致如下：
     1. 从用户模式切换到内核模式。（这就是对应的定时器中断触发调度，进入内核态方便操作）
     2. 保存当前线程的寄存器状态到其KTHREAD结构中。（保存当前的堆栈）
     3. 调度器算法选出下一个要运行的线程。（调度Schedule）
     4. 从下一个线程的KTHREAD结构中加载其寄存器状态。（选择出来的下一个要加载）
     5. 切换虚拟地址空间（如果新线程属于不同进程）。（加载虚拟内存）
     6. 从内核模式切换回用户模式，新线程开始执行。（进一步执行）
   - 这是一个相对**昂贵**的操作，因为它涉及到了CPU模式的切换和大量状态的保存/加载。
4. **优点**:
   - **真并行**: 在多核CPU上，多个线程可以同时在不同的核心上执行，实现真正的并行计算。
   - **简化的编程模型**: 开发者无需关心调度细节，操作系统会自动处理。
   - **阻塞处理**: 一个线程如果因为I/O操作（如读文件、等网络数据）而阻塞，操作系统会自动调度其他就绪的线程来运行，不会浪费CPU。
5. **缺点**:
   - **资源开销**: 每个线程都需要独立的内核数据结构和栈空间（默认为1MB），创建大量线程会消耗可观的内存。
   - **上下文切换开销**: 频繁的线程切换会带来显著的性能开销。
   - **同步复杂性**: 由于线程并发执行且共享数据，必须使用复杂的同步机制（如互斥锁Mutexes、临界区Critical Sections、信号量Semaphores等）来避免数据竞争，这很容易出错。

### **2. 纤程 (Fiber) - 用户控制的执行单元**

纤程是一种完全在**用户模式（User Mode）\**下实现和调度的执行体。它依附于某一个线程，一个线程可以承载多个纤程。纤程的调度采用\**协作式多任务（Cooperative Multitasking）**。这意味着一个纤程一旦开始运行，它会一直运行下去，直到它**主动**调用特定函数放弃CPU控制权给另一个纤程。操作系统内核对纤程的存在一无所知，它只知道承载这些纤程的那个线程。

1. **数据结构**:
   - 纤程的上下文（主要是CPU寄存器和栈指针）由应用程序自己管理，保存在用户模式的内存中。内核中没有与纤程直接对应的KTHREAD或ETHREAD结构。
2. **创建与调度**:
   - **第一步：转换线程**: 一个普通的线程不能直接创建和调度纤程。它必须首先调用 `ConvertThreadToFiber()` 将自己转换成一个纤程。这个初始纤程会成为调度其他纤程的“根”。
   - **第二步：创建新纤程**: 使用 `CreateFiber()` 来创建新的纤程。你需要为它指定栈大小和一个入口函数。这个函数调用只是分配内存并设置好初始状态，并不会立即执行。
   - **第三步：调度切换**: 关键函数是 `SwitchToFiber()`。当一个纤程调用 `SwitchToFiber(otherFiber)` 时：
     1. 当前纤程的寄存器上下文被保存到它自己的数据结构中（在用户态内存）。
     2. `otherFiber` 的上下文被从它的数据结构中加载到CPU寄存器。
     3. 程序执行流立即跳转到 `otherFiber` 上次中断的地方继续执行。
   - 整个切换过程完全在用户态完成，**没有内核模式的转换**。
3. **销毁**:
   - 通过 `DeleteFiber()` 来释放一个纤程所占用的资源。
4. **优点**:
   - **极低的切换开销**: 纤程切换只是保存/加载寄存器，本质上是一次函数调用，速度极快，比线程的上下文切换快几个数量级。
   - **极小的资源占用**: 纤程的栈可以由程序员自己指定，可以非常小。可以轻松创建成千上万个纤程。
   - **无需同步**: 在单个线程上，任何时候只有一个纤程在运行，因此访问共享数据不需要加锁，大大简化了编程。
5. **缺点**:
   - **无真并行**: 所有纤程都运行在同一个线程上，因此它们共享该线程的一个CPU核心。它们是并发，但不是并行。
   - **阻塞问题**: 这是纤程模型的**致命弱点**。如果一个纤程调用了一个阻塞式的系统调用（如同步文件读写），那么承载它的整个**线程**都会被阻塞。这会导致该线程上的所有其他纤程都无法运行，即使它们是就绪状态。
   - **编程复杂**: 程序员必须手动管理调度逻辑。你需要自己决定何时、切换到哪个纤程，并确保没有纤程会“饿死”（永远得不到执行机会）。

## Windows的虚拟内存

​	咱们上面已经交叉的提到了虚拟内存，虚拟内存（virtual memory）是 OS 为每个进程提供的**独立、隔离且可超配的地址空间**，它把“程序看到的线性地址”映射到物理内存页或磁盘（页面文件）上的备份。这样可以实现进程间地址隔离、程序地址空间大于实际物理 RAM、以及按需加载（demand paging）。

​	虚拟内存到真实的物理内存的桥接是依靠页表进行维护的。一般而言，页面的大小是4KB，页自身也是硬件映射维护上的最小管理单位。

​	对于页表，咱们的CPU/MMU 用多级页表把虚拟页号映射到物理页框（PFN）。Windows 在缺页时会“懒惰”地建立或补全这些页表项。

#### 进程的虚拟地址空间（VAS）与 VAD（Virtual Address Descriptors）

**每个进程都有自己的 VAS**（32 位/64 位的可寻址范围由 OS/架构决定）。例如微软文档指出：32 位进程典型 4GiB（或 3GiB 配置），64 位有更大的用户空间限制。

**VAD（Virtual Address Descriptor）树**：Windows 用一棵内核数据结构（VAD tree）记录“被分配的虚拟区间”（即哪段地址被 reserve/commit、权限、是否是映射文件等）。内核在处理访问和分配时会查 VAD，而不是事先为每个保留区建立页表。调试器的 `!vad` 命令可以查看 VAD。

#### Reserve vs Commit（懒分配） & 关键 API

**Reserve（保留）**：保留虚拟地址范围，不占实际物理或 pagefile 空间（`MEM_RESERVE`）。

**Commit（提交）**：把虚拟页“承诺”有 backing 存储（物理内存或 pagefile），会增加系统的 commit charge（见下）。可以一次性 reserve+commit。API：`VirtualAlloc`/`VirtualFree`、`VirtualProtect`、`VirtualQuery` 等。

------

#### 页面到物理页的管理：PFN 数据库与页面列表

Windows 维护一个**PFN（Page Frame Number）数据库**来跟踪每个物理页的状态；常见的页面列表包括：**Free、Zeroed、Standby、Modified、Active/Valid、Transition** 等。页面被从工作集中剥离后通常先进入 Standby（可被快速回收，发生“soft fault”即可重用）；写回磁盘后成为 Free/Zeroed。用内核调试命令（如 `!memusage`）能看到 PFN 数据和列表统计。

------

#### 工作集（Working Set）与缺页（Page Fault）

- **工作集**：某进程在某时刻内“实际驻留在物理内存中”的那部分页集合。访问不在工作集的页面会产生缺页。系统会尝试将被访问页加入工作集。
- **软缺页（soft/minor） vs 硬缺页（hard/major）**：
  - 软缺页：所需页在物理内存的某处（例如 standby 或别的进程的工作集），只需更新页表即可，开销小。
  - 硬缺页：页确实不在物理内存，需要从 pagefile 或映射文件读回，产生磁盘 I/O，开销大。
- **处理流程**：CPU 触发 page fault → 内核陷入（trap）→ 内存管理器（例：`MmAccessFault`）处理：检查 VAD、构造/更新 PTE、如果需要则读取磁盘并将页放入工作集，最后复位线程继续执行。微软 AskPerf 和 Windows Internals 有流程说明。

------

#### 提交（Commit）、页面文件（pagefile）与系统 Commit Limit

**Commit charge（已提交内存）**：系统已承诺的、需要 backing（RAM 或 pagefile）的虚拟内存总量。系统有一个 **commit limit**（大致等于可用物理内存 + 所有 pagefile 大小），commit charge 达到 limit 会导致系统拒绝新的提交请求并弹出“虚拟内存不足”警告。Pagefile 的设置直接影响 commit limit。微软对 pagefile / commit 的运作有专门文档。

------

#### 现代改进（Windows 10+）：内存压缩、预写与延迟写回

- **内存压缩（memory compression）**：从 Windows 10 的某些版本起，Memory Manager 可以**在物理内存中将不常访问页压缩**并放入一个压缩存储（以避免立即写入 pagefile），从而减少磁盘 I/O 和提升响应性（以 CPU 代价换 I/O）。

------

#### 内存映射/共享 & 复制写（Copy-on-Write）

**内存映射文件（file mapping）**：通过 `CreateFileMapping` + `MapViewOfFile`，文件内容被映射到进程虚拟地址，页面按需装入物理内存；多个进程可以映射同一文件以实现高效共享。映射文件也支持写时复制（COW），内核会使用 prototype PTEs 来实现共享/复制行为。

