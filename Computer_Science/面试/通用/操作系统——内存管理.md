# 说一说Malloc函数的底层？

`malloc()` 的底层实现是一个复杂且依赖于操作系统的过程，但其核心思想是管理一块**堆 (Heap)** 内存区域，以高效地响应用户对内存的请求。

**`malloc` 实现的几个关键概念：**

1. **系统调用：**
   - `malloc` 本身并不是一个系统调用。它是一个 C 标准库函数，是基于底层操作系统提供的系统调用来实现的。
   - **`sbrk()` (或 `brk()`)：** 在早期或某些Unix/Linux系统上，`malloc` 会通过`sbrk()`系统调用来调整进程的**数据段 (data segment)** 的末尾（即**程序中断点** `program break`）。通过移动程序中断点，可以向进程的虚拟地址空间添加或移除内存。
   - **`mmap()`：** 在现代Unix/Linux系统上，对于较大的内存分配请求（通常是128KB或更大，这个阈值是可配置的），`malloc` 更倾向于使用`mmap()`系统调用。`mmap()`可以将文件或匿名内存区域映射到进程的虚拟地址空间，提供更灵活的内存管理方式，且更适合大块内存分配。对于小块内存分配，`sbrk()`仍然可能被使用，但`mmap()`逐渐成为主流。
   - **Windows系统：** 在Windows上，`malloc` 通常通过 `HeapAlloc` 或直接调用 `VirtualAlloc` 等API来获取内存。
2. **内存池管理：**
   - 操作系统系统调用（`sbrk` 或 `mmap`）的开销相对较大。如果每次 `malloc` 都直接调用系统调用，效率会很低。
   - 因此，`malloc` 的实现通常会维护一个**内存池 (Memory Pool)**。当进程第一次请求内存或请求的内存不足时，`malloc` 会通过系统调用一次性向操作系统申请一大块内存。
   - 这块大内存块被划分为更小的、可管理的单元，形成一个内存池。后续的小块 `malloc` 请求可以直接从这个内存池中分配，避免频繁的系统调用。
3. **内存分配算法：**
   - `malloc` 内部需要一套复杂的算法来管理内存池中的空闲块。常见的算法包括：
     - **首次适应 (First Fit)：** 从空闲链表中找到第一个足够大的块。
     - **最佳适应 (Best Fit)：** 遍历整个空闲链表，找到最接近所需大小的块。
     - **最差适应 (Worst Fit)：** 找到最大的空闲块，从中分割出所需大小，剩下的最大。
     - **伙伴系统 (Buddy System)：** 将内存块大小限制为2的幂次，以便于快速合并和分割。
     - **哈希表或红黑树等数据结构：** 用于高效地查找和管理空闲内存块。
4. **内存碎片：**
   - `malloc` 的实现必须考虑**内存碎片**问题。
     - **内部碎片：** 分配的内存块比实际请求的要大，多余的部分无法被其他请求利用。
     - **外部碎片：** 内存池中存在大量不连续的小空闲块，虽然总和足够大，但无法满足大块内存请求。
   - 优秀的 `malloc` 实现会通过合并相邻的空闲块、采用合适的分配算法等方法来尽量减少碎片。
5. **线程安全：**
   - 在多线程环境中，`malloc` 需要保证线程安全，防止多个线程同时修改内存管理数据结构导致错误。通常通过**互斥锁**来实现对内存管理结构的保护。

**简要流程（以Linux `glibc` 库的 `malloc` 为例）：**

1. **小型请求：** 如果请求的内存大小小于某个阈值（例如128KB），`malloc` 会尝试从其内部维护的**空闲链表 (free list)** 中查找合适的内存块。这些空闲块是从之前通过`sbrk`或`mmap`分配的大块内存中分割出来的。
2. **大型请求：** 如果请求的内存大小超过阈值，`malloc` 倾向于直接调用 `mmap()` 系统调用向操作系统申请独立的、匿名内存区域。
3. **释放内存：** `free()` 函数接收一个指针，将其指向的内存块标记为已释放，并将其归还到 `malloc` 内部的空闲链表或直接解除映射（对于`mmap`分配的）。`free` 也会尝试合并相邻的空闲块以减少碎片。

`malloc` 的具体实现细节可以在不同的 C 库（如 `glibc`、`jemalloc`、`tcmalloc`）中有所不同，这些库都在致力于提供更高性能、更低碎片和更好线程安全性的内存管理。

------

## 什么是 `mmap`和`munmap`？

`mmap` 是 Linux/Unix 系统中一个非常重要的**内存映射（Memory Map）系统调用。它的核心功能是将文件或设备**的全部或一部分内容，映射到调用进程的**虚拟地址空间**中。一旦映射成功，程序就可以像访问普通内存一样直接读写这段映射区域，而所有的读写操作都会自动地、透明地反映到被映射的文件或设备上。

### mmap能干啥？

1. 文件映射，将磁盘读写转化成内存读写。
2. 匿名映射（Anonymous Mapping），他不与任何文件关联，而是映射一块匿名的、只存在于内存中的区域。这个东西用在跨越进程的IPC通信中。


### 文件映射

将一个文件或文件的一部分区域映射到进程的虚拟地址空间。

- **I/O 效率高**：
  - **减少系统调用次数**：传统的文件读写（`read()`/`write()`）需要多次系统调用，每次调用都涉及用户态和内核态的切换，以及数据从内核缓冲区到用户缓冲区的拷贝。`mmap` 只需要一次 `mmap` 系统调用建立映射，之后所有的读写都在内存中进行，无需额外的系统调用。
  - **减少数据拷贝**：数据不再需要从磁盘 -> 内核缓冲区 -> 用户缓冲区 的两次拷贝，而是直接通过页表映射，将文件内容“投影”到用户地址空间，实现**零拷贝（Zero-Copy）**或单次拷贝。这大大提高了大文件读写的效率，尤其是在文件频繁读写或作为进程间通信的共享介质时。
- **方便随机访问**：对于大文件，传统方法进行随机访问需要频繁地使用 `lseek()` 配合 `read()`/`write()`，效率低下。`mmap` 允许像访问数组一样直接通过内存地址加偏移量来访问文件任意位置的数据，非常方便且高效。
- **简化编程模型**：将文件操作转换为内存操作，使代码更直观、简洁。
- **惰性加载（Lazy Loading）**：文件内容不是一次性全部加载到内存，而是按需（Page Fault）加载。只有当进程实际访问到某个映射页时，该页才会从磁盘加载到物理内存，节约了内存资源。
- **数据共享**：允许多个进程将同一个文件映射到各自的地址空间，实现高效的**进程间通信（IPC）**，因为它们共享同一份物理内存中的文件数据，避免了额外的数据拷贝。

### 匿名映射

- **高效进程间通信（IPC）**：如果多个进程 `mmap` 相同参数且没有指定文件描述符（即匿名映射），它们可以共享一块内存区域，实现共享内存通信。这通常比管道、消息队列等其他 IPC 机制效率更高。
- **替代 `malloc()`**：对于需要分配大块内存的场景，`mmap` 可以比 `malloc()` 更高效，因为它直接向操作系统请求页面，减少了 `malloc()` 内部的堆管理开销。在某些高并发或特定内存管理需求下，直接使用 `mmap` 可能更具优势。

### 实际操作

​	下面这个函数是mmap的原型：

```
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

- `addr`：
  - 指向希望映射的内存起始地址的指针。通常设置为 `NULL`，表示由内核选择合适的地址。如果指定了非 `NULL` 值，内核会尝试在此地址附近创建映射，但不保证成功。
- `length`：
  - 映射区域的长度（字节数）。必须是页大小的整数倍。
- `prot`：
  - 内存保护标志，指定映射区域的访问权限。可以按位或 (`|`) 组合。
    - `PROT_EXEC`：可执行。
    - `PROT_READ`：可读。
    - `PROT_WRITE`：可写。
    - `PROT_NONE`：不可访问。
- `flags`：
  - 映射行为的标志位，可以按位或 (`|`) 组合。
    - `MAP_SHARED`：**共享映射**。对映射区域的修改会反映到原始文件，并且对该文件的其他 `MAP_SHARED` 映射进程可见。用于共享文件或实现进程间通信。
    - `MAP_PRIVATE`：**私有映射**。对映射区域的修改不会反映到原始文件，也不会影响其他进程的映射。每次修改都会创建一个私有的写时拷贝（Copy-on-Write）副本。
    - `MAP_ANONYMOUS` (或 `MAP_ANON`)：**匿名映射**。不映射任何文件，而是创建一块新的、不与文件关联的内存区域。通常 `fd` 设为 -1，`offset` 设为 0。
    - `MAP_FIXED`：强制内核使用 `addr` 指定的精确地址。如果该地址不可用，`mmap` 会失败。不推荐在一般应用中使用，因为可能导致地址冲突。
- `fd`：
  - 要映射的文件的文件描述符。对于匿名映射，通常设为 -1。
- `offset`：
  - 文件内容的起始偏移量（字节数）。必须是页大小的整数倍。

**返回值：**

- 成功时，返回映射区域的起始地址（`void *` 类型）。
- 失败时，返回 `MAP_FAILED`（通常是 `(void *)-1`），并设置 `errno`。

### munmap

```
#include <sys/mman.h>
int munmap(void *addr, size_t length);
```

- `addr`：`mmap` 返回的映射区域的起始地址。
- `length`：映射区域的长度，必须与 `mmap` 时指定的长度一致。

**返回值：**

- 成功时，返回 0。
- 失败时，返回 -1，并设置 `errno`。

## 代码

### 文件映射

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main() {
    const char *filepath = "mmap_example.txt";
    const char *content = "Hello, mmap!";
    int fd;
    struct stat sb;
    char *mapped_mem;
    size_t file_size;

    // 1. 创建并写入文件，确保文件存在且有内容
    fd = open(filepath, O_RDWR | O_CREAT | O_TRUNC, 0666);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    if (write(fd, content, strlen(content)) == -1) {
        perror("write");
        close(fd);
        exit(EXIT_FAILURE);
    }
    // 调整文件大小以适应内容，如果文件太小，mmap可能失败或导致段错误
    // 或者直接lseek到末尾并write一个字节以设置文件大小
    if (ftruncate(fd, strlen(content)) == -1) {
        perror("ftruncate");
        close(fd);
        exit(EXIT_FAILURE);
    }
    close(fd); // 重新打开以获取正确的文件大小，或者直接stat

    // 2. 获取文件大小
    fd = open(filepath, O_RDWR);
    if (fd == -1) {
        perror("open (again)");
        exit(EXIT_FAILURE);
    }
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        close(fd);
        exit(EXIT_FAILURE);
    }
    file_size = sb.st_size;

    // 3. 将文件映射到内存
    mapped_mem = (char *)mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mapped_mem == MAP_FAILED) {
        perror("mmap");
        close(fd);
        exit(EXIT_FAILURE);
    }

    printf("Original content from mapped memory: %s\n", mapped_mem);

    // 4. 修改映射内存中的内容，这会直接修改文件
    char *new_content = "World!";
    // 确保不会越界
    if (strlen(new_content) <= file_size) {
        strncpy(mapped_mem + 7, new_content, strlen(new_content)); // 从 "Hello, " 后面开始修改
        printf("Modified content in mapped memory: %s\n", mapped_mem);
    } else {
        printf("New content too long for file size.\n");
    }


    // 5. 解除内存映射
    if (munmap(mapped_mem, file_size) == -1) {
        perror("munmap");
    }

    // 6. 关闭文件描述符
    close(fd);

    // 7. 验证文件内容是否被修改（通过普通 read 再次打开文件）
    printf("Verifying file content after mmap modification...\n");
    fd = open(filepath, O_RDONLY);
    if (fd == -1) {
        perror("open for verification");
        exit(EXIT_FAILURE);
    }
    char read_buffer[20];
    ssize_t bytes_read = read(fd, read_buffer, sizeof(read_buffer) - 1);
    if (bytes_read > 0) {
        read_buffer[bytes_read] = '\0';
        printf("Content in file after mmap modification: %s\n", read_buffer);
    }
    close(fd);

    // 清理文件
    unlink(filepath);

    return 0;
}
```

### 匿名映射

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

int main() {
    const size_t shm_size = 4096; // 共享内存大小，通常是页的整数倍
    char *shared_memory;
    pid_t pid;

    // 1. 创建匿名共享映射区域
    // MAP_ANONYMOUS 标志表示不与文件关联
    // MAP_SHARED 标志表示允许多个进程共享此区域
    shared_memory = (char *)mmap(NULL, shm_size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    if (shared_memory == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    printf("Shared memory address in parent: %p\n", shared_memory);

    pid = fork();

    if (pid == -1) {
        perror("fork");
        // 2. 进程创建失败，解除映射
        munmap(shared_memory, shm_size);
        exit(EXIT_FAILURE);
    } else if (pid == 0) { // 子进程
        printf("Child process: Shared memory address: %p\n", shared_memory);
        // 子进程读取父进程写入的数据
        printf("Child process: Read from shared memory: %s\n", shared_memory);

        // 子进程修改共享内存
        char *child_msg = "Hello from Child!";
        strncpy(shared_memory, child_msg, shm_size - 1);
        shared_memory[shm_size - 1] = '\0'; // 确保字符串以null结尾
        printf("Child process: Wrote to shared memory: %s\n", shared_memory);

        // 3. 子进程解除映射
        munmap(shared_memory, shm_size);
        exit(EXIT_SUCCESS);
    } else { // 父进程
        // 父进程写入数据到共享内存
        char *parent_msg = "Hello from Parent!";
        strncpy(shared_memory, parent_msg, shm_size - 1);
        shared_memory[shm_size - 1] = '\0'; // 确保字符串以null结尾
        printf("Parent process: Wrote to shared memory: %s\n", shared_memory);

        // 等待子进程结束
        wait(NULL);

        // 父进程再次读取共享内存，查看子进程的修改
        printf("Parent process: After child, read from shared memory: %s\n", shared_memory);

        // 4. 父进程解除映射
        munmap(shared_memory, shm_size);
        printf("Parent process: Unmapped shared memory.\n");
    }

    return 0;
}
```

`mmap` 在操作系统和应用程序中有着广泛的应用：

- **数据库系统**：许多数据库系统（如 PostgreSQL, MongoDB, Redis AOF 持久化）使用 `mmap` 来管理其数据文件，以实现高效的 I/O 和缓存管理。
- **Web 服务器**：静态文件服务通常使用 `mmap` 来将文件内容映射到内存，然后直接通过映射的内存将数据发送给客户端，减少了 CPU 拷贝。
- **动态链接库**：程序的动态链接库（.so 文件）就是通过 `mmap` 映射到进程的虚拟地址空间中的。
- **进程间通信（IPC）**：作为一种高效的共享内存机制，用于同一主机上不同进程间的大数据量传输。
- **大文件处理**：对于需要处理远大于物理内存的大文件（例如，日志分析、大型文本处理），`mmap` 允许程序分段访问文件，而无需将整个文件加载到内存。
- **零拷贝技术**：在网络传输和文件传输中，`mmap` 是实现零拷贝的关键技术之一，如 `sendfile()` 系统调用在内部就可能利用了类似的技术。

### `mmap` 的注意事项

- **页对齐**：`length` 和 `offset` 参数通常需要是系统页大小（通常是 4KB）的整数倍。如果不是，`mmap` 可能会自动调整或返回错误。
- **内存同步**：对于 `MAP_SHARED` 映射，内存中的修改会自动同步回文件。然而，为了确保数据被及时写入磁盘（例如，在系统崩溃前），可能需要使用 `msync()` 系统调用手动将修改强制刷新到磁盘。
- **内存不足**：如果系统物理内存或交换空间不足，`mmap` 可能会失败。
- **文件大小**：映射文件时，即使只映射一部分，也需要确保文件实际大小至少等于 `offset + length`。否则，访问超出文件末尾的映射区域可能会导致 `SIGBUS` 信号（总线错误）。
- **迭代器/指针失效**：`mmap` 返回的是一个原始指针。在使用 C++ 容器等时，要特别注意这些容器内部的指针或迭代器是否与 `mmap` 区域冲突或被意外修改。

通过 `mmap`，开发者可以利用操作系统底层的内存管理机制，实现更高效、更灵活的文件和内存操作。

## 在1G内存的计算机中能否malloc(1.2G)？为什么？



**在1G物理内存的计算机中，理论上**可以**成功调用 `malloc(1.2G)`，但实际上能否成功以及能否实际使用，需要分情况讨论：

**为什么理论上可以成功调用 `malloc(1.2G)`？**

这主要得益于现代操作系统的**虚拟内存 (Virtual Memory)** 机制。

1. **虚拟内存：** 操作系统为每个进程提供了一个独立的、连续的**虚拟地址空间**（例如，在64位系统上通常高达256TB，即使是32位系统也有4GB）。当程序调用 `malloc` 请求内存时，它请求的是**虚拟内存**，而不是直接请求物理内存。
2. **按需分配 (Demand Paging)：** 操作系统并不会在 `malloc` 调用时立即分配所有请求的物理内存。它只会将请求的虚拟地址范围标记为“已分配”或“可用”，但实际的物理内存页只有在程序**真正访问**这些虚拟地址时（发生**缺页中断**）才会被分配和映射。
3. **内存超售 (Overcommit)：** 许多操作系统（尤其是Linux）默认开启了内存超售机制。这意味着操作系统允许应用程序请求的虚拟内存总量超过实际可用的物理内存。操作系统认为，大部分程序请求的虚拟内存并不会被立即或完全访问。

**为什么实际能否成功以及能否实际使用，需要分情况讨论？**

1. **成功调用 `malloc(1.2G)`：**
   - 如果你的操作系统支持内存超售（如Linux默认），并且你的进程有足够的虚拟地址空间，那么 `malloc(1.2G)` 很可能会**成功返回一个非 `NULL` 指针**。这表示你已经“预定”了1.2GB的虚拟内存。
   - 在Windows上，默认不进行内存超售，但如果设置了足够的**页面文件 (Page File)**，且系统总的提交限制（Commit Limit）允许，`malloc` 仍然可能成功。
2. **实际使用这1.2GB内存：**
   - 当你开始**实际写入或读取**这1.2GB的虚拟内存时，操作系统会尝试将对应的虚拟页映射到物理内存。
   - **如果物理内存（1G）加上交换空间 (Swap Space / Page File) 的总和大于或等于1.2GB，** 那么你可以正常地使用这1.2GB内存。操作系统会根据需要将不活跃的物理内存页换出到磁盘上的交换空间，为新的内存请求腾出物理内存。
   - **如果物理内存（1G）加上交换空间的`总和小于1.2GB`，** 那么当程序访问超过物理内存和交换空间总和的虚拟内存时，就会发生**内存耗尽 (Out Of Memory, OOM)** 错误。在Linux上，可能会触发 **OOM Killer**，它会选择并杀死一个或多个进程来释放内存，通常是占用内存最大的那个。在Windows上，可能会导致程序崩溃。

**结论：**

- 在1G物理内存的机器上，**`malloc(1.2G)` 可能会成功返回一个指针**（尤其是在Linux等支持内存超售的系统上）。
- 然而，**能否实际使用这1.2GB内存，取决于你的物理内存加上交换空间的总和是否足够。** 如果不够，程序在访问超出可用物理+交换内存的部分时会崩溃或被系统杀死。
- 这种机制的优势在于，程序可以请求比实际物理内存更大的地址空间，使得编程更加灵活，同时提高了内存的利用率。

## 进程的基本的内存分布

1. **代码段 (Text Segment / Code Segment)：**
   - 存放CPU执行的机器指令（可执行代码）。
   - 通常是**只读 (read-only)** 的，以防止程序意外修改自身代码。
   - 在内存中通常位于最低地址。
2. **数据段 (Data Segment / Initialized Data Segment)：**
   - 存放已初始化的**全局变量**和**静态变量**。
   - 在程序启动时，这些变量会被加载器从可执行文件中读取并初始化。
   - 可读写。
3. **BSS 段 (Block Started by Symbol Segment / Uninitialized Data Segment)：**
   - 存放**未初始化**的**全局变量**和**静态变量**。
   - 这部分变量在程序加载时会被系统自动初始化为**零**或空指针。
   - 可读写。
   - 它不占用可执行文件空间，只在运行时分配内存。
4. **堆 (Heap)：**
   - 用于程序运行时的**动态内存分配**。
   - 程序员通过 `malloc()`, `calloc()`, `realloc()` 等函数申请内存。
   - 内存的分配和释放由程序员手动管理 (`free()`)。
   - 堆是从低地址向高地址增长。
   - 可读写。
5. **栈 (Stack)：**
   - 用于存放**局部变量**、**函数参数**、**返回地址**等。
   - 栈由编译器自动管理，遵循“先进后出”(LIFO) 原则。
   - 每次函数调用都会创建一个栈帧。
   - 栈是从高地址向低地址增长。
   - 可读写。
6. **命令行参数和环境变量：**
   - 通常位于栈的上方，用于存储程序启动时的命令行参数和环境变量。

**简化示意图：**

```
高地址 --------------------------
       | 命令行参数 & 环境变量   |
       |-------------------------|
       |        栈 (Stack)       |
       |      (向下增长)         |
       |                         |
       |-------------------------|
       |        堆 (Heap)        |
       |      (向上增长)         |
       |                         |
       |-------------------------|
       |        BSS 段           | (未初始化全局/静态变量)
       |-------------------------|
       |        数据段           | (已初始化全局/静态变量)
       |-------------------------|
       |        代码段           | (只读，可执行指令)
低地址 --------------------------
```

### 内存分配的方式

在 C 语言中，内存分配主要有以下几种方式：

1. **静态存储区分配 (Static Storage Allocation)：**
   - **分配时机：** 程序编译时或加载时确定。
   - **生命周期：** 整个程序运行期间。
   - **存放位置：** 数据段 (.data) 或 BSS 段 (.bss)。
   - **包括：** 全局变量、静态变量。
   - **特点：** 编译时已知大小，生命周期长，但内存一旦分配，在程序结束前不会释放。
2. **栈上分配 (Stack Allocation)：**
   - **分配时机：** 函数被调用时。
   - **生命周期：** 对应函数执行期间，函数返回后自动释放。
   - **存放位置：** 栈区。
   - **包括：** 局部变量、函数参数。
   - **特点：** 自动管理，效率高，但空间有限，且变量生命周期短。
3. **堆上分配 (Heap Allocation / Dynamic Memory Allocation)：**
   - **分配时机：** 程序运行时，程序员通过函数显式请求。
   - **生命周期：** 从分配到程序员显式释放 (`free()`) 或程序结束。
   - **存放位置：** 堆区。
   - **包括：** 通过 `malloc()`, `calloc()`, `realloc()` 等函数分配的内存。
   - **特点：** 灵活，可以分配任意大小的内存，生命周期由程序员控制。但需要手动管理，容易出现内存泄漏、重复释放、野指针等问题。

**总结：**

- **静态/全局变量**：存储在**数据段**或**BSS段**，生命周期与程序相同。
- **局部变量/函数参数**：存储在**栈区**，随着函数调用和返回而分配和释放。
- **动态分配的内存**：存储在**堆区**，需要程序员手动管理其生命周期。