# 嵌入式C语言教程——讨论堆栈

## 起手进程

​	我们讨论的堆栈需要从进程起手，因为在用户视图下，它是进程的私有物。当我们运行我们自己写的程序的时候，我们首先第一步就是起手找可执行文件的映像文件，第二步就是使用bash启动它（当然这是主程序，一般我们都是在shell中./文件跑起来代码，但是还存在其他方式等等，总而言之，你让OS知道你想启动一个程序了），现在经过一定的解释和配置，我们又进一步的把内容送到OS中，OS配置成为一个进程进入运行，执行你写的代码。

## 32位Linux的内存管理

​	首先笔者谨慎的认为《嵌入式C语言教程》中对遣词稍有不严谨，笔者建议还是多加指出我们在这里讨论的Linux是运行在32位平台上的。只有在这种情况下下面的陈述才是正确的。

​	无关乎32位还是64位，内存管理本身就是一个极其复杂的问题。需要操作系统，编译器和底层的CPU，虚拟/物理内存等相互的配合。当然我们先从简单的上层入手。对于一个死的，在硬盘上没有选中执行的程序，它的链接起始地址都是一样的。我的意思是说，只有在选中上之后，我们的地址等才会真正的确定下来，否则都是偏移地址（这样的好处很多，要知道操作系统现在可能跑着几百上千的进程，你硬耦合地址，那结果大概率是等到天荒地老上面都有进程跑）。

​	无论是32位还是64位，Linux都将我们的地址空间划分为两个部分。64位限制比较小（虚拟地址用都用不完），32位则是默认按照3：1的方式进行划分（3是用户，1是内核）。我们在程序层次都是使用的虚拟地址。我们的虚拟地址经过页表转换后拿到物理地址之后采取真正的DRAM序列阵后者是其他能存东西的地方拿到数据。

## 栈

​	内存中的栈（Stack）是计算机系统中一个重要的数据结构，它用于管理程序执行过程中函数调用、局部变量、函数参数等信息的存储。栈具有先进后出（Last In, First Out, LIFO）的特点，即最新入栈的数据最先被取出。栈广泛应用于程序运行中的函数调用、递归操作和表达式计算等场景。

​	栈的工作原理可以通过对程序执行过程中的函数调用过程来理解。当程序执行到一个函数时，系统会为该函数分配一定的内存空间，这块内存空间被称为栈帧（Stack Frame）。栈帧中存储了函数的局部变量、参数、返回地址等信息。每次函数调用时，新的栈帧会被压入栈顶，执行完毕后，栈帧被弹出，控制权返回到调用函数的位置。由于栈的操作符合后进先出的原则，因此每次函数调用时，最新的栈帧位于栈顶，返回时栈帧被弹出，恢复到之前的状态。

​	这样说太干了，看个demo:

```
#include <stdio.h>

void foo(int x) {
    int y = x + 5;
    printf("y = %d\n", y);
}

int main() {
    int a = 10;
    foo(a);
    return 0;
}

```

​	去除无关代码后arm汇编如下：

```
.global main

main:
    PUSH {LR}               // 保存返回地址
    MOV R0, #10             // 将参数 a = 10 存入寄存器 R0
    BL foo                   // 调用 foo 函数
    MOV R0, #0              // 返回值 0
    MOV R7, #1              // 系统调用退出
    SVC #0                  // 执行退出

foo:
    PUSH {LR}               // 保存返回地址
    PUSH {R0}               // 保存参数 x
    ADD R0, R0, #5          // 计算 y = x + 5
    MOV R1, R0              // 将 y 存入 R1
    BL printf               // 调用 printf
    POP {R0}                // 恢复参数 x
    POP {LR}                // 恢复返回地址
    BX LR                   // 返回到 main

```

在程序开始时，栈是空的，栈指针（`SP`）指向栈的顶端。

```
栈 (SP)
--------
|      |
| 空   |
|      |
--------
```

#### `main` 调用 `foo`

1. `main` 执行 `PUSH {LR}`，将返回地址压入栈中。
2. `MOV R0, #10`，将参数传递给 `foo`。
3. `BL foo`，跳转到 `foo`，此时 `LR` 保存的是 `main` 返回地址。

栈的变化如下：

```
栈 (SP)
--------
|      |   <- SP
| LR   | <- 保存的返回地址 (main 下一条指令地址)
--------
```

#### 进入 `foo` 函数

在 `foo` 函数中：

1. `PUSH {LR}`：将 `foo` 的返回地址压入栈中。
2. `PUSH {R0}`：将 `foo` 的参数 `x`（10）压入栈中。

栈的变化如下：

```
栈 (SP)
--------
|      |   <- SP
| R0   | <- 参数 x (10)
| LR   | <- 返回地址 (main 返回地址)
--------
```

#### 在 `foo` 中计算并调用 `printf`

1. `ADD R0, R0, #5`：计算 `y = x + 5`，`R0` 变成 15。
2. `MOV R1, R0`：将计算结果存入 `R1`，为 `printf` 准备参数。
3. `BL printf`：调用 `printf` 函数，`printf` 函数的栈使用略复杂，但我们在这里只是简单假设调用 `printf`。

栈状态不变，继续保持如下：

```
栈 (SP)
--------
|      |   <- SP
| R0   | <- 参数 x (10)
| LR   | <- 返回地址 (main 返回地址)
--------
```

#### `foo` 函数返回

1. `POP {R0}`：恢复 `foo` 的参数 `x`（10）。
2. `POP {LR}`：恢复 `main` 返回地址（`LR`），准备从 `foo` 返回。
3. `BX LR`：返回到 `main`。

栈的变化如下：

```
栈 (SP)
--------
|      |   <- SP
| 空   |   <- 栈为空，栈指针恢复到初始位置
--------
```

#### `main` 继续执行

1. `MOV R0, #0`：设置返回值 0。
2. `MOV R7, #1` 和 `SVC #0`：调用系统退出。

栈已经完全清空，程序结束。

#### 完整栈变化图

```
步骤1: 初始状态 (空栈)
栈 (SP)
--------
|      |
| 空   |
|      |
--------

步骤2: `main` 调用 `foo`，保存返回地址
栈 (SP)
--------
|      |
| LR   | <- `main` 返回地址
--------
 
步骤3: 进入 `foo`，保存 `foo` 返回地址和参数
栈 (SP)
--------
|      |
| R0   | <- 参数 x (10)
| LR   | <- `main` 返回地址
--------

步骤4: `foo` 执行完毕，栈内容恢复
栈 (SP)
--------
|      |
| 空   |
--------
```

​	栈的内存分配是由操作系统和编译器共同管理的。通常情况下，栈的大小是固定的，操作系统在程序加载时为其分配一块预定的内存区域。栈的增长方向通常是向低地址增长，即栈指针（Stack Pointer）会指向栈的顶部，每次入栈时，栈指针会向低地址移动，出栈时，栈指针则向高地址移动。栈的大小受限于操作系统和硬件架构，因此在程序执行时，栈空间的使用不能超过系统预设的最大值，否则会发生栈溢出（Stack Overflow），导致程序崩溃或异常终止。

​	**栈的一个重要特点是它能够高效地分配和回收内存。**由于栈内存的管理是自动的，不需要程序员手动管理内存的分配和释放，这使得栈成为函数调用和局部变量存储的理想选择。在栈上分配内存的操作通常比在堆上分配内存更加高效，因为栈只需移动栈指针，而堆则涉及到复杂的内存管理操作。

​	栈的另一个重要用途是在函数的参数传递中。当一个函数被调用时，参数通常是通过栈传递的。函数参数被压入栈中，在函数调用完成后，栈空间会被自动释放。这种传递方式的好处是简单且高效，特别是在处理基本数据类型时。然而，对于较大的数据结构（如大数组、结构体等），栈传递可能会导致性能瓶颈，因为数据必须被完整地复制到栈上。在这种情况下，可以考虑使用指针或引用来避免不必要的数据复制。

## 堆

​	内存中的堆（Heap）是计算机系统中一个重要的内存区域，用于动态分配内存。与栈不同，堆内存的分配和回收由程序员或操作系统来管理，堆的大小通常是由操作系统决定的，并且它的分配方式比栈更加灵活。堆内存通常用于存储在程序运行时动态创建的数据结构，如对象、数组等，而这些数据结构的生命周期无法在编译时确定。

​	在Linux中，堆的管理由操作系统的内存管理机制负责，程序员可以通过特定的内存分配函数（如 C 语言中的 `malloc` 和 `free`）手动进行内存的分配和释放。

堆内存的分配是通过操作系统的内存管理模块进行的。当程序请求分配内存时，操作系统会在堆区寻找足够大的空闲内存块，并返回该内存块的地址。由于堆内存的分配不是连续的，操作系统可能会在堆区的不同位置找到可用的空间，这就意味着堆内存的管理较为复杂。

​	堆的内存分配通常是非连续的，这样可以避免内存碎片化的问题。堆内存的管理有很多种方式，其中最常见的两种方法是**链表法**和**堆栈法**。链表法通过一个链表来记录每一块内存的状态（如是否被使用），每次分配或释放内存时都会更新链表。而堆栈法则通过使用一个栈结构来分配和释放内存块，虽然这种方式效率较高，但在一些复杂场景下可能会引起性能问题。

​	堆内存的一个显著特点是它的分配和回收是由程序员显式控制的，而不像栈那样由系统自动管理。程序员可以根据需要通过内存分配函数请求一块指定大小的内存，并在不再需要时通过内存释放函数释放这块内存。动态内存的分配允许程序灵活地管理内存，尤其适用于那些在编译时无法预知大小的数据结构。常见的应用场景包括：

1. 动态数组：程序在运行时可能需要处理大小不固定的数据集，例如从文件中读取不确定数量的数据，此时可以通过堆内存分配一个足够大的数组。
2. 链表、树、图等数据结构：这些数据结构通常需要在程序运行时动态创建和销毁节点，堆内存提供了灵活的空间来支持这些操作。
3. 动态对象：在面向对象编程中，对象的实例通常在堆上创建，特别是在程序运行时需要创建大量对象时，堆内存的动态管理能够有效地支持这种需求。

​	虽然堆内存的灵活性和可扩展性带来了许多好处，但它也存在一些问题和挑战。首先，由于堆内存的分配和释放是手动管理的，程序员必须非常小心，避免发生内存泄漏（memory leak）和内存访问错误。内存泄漏是指程序在不再使用某块内存时没有正确释放，导致这块内存始终无法被回收，从而占用系统资源，可能引发性能下降甚至崩溃。内存访问错误则是指程序访问了已经释放或未分配的内存，通常会导致程序崩溃或未定义行为。

​	另外，堆内存的生命周期由程序员控制，通常意味着它们的释放时间较不确定。这种不确定性可能导致内存碎片化问题，即在堆内存中分配和释放内存块时，堆内存空间可能会变得零散，导致新的内存请求无法获得足够大的连续内存块。因此，内存碎片化问题是堆内存管理中需要关注的一个重要问题。为了减少内存碎片化，现代操作系统和内存管理系统采用了多种技术，如内存合并和垃圾回收等。

## mmap：申请大片内存

`mmap` 是一个在操作系统中非常重要的系统调用，用于将文件或设备映射到进程的虚拟地址空间，从而使进程能够像访问内存一样访问文件内容。通过 `mmap`，程序可以在内存中直接操作文件，而无需显式地进行读写操作，提升了性能，尤其是在处理大文件或进行高效内存映射时。

1. **高效的文件访问**：由于文件直接映射到内存，程序可以像访问内存一样访问文件，避免了频繁的磁盘 I/O 操作。
2. **共享内存**：通过 `mmap`，多个进程可以共享同一段内存区域，通常用于进程间通信（IPC）。
3. **懒加载**：`mmap` 映射的文件内容是按需加载的，只有在实际访问时才会读取磁盘文件内容，因此节省了内存和时间。

在类 Unix 系统（如 Linux、macOS）中，`mmap` 的原型通常如下：

```
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```

各参数的含义如下：

- `addr`：建议的映射起始地址。通常设置为 `NULL`，让操作系统决定映射的地址。

- `length`：映射的字节数，表示映射区域的大小。

- ```
  prot
  ```

  ：映射区域的保护标志，控制该内存区域的访问权限。常用的值有：

  - `PROT_READ`：页面可读取。
  - `PROT_WRITE`：页面可写入。
  - `PROT_EXEC`：页面可执行。
  - `PROT_NONE`：不允许任何操作。

- ```
  flags
  ```

  ：映射的选项，控制映射的行为。常用的标志有：

  - `MAP_SHARED`：映射区域是共享的，修改映射区域会反映到文件中，适合多个进程共享。
  - `MAP_PRIVATE`：映射区域是私有的，修改映射区域不会影响文件内容。
  - `MAP_ANONYMOUS`：映射不与任何文件相关联，常用于分配匿名内存。此时 `fd` 和 `offset` 应设为 `-1`。

- `fd`：要映射的文件描述符。如果使用 `MAP_ANONYMOUS`，此参数无效。

- `offset`：文件映射的起始位置，必须是页大小的倍数，通常为 0。

返回值：

- 成功时，返回映射区域的起始地址。
- 失败时，返回 `MAP_FAILED`（通常是 `(void*)-1`），并设置 `errno` 以指示错误。

#### mmap 的使用场景

1. **大文件的映射**

​	当文件太大，无法一次性加载到内存时，`mmap` 可以将文件的一部分映射到内存中，只在需要时加载数据，从而有效避免了读取大文件时的性能瓶颈。例如，操作系统的分页机制会将文件内容按页加载，只有当程序访问某个页面时，这部分内容才会被加载到内存。

2. **共享内存**

​	多个进程可以通过 `mmap` 映射同一文件或共享的内存区域，以实现进程间通信（IPC）。这种方式比传统的管道或消息队列等 IPC 机制更高效，尤其在需要共享大量数据时。

3. **内存映射 I/O（MMIO）**

​	`mmap` 还可以用于设备驱动程序中，映射硬件寄存器或设备内存到进程的虚拟地址空间。通过这种方式，程序可以直接操作硬件而不需要通过传统的 I/O 操作。

4. **避免显式读写**

​	在某些场景下，程序可以通过 `mmap` 将文件映射到内存，直接操作内存区域，而无需调用传统的文件读写接口。对于大文件或需要频繁访问的文件，这种方式可以显著提升性能。

#### 例子

​	看一个简单的例子：

```
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

int main() {
    const char *filename = "example.txt";
    
    // 打开文件
    int fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }
    
    // 获取文件大小
    off_t file_size = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);  // 重置文件指针

    // 映射文件到内存
    char *mapped = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (mapped == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    // 打印映射的内容
    printf("File content:\n%s\n", mapped);

    // 解除映射
    if (munmap(mapped, file_size) == -1) {
        perror("munmap");
    }

    // 关闭文件
    close(fd);
    
    return 0;
}
```

在这个例子中，首先打开一个文件，并使用 `lseek` 获取文件的大小。然后通过 `mmap` 将文件映射到内存，映射区域是只读的，并且使用 `MAP_PRIVATE` 标志，这意味着对映射区域的任何修改不会反映到文件中。映射完成后，我们可以直接操作内存，读取文件内容。最后，通过 `munmap` 解除映射，关闭文件。

#### 优点：

- **高效的内存访问**：通过 `mmap`，程序可以像访问内存一样高效地访问文件，减少了传统 I/O 操作的开销。
- **懒加载**：`mmap` 采用懒加载机制，只有在需要时才加载文件内容，节省内存和提高性能。
- **支持大文件**：`mmap` 使得操作系统能够处理大于物理内存的文件，适用于处理海量数据。

#### 缺点：

- **复杂的错误处理**：如果映射失败，程序必须处理各种可能的错误（如内存不足、文件不可访问等）。
- **内存碎片**：由于内存是按页管理的，可能会导致内存碎片化。
- **同步问题**：对于共享内存映射，必须小心同步问题，多个进程对同一内存区域的并发访问可能导致数据损坏。