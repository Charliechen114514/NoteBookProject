# Python设计模式速通

## 先导

​	我们开始设计模式之前，首先第一步就是搞清楚一些概念：

### 对象的事情

我们可以通过以下几点来描述对象。

- 它们表示所开发的应用程序内的实体。
- 实体之间可以通过交互来解决现实世界的问题。

例如,Person是实体,而Car也是实体。Person可以驾驶Car,从一个地方开到另一个地方。这个意思就是说，我们对现实世界的对象进行建模，挪到我们的程序设计当中。

### 类的事情

​	对象也有种类之分，不是吗？我们说对象Tom是一个Person，Person就是一个类了

- 类可以定义对象的属性和行为。属性是数据成员,行为由成员函数表示。
- 类包含了构造函数,这些函数的作用是为对象提供初始状态。
- 类就像模板一样,非常易于重复使用。

### 方法

​	实际上就是在描述对象的行为，它允许我们对其他对象：或者是自己的属性，或者是其他传入对象的属性进行操作。

### 面对对象程序设计的几个基本要点

#### 封装

封装的主要特点如下所示。

- 对象的行为对于外部世界来说是不可见的,或者说对象的状态信息是私密的。
- 客户端不能通过直接操作来改变对象的内部状态。相反,客户端需要通过发送消息来请求对象改变其内部状态。对象可以根据请求的类型,通过特定的成员函数(例如get和set改变它们的内部状态,以做出相应的响应。
- 在Python中,封装(数据和方法的隐藏)的概念不是隐式的,因为它没有提供封装所需的关键字,诸如public、private和protected(在诸如C+H+或Java之类的语言中,都提供了这些关键字)。当然,如果在变量或函数名前面加上前缀__,就可以将其可访问性变为私有。

#### 多态

多态的主要特征如下所示。

- 多态有两种类型。

  - 对象根据输入参数提供方法的不同实现。

  - 不同类型的对象可以使用相同的接口。

- 对于Python来说,多态是该语言的内置功能。例如,操作符“+“可以应用于两个整数以进行加法运算,也可以应用于字符串来连接它们。

#### 继承

- 继承将会使得我们的子类拥有父类的功能
- 继承也可以认为时重新定义基类的方法
- 可以允许我们对现实世界采取层次化的建模

#### 抽象

​	这个步骤很为关键：那就是将复杂的交互整理为一些接口的交互。这样我们就将复杂的实现转化为若干接口的沟通——这样我们就简化了建模的难度。

#### 组合

​	现在广泛的认为：组合可以更好的抽象结构：字如其名，我们将若干对象组合在一起构成更加复杂的对象。

### 面对对象程序设计的准则

#### 开放/封闭原则

​	类或对象及其方法对于扩展来说,应该是开放的,但是对于修改来说,应该是封闭的。简单地说,这意味着当你开发软件应用的时候,一定确保以通用的方式来编写类或模块,以便每当需要扩展类或对象行为的时候不必修改类本身。相反,类的简单扩展将有助于建立新的行为。

​	例如,开放/封闭原则能够在下列情形中表现得淋漓尽致:为了实现所需行为,用户必须通过扩展抽象基类来创建类的实现,而不是通过修改抽象类。

​	本设计原则的优点如下。1.现有的类不会被修改,因此退化的可能性较小。2.它还有助于保持以前代码的向后兼容性。

#### 控制反转原则

​	高层级的模块不应该依赖于低层级的模块,它们应该都依赖于抽象。细节应该依赖于抽豪,而不是抽象依赖于细节。该原则建议任何两个模块都不应以紧密方式相互依赖。事实上,基本模块和从属模块应当在它们之间提供一个抽象层来糊合。这个原则还建议,类的细节应该描绘抽象。在栋些情况下,这种观念会反转,也就是实现细节本身决定了抽豪,这种情况是应该避免的。

​	它可以消弱了模块间的紧耦合,因此消除了系统中的复杂性/刚性。由于在依赖模块之间有一个明确的抽象层(由钩子或参数提供),因此便于通过更好的方式处理模块之间的依赖关系。

#### 接口隔离原则

​	客户端不应该依赖于它们不需要使用的接口。

​	接口隔离原则的意思就是,软件开发人员应该仔细地处理接口。例如,它提醒开发人员/架构师开发的方法要与特定功能紧密相关。如果存在与接口无关的方法,那么依赖于该接口的类就必须实现它,实际上这是毫无必要的。

​	例如,一个Pizza接口不应该提供名为add_chicken()的方法。基于Pizza接口的VegPizza类不应该强制实现该方法。

​	它强制开发人员编写“瘦身型“接口,并使方法与接口紧密相关。防止向接口中随意添加方法。

#### 单一职责原则

​	类的职责单一,引起类变化的原因单一。这个原则是说,当我们开发类时,它应该为特定的功能服务。如果一个类实现了两个功能,那么最好将它们分开。也就是说,功能才是改变的理由。例如,一个类可以因为所需行为的变化而进行修改,但是如果一个类由于两个因素(基本上是两个功能的改变)而改变,那么该类就应该进行相应的分割。

本设计原则的优点如下所示。

- 每当一个功能发生变化时,除了特定的类需要改变外,其他类无需变动。
- 此外,如果一个类有多种功能,那么依赖它的类必定会由于多种原因而经历多次修改,这是应该避免的。

#### 替换原则规定

派生类必须能够完全取代基类。这个原则很简单,当应用程序开发人员编写派生类时,该原则的含义就是他们应该扩展基类。此外,它还建议派生类应该尽可能对基类封闭,以至于派生类本身可以替换基类,而无需修改任何代码。

## 三大模式

​	我们将一大堆设计模式分为三个基本的大类：

1. 创建型模式
2. 结构型模式
3. 行为型模式

### 创建型模式

​	对象的运行机制基于对象的创建方式，这样的模式就是将对象的创建细节进行隔离，让我们的代码跟创建的类型时无关的（创建如何被收拢到了对象内部）

### 结构型模式

​	这个模式致力于设计使用组合得到更为强大的对象和类，主要是用于理清楚类和对象之间的关系，换而言之，这一模式使用到的技术更多是继承和组合。

### 行为型模式

​	关注对象之间的交互和响应，同时追求对象的松耦合！



# 单例设计模式

很简单：整个类有且只有一个对象，所有外部对之都是引用。比如说日志记录，比如说数据库操作，打印机后台处理程序等。
使用这个设计模式等意图如下：

- 确保 类有且只有一个对象被创建
- 为对象提供一个访问点让程序访问
- 控制共享资源的并发访问

现在，我们控制了对象的全局唯一性：意味着我们也可以做懒汉初始化：

### 工厂模式
最常用的设计模式之一：将类的创建解藕合了，他不需要知道类如何具体如何被创建，只需要知道调用接口就可以返回对象，同时对于对象继承树上不需要更改代码。同时还控制了对象的获取方式（工厂可以返回现用对象）

工厂模式有三个变体：简单工厂模式（只是创建对象），工厂方法模式（依赖接口创建）和抽象工厂模式（依赖子类创建）

### 门面模式
门面模式实际上是一种掩盖屎山的有效方式：我们将内部庞大系统的工作原理和步骤封装起来，换成简单的统一接口。客户按照门面接口沟通而不是直接调用子系统。

### 代理模式
代理就是一个中介：他是请求方和提供方的中介，实际上就是对请求的进一步封装。她可以让更简单的方式访问一个复杂系统，保证了对象的安全性。
代理分为虚拟代理（面对高消耗的资源采取懒式记载加载），远程代理（对于远程对象的本地表达），保护代理（需要安全访问的代理方式）和智能代理（封装请求添加补全）

### 观察者模式
对象维护依赖列表，我们将会监控被观察对象的变化，将事件传递给通知器，通知器采取进一步行动传播到系统。

### 命令模式
实际上是对功能调用的一种封装：一般而言命令模式需要传递这些信息：方法名称，拥有这个方法的对象以及伴随参数。我们会将各种各样的请求封装为Command，它需要了解Receiver对象的情况。而且将请求对象化后就可以四处传递，像对象一样控制请求。

### 模版方法模式
可以按照模版一般的流程封装算法，比如说当我们的处理一个复杂处理的对象的时候可用这个方法来进行操作。这个操作指代的是那些名称相同的不同实际处理的一系列流程——子类复用父类的接口进行实践。

### MVC模式
是实现用户界面的常见设计模式：用户跟View界面打交道：控制器将会从视图转发操作给模型，实现主题的变换在将变化操作返回给View控制器在这里充当中介胶水，View是前端， Model是后端！



