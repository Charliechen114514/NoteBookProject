# Power && Performance

## Chapter I: 早期Intel架构

​	我们聊聊8086，这个是Intel首次采用x86架构设计的CPU。这个东西非常具备划时代的意义。

​	当你启动一个处理器：即对处理器做复位操作的时候，芯片将会开启全局的重启。他会赋予我们的处理器完全全新的，可知的状态（既过去如何完全与现在没有关系）。对于32位芯片。我们的系统需要首先运行在16位实地址模式，下面，更新CR0寄存器的Page Protection位为1进入保护模式。我们的Intel系列芯片将这40多年的发展压缩到了这一眨眼的时间完成（我的另一意思就是：现在所有的Intel的芯片都会兼容之前的芯片！也就是说，现在你的电脑仍然可以run 1980s的程序，只要都是Intel的芯片）

### Intel 8086

​	x86实际上是一个系列，他包含了8086, 80186, ... , 80386等芯片，他们都是86架构发展线的产品。8086这个芯片具备划时代的意义。我们就拿这个来谈。

​	他有三大设计准则：

- 各个特化的构件的使用是解耦合的（也就是说8086是提供最小运行集的，其他的功能需要按照级联或者是外设的方式集成进来）
- 对于接下来产生的86系列芯片都要兼容——保证在快速迭代的产品中旧有的程序还会被支持
- 层次化的总线设置，支持简单的，或者是复杂的数据流传递。

​	特化的部件分为两个十分清晰的大部分：执行单元（EU）与总线接口单元（BIU）。EU就是中心的执行单元：包含了内部的处理器和所使用到的寄存器。EU是没有办法访问到内存和外设，他需要BIU的辅助对外沟通。

### 系统状态

​	我们下面走马观花一下常见的存储体系

​	三大层次如下所示：处理器的寄存器组 + RAM + 硬存。依次从高向下，我们的沟通速度依次向下递减，成本也依次向下递减。我们的处理器的寄存器的处理速度几乎可以说是跟处理器自身一样的快，意味着如果我们的数据是存储在处理器寄存器组的话，压根就不花费时间就可以取到数据。

### 地址空间

​	8086的确将内存分成两个部分：一个是处理器的内存地址空间，还有一个就是外设的映射部分。20位的地址线就是在说明我们的地址寻址空间为 2 * 20 bit = 1 MB. 然后对于外设则是只接受64KB大小的映射。（16位）

​	 在8086中，我们的地址是分段的——指代的是一个逻辑段地址。这个地址很有意思：他是由一个段地址 + 偏移量组合而成的。对于8086还没有虚拟模式这个概念，我们所使用到的地址都是实际的物理地址。其转化非常的简单：

```
Addr = Segs << 1 + Offset
```

​	在8086中有四种段地址。这里一一枚举：

- CS段：这里是代码段，在那个时代，我们的Code Base Address就是在这里取出的
- SS段：写程序的都知道，我们的堆栈由（E/R）SP来进行维护，那么SP如何维护一个巨大的地址空间呢？基址就放在这里的。
- DS段：数据段。也就是我们程序的数据段基址放在这里。到时候找数据的时候很方便找到。
- ES段：额外的数据段，说白了就是一个DS不够用，再加个ES

​	当然，我们还必须介绍其他一些CPU外围的寄存器先：一共是七个通用寄存器和两个状态寄存器。 通用寄存器分为两类。AX、 BX、CX 和 DX 四个寄存器被归类为数据寄存器。这些数据寄存器可以作为完整的 16 位寄存器（用 X 后缀表示）、完整的 16 位寄存器的低字节（用 L 后缀表示）或 16 位寄存器的高字节（用 H 后缀表示）进行访问。例如，AX 将访问完整的 16 位寄存器，而 AL 和 AH 将分别访问寄存器的低字节和高字节。 

​	寄存器的第二种分类是指针/索引寄存器。这包括以下四个寄存器：SP、BP、SI 和 DI，SP 寄存器（堆栈指针）保留用作指向堆栈顶部的指针。SI 和 DI 寄存器通常分别隐式用作源指针和目标指针。 与数据寄存器不同，指针/索引寄存器只能作为完整的 16 位寄存器进行访问。 正如这种分类所表明的那样，通用寄存器附带一些针对其预期用途的指导。这种指导反映在具有隐式操作数的指令形式中。具有隐式操作数的指令（即，假定为某个寄存器的操作数，因此不需要对该操作数进行编码）允许对常见用途进行较短的编码。为方便起见，具有隐式形式的指令通常也有显式形式，这需要更多的字节来编码

​	当然下面我们进一步查看一下各个寄存器的推介用法：

- AX Accumulator
- BX Data (relative to DS)
- CX Loop counter
- DX Data
- SI Source pointer (relative to DS)
- DI Destination pointer (relative to ES)
- SP Stack pointer (relative to SS)
- BP Base pointer of stack frame (relative to SS)

​	一旦熟悉了各种寄存器含义，程序员将能够更快地推断出汇编的含义（假设它符合指南）。这在某种程度上类似于变量名称如何帮助程序员推理其内容。需要注意的是，这些只是建议，而不是规则。

​	此外，还有两个状态寄存器，即指令指针和标志寄存器。指令指针 IP 也经常被称为程序计数器。该寄存器包含下一个要执行的指令的内存地址。在引入 64 位模式之前，程序员无法直接访问指令指针，也就是说，无法像访问其他通用寄存器那样访问它。尽管如此，指令指针是间接访问的。虽然不能通过 MOV 指令修改指令指针，但可以通过任何改变程序流的指令（例如 CALL 或 JMP 指令）修改它。

​	利用 x86 处理函数调用的方式，也可以读取指令指针的内容。从一个函数转移到另一个函数是通过 CALL 和 RET 指令进行的。CALL 指令保留指令指针的当前值，将其推送到堆栈以支持嵌套函数调用，然后将新地址加载到指令指针中，作为指令的操作数。堆栈上的这个值称为返回地址。每当函数执行完毕时，RET 指令就会从堆栈中弹出返回地址并将其恢复到指令指针中，从而将控制权转移回发起函数调用的函数。利用这一点，程序员可以创建一个特殊的 thunk 函数，该函数只需将返回值从堆栈中复制出来，将其加载到其中一个寄存器中，然后返回。例如，在编译第 12 章中讨论的位置无关代码 (PIC) 时，编译器将自动添加使用此技术获取指令指针的函数。这些函数通常称为 __x86.get _pc_thunk.bx()、__x86.get_pc_thunk.cx()、__x86.get_pc_thunk.dx() 等，具体取决于加载指令指针的寄存器。第二个状态寄存器，即 EFLAGS 寄存器，由 1 位状态和控制标志组成。这些位由各种指令（通常是算术或逻辑指令）设置，以发出某些条件的信号。然后可以检查这些条件标志以做出决定。有关每条指令修改的标志的列表。8086 在 EFLAGS 中定义了以下状态和控制位：

>零标志 (ZF) 如果指令结果为零，则设置该标志。
>符号标志 (SF) 如果指令结果为负，则设置该标志。
>溢出标志 (OF) 如果指令结果溢出，则设置该标志。
>奇偶校验标志 (PF) 如果结果设置了偶数位，则设置该标志。
>进位标志 (CF) 用于在执行带进位的算术的指令中存储进位位（用于实现扩展精度）。
>调整标志 (AF) 类似于进位标志。在 8086 文档中，这被称为辅助进位标志。
>方向标志 (DF) 对于自动增加或自动减少指针的指令，此标志选择执行哪一种。如果设置，则自动减少，否则自动增加。
>中断启用标志 (IF) 确定是否启用可屏蔽中断。
>陷阱标志 (TF) 如果设置，CPU 将以单步调试模式运行。
