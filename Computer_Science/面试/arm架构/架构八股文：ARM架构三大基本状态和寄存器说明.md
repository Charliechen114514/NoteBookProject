# 架构八股文：ARM架构三大基本状态和寄存器说明

## ARM / Thumb / Jazelle

​	这是ARM架构的三种经典状态，

####  **ARM 状态**

​	ARM状态下的指令都是32位长，**指令功能强大，寄存器操作灵活，因此性能比较高**，但是由于长度为32位，因此，代码尺寸较大，在一些存储比较极端的场景下，非常容易炸存储，这也就是我们为什么会在一些很极端的情况下请出来第二种模式。

#### Thumb 状态

​	Thumb 状态下的指令长度都是16位长，功能为 ARM 指令子集，代码尺寸更小，也就是解决存储非常即端的场景下的状态。

#### Jazelle 状态

- 用于加速 Java 字节码执行（执行 JVM Bytecode）
- 使用 `BXJ` 指令进入 Jazelle 模式
- 在某些 ARMv5 及其以后的处理器中支持

但是现在已经逐步的走向废弃了，这里就不再赘述了。

## 使用场景

- ARM状态的使用场景：操作系统内核、启动阶段、计算密集型任务等
- Thumb 状态的使用场景：代码存储空间极端受限的嵌入式系统

- ARM `->` Thumb：使用 `BX` 指令跳转到目标地址并设置 LSB（最低位）为 1
- Thumb `->` ARM：使用 `BX` 指令跳转到目标地址并设置 LSB（最低位）为 0

------

## 🌟 状态切换总结

| 来源状态 | 跳转指令 | LSB（地址最低位） | 目标状态 |
| -------- | -------- | ----------------- | -------- |
| ARM      | BX       | 0                 | ARM      |
| ARM      | BX       | 1                 | Thumb    |
| Thumb    | BX       | 0                 | ARM      |
| Thumb    | BX       | 1                 | Thumb    |
| 任意     | BXJ      | 特殊处理          | Jazelle  |

### 🔹 ARM vs Thumb 对比

| 对比项   | ARM 指令       | Thumb 指令     |
| -------- | -------------- | -------------- |
| 指令长度 | 32 位          | 16/32 位       |
| 代码密度 | 低             | 高             |
| 性能     | 高             | 略低           |
| 功能支持 | 全指令集       | 子集           |
| 应用场景 | 内核、性能敏感 | 小代码空间场景 |

------

### 🔹 如何判断当前状态？

可通过查看 **CPSR（Current Program Status Register）** 的 T 位（第 5 位）：

- T 位 = 0：ARM 状态
- T 位 = 1：Thumb 状态

## ARM 寄存器总览（ARMv7-A 架构为例）

ARM（AArch32）共有 **37 个物理寄存器**，包括：

| 类型           | 数量 | 说明                                                       |
| -------------- | ---- | ---------------------------------------------------------- |
| 通用寄存器     | 16   | R0 ~ R15（其中 R13 为 SP，R14 为 LR，R15 为 PC）           |
| 程序状态寄存器 | 2    | CPSR（Current Program Status Register）、SPSR（Saved PSR） |
| 模式私有寄存器 | 19   | 为不同模式（如 FIQ、IRQ、Supervisor）准备的 banked 寄存器  |

------

### ARM 通用寄存器详解

| 名称   | 功能说明                                  |
| ------ | ----------------------------------------- |
| R0-R12 | 通用寄存器，参数传递、运算等              |
| R13    | SP（Stack Pointer）栈指针                 |
| R14    | LR（Link Register）函数返回地址或中断返回 |
| R15    | PC（Program Counter）程序计数器           |

------

## CPSR/SPSR 状态寄存器

提示：**Saved Program Status Register**是CPSR的备份，**用于保存CPSR的状态，以便异常返回后恢复异常发生时的工作状态。**，也就是说，他是异常发生的备份寄存器。所以下面我们直接看CPSR就好了。

### 🔹 CPSR（Current Program Status Register）

| 位    | 名称   | 含义                        |
| ----- | ------ | --------------------------- |
| [31]  | N      | 负数标志                    |
| [30]  | Z      | 零标志                      |
| [29]  | C      | 进位标志                    |
| [28]  | V      | 溢出标志                    |
| [7]   | I      | IRQ 中断屏蔽位              |
| [6]   | F      | FIQ 中断屏蔽位              |
| [5]   | T      | 0 表示 ARM 状态，1 为 Thumb |
| [4:0] | M[4:0] | 模式位（User/SVC/IRQ 等）   |

------

## Banked Registers（模式切换相关）

ARM 支持多种处理器模式，每种模式下部分寄存器会“换银行”（banked）：

| 模式             | 专用寄存器                  |
| ---------------- | --------------------------- |
| FIQ 模式         | R8_fiq ~ R14_fiq, SPSR_fiq  |
| IRQ 模式         | R13_irq, R14_irq, SPSR_irq  |
| Supervisor 模式  | R13_svc, R14_svc, SPSR_svc  |
| Abort 模式       | R13_abt, R14_abt, SPSR_abt  |
| Undefined 模式   | R13_und, R14_und, SPSR_und  |
| System/User 模式 | 无私有寄存器（共用 R0-R14） |

------

## 快问快答

#### ARM 有哪些寄存器？

ARM（AArch32）总共提供 37 个物理寄存器，包括 R0 到 R15 共 16 个通用寄存器、一个 CPSR 当前程序状态寄存器，以及 20 个模式相关的 banked 寄存器。R13 是栈指针 SP，R14 是链接寄存器 LR，R15 是程序计数器 PC，状态寄存器 CPSR 用于记录标志位、中断屏蔽位和处理器模式等信息。

#### CPSR 有什么作用？

CPSR 是 ARM 中的当前程序状态寄存器，用于保存运算结果标志位（如 N/Z/C/V），中断屏蔽控制（I/F 位），当前处理器状态（T 位）和运行模式（M[4:0]）。其中 T=1 表示 Thumb 状态，T=0 表示 ARM 状态；M 位决定当前运行在 User、FIQ、IRQ、SVC 等模式中。

#### ARM 如何保存中断上下文？

在中断发生时，ARM 会自动将返回地址保存在 LR（链接寄存器）中，并将当前 CPSR 状态保存到 SPSR 寄存器中。由于不同中断模式（如 IRQ、FIQ）有独立的 LR 和 SPSR，因此上下文切换开销较小，利于中断嵌套与快速响应。

#### R13、R14、R15 的特殊用途？

R13是SP，也就是经典的栈指针，用于函数调用和中断处理的堆栈管理；R14 是 LR（链接寄存器），用于保存子程序返回地址或异常返回地址；R15 是 PC（程序计数器），用于控制程序的执行流。

#### ARM 中如何进行模式切换？不同模式下寄存器有什么区别？

模式切换由 CPSR 的 M[4:0] 位控制，不同模式具有独立的 banked 寄存器组，例如 FIQ 模式有 R8~R14 的私有副本，IRQ/SVC 等也有独立的 R13/R14 和 SPSR。这样可避免多模式下保存/恢复通用寄存器的额外开销，提高中断和异常处理效率。

