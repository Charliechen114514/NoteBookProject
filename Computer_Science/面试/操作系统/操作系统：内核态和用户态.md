# 操作系统：内核态和用户态

​	在笔者之前的《从0手搓一个操作系统》的系列文章中，就有涉及到操作系统的内核态和用户态的区别。这里，我们专门针对这个专题，重新的讨论一次内核态和用户态，作为一个笔记的整理部分。

## 啥是内核态，啥是用户态？

#### 用户态

​	当我们的操作系统运行的是用户程序的时候，我们需要提供一个对于我们计算机本身安全的环境，这个时候，我们的机器/操作系统就处于用户态的运行程序。或者说，在这个时候，我们的计算机十分的窝囊，他干什么都需要向我们的操作系统老大哥申请资源（内存啊，磁盘啊其他硬件啊等等）。我们所有跟计算机的交互都必须通过操作系统给定的接口（在我们的编程中走的是库函数的接口，库函数封装了操作系统的接口，让我们使用起来更加的封边）

> 一句话：普通应用程序运行的状态，权限受限。在此模式下，代码不能直接访问硬件或敏感内存，只能通过操作系统的接口（系统调用）请求服务。若程序崩溃，通常不会影响整个系统。

#### 内核态

​	运行操作系统自身的代码逻辑的时候，我们的计算机出于内核态，这个时候，我们可能是在处理调度计算机资源本身的状态。比如说，我们的应用程序发起系统调用请求服务的时候，这个时候我们的计算机就会从用户态转化到内核态。在这里，我们的操作系统是具备完全的权限，可以直接操作CPU，内存，硬件（驱动程序直接打招呼），这里要是出错了，Windows我们熟悉的就是蓝屏，Linux则是经典的Kernel Panic

> 操作系统内核运行的状态，拥有**完全权限**，可直接操作CPU、内存、设备等硬件资源。内核代码需要高度可靠，一旦出错可能导致系统崩溃（如蓝屏、内核恐慌）。

## 只有内核态不好嘛？

​	有人会觉得奇怪，这不多此一举嘛？为什么要有内核态呢？如果你仔细读读上面的定义，你会给出第一个答案：

#### 安全性

​	我们知道，用户程序都是相对于操作系统而言的第三方编写的，谁也不知道这些程序要是直接操作硬件会带来怎么样的结果，不管是不是故意的，我相信要是用户程序完全取得了你的硬件级别的计算机的使用权，晚上不大可能睡得好觉。换而言之，我们给我们的用户进程上了把锁，让他只能干好他自己的事情，让他只能做自己的事情，相互之间除非明确的需要IPC以外，坚决不会互相干扰。

​	请求的资源，必须经过操作系统严格的审查。请求的资源是否合法？请求的资源是否可用？这些都是辅助我们的用户程序有序的进行运行的。

#### 稳定性

​	内核的代码是进行了专门的测试，保证我们的操作系统几乎不会出现任何的bug可以正常的进行运行，同时，对于我们服务的对象用户程序要是崩溃了，内核可回收其资源，系统仍能运行。

#### 硬件抽象

​	内核建立对硬件细节（如不同显卡型号）的统一抽象。内核通过设备驱动提供统一接口，用户态通过系统调用（如`read()`、`write()`）访问硬件。这样我们编写程序就可以完全不需要关心底层的细节，直接进行梭哈。

#### 权限分级

CPU支持多特权级（如x86的Ring 0~3）。内核态运行在最高特权级（Ring 0），用户态运行在低特权级（Ring 3）。尝试执行特权指令时会触发异常（如General Protection Fault）。

## 内核态和用户态的转化

​	那么，我们很容易想到的问题是，中间的转化可能会是如何触发的呢？答案是，我们只有在需要跟操作系统打交道的时候，才会触发这个转化。所以，我们就把问题转化成，何时我们的计算机跟操作系统打交道呢？

### 请求系统服务：系统调用（System Call）

​	这个时候，我们需要请求系统服务，就需要发起系统调用，举个例子：调用 `open()` 打开文件、`fork()` 创建进程、`write()` 写入数据等等。

​	一般而言，对于X86，我们会把系统调用号直接放到EAX当中，然后执行`int 0x80`（128号系统中断），在那里的ISR中，我们会取出来这个系统调用号调用服务表对应偏移的函数指针，也就是处理句柄处理我们的请求。执行结束后，我们会讲这个结果返回回来，这个时候程序继续运行。

​	那显然，这个是我们主动请求操作系统的，同时也是同步的，我们必须等到操作系统完成他的工作后才会返回结果。

### 硬件通知操作系统做事情

​	我们的外部设备需要内核处理硬件事件（如键盘输入、定时器到期），这个时候，我们的硬件会通过中断芯片发起请求操作系统的中断处理事件，这个时候，我们实际上会触发CPU的中断，这个时候，CPU就会暂停当前执行（无论用户态还是内核态），保存上下文，切换到内核态（这个是我们的CPU自己做的），我们这个时候就会处理对应中断号的程序，处理完成后，恢复被中断的进程上下文，切换回原状态（用户态或内核态）。

​	这个时候，我们发现这种处理是被动的（我们也不知道硬件要如何通知），更加是异步的（可能发生在任何指令执行期间）

### 存在异常需要处理

​	这个时候是程序执行时发生错误或特殊事件。比如说，我们的

- 逻辑运算出现问题：除零错误
- 页缺失（Page Fault），这个笔者后面单开一个好好说
- 我们执行了在给定的权限下不恰当的非法指令（如用户态执行 `cli`）。

​	处理上，则是CPU检测到自己或者是外部反馈的异常，自动的切换到内核态进行处理，这个时候我们就会调用异常处理程序。我们会尝试从异常中回复回来。

- **可恢复异常**（如页缺失）：那些可以试着恢复的异常。内核加载缺失页后，恢复程序执行。
- **不可恢复异常**（如非法访问）：那些不可以恢复的异常。终止进程（如段错误 `Segmentation Fault`）。

###  进程上下文切换

​	这个笔者认为实际上需要归类到硬件中断的部分，搓过操作系统的朋友都知道，这个是定时器的硬件驱动的，当我们的定时器中断触发，CPU 进入内核态。我们将当前的进程状态压入我们的task_struct之后，根据调度类选择下一个进程。选择到了下一个进程之后，我们从中取出新进程的上下文，可能切换回用户态（若新进程是用户程序）。

## 这种内核态和用户态的切换的代价是什么（等价问题：为什么频繁切换会影响性能）

​	真好理解，我们的上下文是不一样的，意味着每一次我们的切换操作。都有：

- 保存用户态寄存器状态。
- 切换至内核态，执行内核代码。
- 恢复用户态上下文。

​	实际上是保存和恢复上下文带来的开销，同时还有：

- **缓存失效（Cache Pollution）。**系统使用的缓存和用户进程使用的缓存不一致。
- 模式切换的指令周期。
- 内核与用户态数据拷贝（如系统调用参数）。

| **切换时机** | **触发方式**   | **特点**           |
| :----------- | :------------- | :----------------- |
| 系统调用     | 程序主动请求   | 同步、可控         |
| 硬件中断     | 外部设备触发   | 异步、不可预测     |
| 异常         | CPU 检测到错误 | 同步、可能终止进程 |
| 进程调度     | 内核强制切换   | 依赖定时器中断     |