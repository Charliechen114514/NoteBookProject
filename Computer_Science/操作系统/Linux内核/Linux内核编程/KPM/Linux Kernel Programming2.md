# Linux Kernel Programming 2

## 书写内核框架

​	首先，我们需要确认的是我们的内核是适合写Module的，办法老简单了。

```
zcat /proc/config.gz | grep MODULES
```

![enable_module](./Linux Kernel Programming2/enable_module.png)

> 当然这个事情有点递归了，支持存在config,gz查看的适合还需要你的内核支持 `CONFIG_IKCONFIG` 和 `CONFIG_IKCONFIG_PROC`，不过好在绝大部分的发行版和内核的构建都是支持的

当然，想要开发module，对于本机上的模块，我们需要保证：

- 本机有目标平台上的GCC模块
- 本机上有Linux目标内核的头文件

​	就这样，完事。

## 起手我们需要理解的是：用户态和内核态

​	现代微处理器至少支持两种特权级别的代码执行。举一个现实世界的例子，Intel/AMD x86[-64] 系列支持四种特权级别（它们称之为环级别），**AArch32（ARM-32）微处理器系列支持多达七种模式（ARM 称之为执行模式；其中六种是特权模式，一种是非特权模式）**，

​	AArch64（ARM-64/ARMv8）微处理器系列支持四种异常级别（EL0 至 EL3，其中 EL0 特权级别最低，EL3 特权级别最高）。这里的关键点是，为了平台的安全性和稳定性，在这些处理器上运行的所有现代操作系统都将使用（至少）两个特权级别（或模式）的执行，从而将虚拟地址空间 (VAS) 分成两个明确区分的（虚拟）地址空间： 用户空间：用于在非特权用户模式下运行的应用程序。所有应用程序（进程和线程）都将在此空间中以此特权执行。

​	现在，您可能正在使用浏览器、编辑器、PDF 阅读器、终端、电子邮件客户端等。它们都是应用程序 - 最终是进程和线程；在 Linux 上，它们都在用户空间中以用户模式执行，这是非特权的。 我们很快就会明白特权和非特权的确切含义。 内核空间：用于在特权模式（内核模式）下运行的内核（及其所有组件）。这是操作系统及其内部内容的领域（如驱动程序、网络、I/O 等，包括内核模块）。它们都以操作系统特权运行；

​	实际上，它们可以做任何它们想做的事情！请注意，此特权级别是硬件功能，与是否以 root 身份运行不同（这是纯软件产物）；在许多情况下，以内核特权运行可以被视为以 root 身份有效运行。下图显示了此基本架构：

![image-20241101222331775](./Linux Kernel Programming2/image-20241101222331775.png)

​	

### 库和系统调用 API

​	用户空间应用程序通常依赖应用程序编程接口 (API) 来执行其工作。库本质上是 API 的集合或存档，允许您使用标准化、编写良好且经过充分测试的接口（并利用常见的好处：不必重新发明轮子、可移植性、标准化等）。

​	其中，所有用户模式 Linux 应用程序（可执行文件）都“自动链接”到一个重要的、始终使用的库中：glibc - GNU 标准 C 库，您将会了解到。但是，库仅在用户模式下可用；内核不使用这些用户模式库（有关此内容的更多信息，请参阅下一章）。库 API 的示例包括众所周知的 printf(3)、scanf(3)、strcmp(3)、malloc(3) 和 free(3)。 （回想一下在线章节“内核工作区设置”中的“使用 Linux 手册页”部分。）

​	现在，一个关键点：如果用户和内核是独立的地址空间并且具有不同的特权级别，那么用户进程（正如我们刚刚了解到的，仅限于用户空间）如何访问内核？简短的回答是：通过系统调用。系统调用是一种特殊的 API，因为它是用户空间进程（或线程）访问内核的唯一合法（同步）方式。换句话说，系统调用是进入内核空间的唯一合法入口点。

​	它们（系统调用）具有从非特权用户模式切换到特权内核模式的内置能力系统调用的示例包括 fork(2)、execve(2)、open(2)、read(2)、write(2)、socket(2)、accept(2)、chmod(2) 等等。

### 内核空间组件

当今的 Linux 内核是一个相当庞大和复杂的庞然大物。在内部，它由几个主要的子系统和多个组件组成。对内核子系统和组件进行广泛列举可得出以下列表：

1. 核心内核：此代码处理任何现代操作系统的典型核心工作，包括（用户和内核）进程和线程创建/销毁、CPU 调度、同步原语、信号、计时器、中断处理、命名空间、cgroup、模块支持、加密等。

2. 内存管理 (MM)：处理所有与内存相关的工作，包括内核和进程虚拟地址空间 (VAS) 的设置和维护。
   VFS（用于文件系统支持）：虚拟文件系统交换机 (VFS) 是 Linux 内核中实现的实际文件系统的抽象层（例如，ext[2|4]、vfat、ntfs、msdos、iso9660、f2fS、ufS 等等）。

3. 块 I/O：实现实际文件 I/O 的代码路径，从文件系统一直到块设备驱动程序以及其间的所有内容（真的，相当多！）都包含在这里。
   网络协议栈：Linux 以其精确、符合 RFC 要求的高质量实现而闻名，这些协议在模型的所有层上都众所周知（和不太知名的）网络协议，其中 TCP/IP 可能是最著名的。
   进程间通信 (IPC) 支持：IPC 机制的实现在这里完成； Linux 支持消息队列、共享内存、信号量（包括较旧的 SysV 和较新的 POSIX）和其他 IPC 机制。

4. 声音支持：实现音频的所有代码都在这里，从固件到驱动程序和编解码器。

5. 虚拟化支持：Linux 已在大型和小型云提供商中变得非常受欢迎，一个重要原因是其高质量、低占用空间的虚拟化引擎，即基于内核的虚拟机 (KVM)。

![image-20241101223713359](./Linux Kernel Programming2/image-20241101223713359.png)

​	上面的架构说的很明白了：Linux是一个宏内核，在这个巨大的内核内部是多个子系统之间协调的工作。

​	您应该知道的另一个事实是，这些地址空间当然是虚拟地址空间，而不是物理地址空间。内核将在页面粒度级别将虚拟页面映射到物理页面框架，利用硬件块（例如内存管理单元 (MMU) 和处理器以及转换后备缓冲区 (TLB) 缓存）来提高效率。它通过使用主内核分页表将内核虚拟页面映射到物理框架 (RAM) 来实现这一点，并且对于每个处于活动状态的用户空间进程，它通过每个进程的单独分页表将进程的（用户）虚拟页面映射到物理页面框架
