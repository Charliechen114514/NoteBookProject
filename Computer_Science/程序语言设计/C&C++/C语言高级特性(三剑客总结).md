# C 陷阱与缺陷

## 词法陷阱

​		首先，独自出现的`->`是可能没有意义的，这是指的是

```
AStruct->pString = "->" 
```

​		两者的`->`有显著的区别：，前一个则是作为一个操作符出现，后者是作为一个字符串出现。

​		我们指出，`->`就是一个符号，英文意思就是`token`，编译器分析每一个token，也就是语法最小单位来判断需要翻译成怎样的指令。

​		举个例子：

```
if(x > big) big = x;
```

​		分一下if, (, x, >, big ,), big, =, x, ;

## 小心 `=` 和 `==`

```
if(x = y)
	break;
```

​		这样的行为就是一个赋值行为,表达式的值就会交给if模块，所以，这个表达式的意思就是：把 y 赋值给 x，然后if( x ) ，x是0，判断结果就是假，反之就是真。

​		现在，我们再来看一个程序：

```
while(c = ' ' || c == '\t' || c == '\n')
	c = getc(f);
```

​		这里，第一个表达式被写作了:`c = ' '`，也就是说，c这个字符被赋值给了一个‘ ’,远远背离我们的预期。

​		当然，我们有的时候确实需要赋值并检查，可以使用显式的比较方案：

```
if( (fd = open(argv[1], 'r')) < 0)
	error();
```

## C语言的词法分析是“贪心”的

​		我指的意思是：C语言的词法分析总是试图以最大字符长度的解释字符，如：看到两个 -- ，会自动翻译成自递减而不是两个减号一个道理。另一个操蛋的例子是：

```
x/*p;
```

​		我知道，意思显然是： x / (*p)。但是，根据上面的原则，他会直接读取到 `/*`，这意味着，被解析成了注释的前半段。，想要表达想表达的那个意思，**请务必加上（）。**

## 整形常量

​		注意，我**们的数字要是以0开头，意味着这个数字是一个八进制数字**。一些人常常喜欢搞对齐：

```
struct{
    int part_num;
    char* descriptions;
}partTab[]{
    046, "left",
    047, "right",
    125, "Unknown"
}
```

​		导致事实上046 != 46!

## 字符 && 字符串

​		C语言下，单引号表示的是一个字符，双引号则是一个字符串。

```
printf("Hello!");
char hello[] = {'H', 'e', 'l', 'l', 'o', '!', '\0'};
printf(hello);
```

​		等价！

# 语法陷阱

## 理解函数声明

​		我们想要启动一个在0地址处的函数，这个函数是一个不需要参数返回为空的函数，我们应该怎么书写之呢？

```
(*(void(*)())0)();
```

​		有点哈人？，好吧，确实。任何一个非C程序员可能会一头雾水。

​		但是我们可以这样封装，在最外层上，这分明是一个调用：

```
(*STH)(0)()
```

​		0就是一个被STH强制转换的指针，STH是一个怎样的指针呢？

```
STH = (void(*)())
```

​		答案是一个不需要参数返回为空的函数指针。回忆一下，我们声明函数指针总是需要返回类型和参数类型：

```
return-type (*PTR_NAME)(PARAM TYPELIST)
```

​		这样，我们就明白了：我们首先弄出来一个类型：void(*)()，他强制转换了0，然后调用之。不过别再操作系统尝试，一定会报错的。

​		我们下一个例子是一个信号处理函数。

```
void sigFunc(int signal){/* Do sth here */}
```

​		然后，我们如果想要拿到他的指针。就需要仿照上面的形式：

```
void(*pSigFunc)(int)
```

​		我们下面要声明一个这样复杂的函数指针：他接受一个int,和一个pSigFunc类型的指针，然后返回一个pSigFunc的指针，我们应该怎么做？

​		我们看到，为了避免复杂，我们当然可以去封装之：

```
typedef void(*HandlePtr)(int);
HandlePtr signal(int, HandlePtr); // 函数类型
```

​		展开之：

```
void (*signal(int, void(*)(int))(iint)
```

## 小心运算符优先级

​		一个表达式可以包含多个运算符。在这种情况下，运算符的优先级决定表达式的哪部分被处理为每个运算符的操作数。例如，按照运算规则，表达式中 *、/、以及 % 的优先级比 + 和 - 高。如下列表达式：

```
a - b * c
```

相当于 a－（b*c）。如果想让操作数以不同的方式组合在一起，则必须使用括号：

```
(a - b) * c
```

​		如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。例如，算术运算符和操作数的组合方式是从左到右，赋值运算符则是从右到左，如表 1 所示。



| 表达式 | 结合律   | 组合方式  |
| ------ | -------- | --------- |
| a/b%c  | 从左到右 | （a/b）%c |
| a=b=c  | 从右到左 | a=（b=c） |

表 2 列出优先级次序下，所有 C 语言运算符的优先级和结合律。



| 优先级 | 运算符                                                       | 结合律   |
| ------ | ------------------------------------------------------------ | -------- |
| 1      | 后缀运算符：[]   ()   ·   ->   ++   --(类型名称){列表}       | 从左到右 |
| 2      | 一元运算符：++   --   !   ~   +   -   *   &   sizeof _Alignof | 从右到左 |
| 3      | 类型转换运算符：(类型名称)                                   | 从右到左 |
| 4      | 乘除法运算符：*   /   %                                      | 从左到右 |
| 5      | 加减法运算符：+   -                                          | 从左到右 |
| 6      | 移位运算符：<<   >>                                          | 从左到右 |
| 7      | 关系运算符：<<=   >>=                                        | 从左到右 |
| 8      | 相等运算符：==   !=                                          | 从左到右 |
| 9      | 位运算符 AND：&                                              | 从左到右 |
| 10     | 位运算符 XOR：^                                              | 从左到右 |
| 11     | 位运算符 OR：\|                                              | 从左到右 |
| 12     | 逻辑运算符 AND：&&                                           | 从左到右 |
| 13     | 逻辑运算符 OR：\|\|                                          | 从左到右 |
| 14     | 条件运算符：?:                                               | 从右到左 |
| 15     | 赋值运算符：    =     +=     -=    *=    /=    %=    &=    ^=    \|=     <<=    >>= | 从右到左 |
| 16     | 逗号运算符：，                                               | 从左到右 |

​		表 2 中优先级最高的运算符中的最后一个（类型名称）{列表} 是 C99 新增加的。

​		一些运算符记号在表 2 中出现了两次。例如，自增运算符 ++ 和自减运算符 --，在作后缀运算符（如表达式 x++）时，较其用作前缀运算符（如表达式 ++x）时，具有较高的优先级。

​		+、-、* 和 & 运算符记号不但可以当作一元运算符（unary operator，只需要一个操作数），也可以当作二元运算符（binary operator，需要两个操作数）。例如，* 只有一个操作数的时候，就是间接运算符（indirection operator），而有两个操作数的时候，就是乘号。

​		在这些例子中，一元运算符比二元运算符具有更高的优先级。例如，表达式 *ptrl**ptr2 等同于表达式（*ptrl）*（*ptr2）。

## 小心不要遗忘；也不要滥用分号

​		这就是我要说的，举个例子：

```
if(x[i] > big)
	big = x[i];
```

​		和

```
if(x[i] > big);
	big = x[i];
```

​		一样吗？不一样。

​		后者被解释成了：

```
if(x[i] > big)
{
	;
}
big = x[i];
```

​		后果是：big总是被更新做`x[i]`!

## switch语句

​		一句简单的话：请务必在switch后面依据情况加上break，我是什么意思呢？

```
switch(sth):
{
    case 1: ...;break;
    case 2: ...;break;
    ...;
    default: break;    
}
```

​		这是不同于其他一些语言的。警惕`fallthrough`!

# 语义陷阱

## 指针与数组

1. C语言中只有一维数组。数组中的元素可以是任意类型的对象，这也是多维数组构建的理论基础所在。

举个例子：

```
calendar[12][31];
```

​		我要问calendar[4]是啥呢？答案是一个calendar[4]是第五个具有31个整形元素的数组。这意味着想要访问具体的元素，需要：

```
calendar[X][Y];
```

​		如同行列一般。

1. 对于一个数组，我们只能做两件事：**确定该数组的大小以及获得该数组下标为0的元素的指针。**任何一个数组下标运算都等同于一个对应的指针运算。
2. 数组名代表首元素的地址，无法对其进行++或者–操作，换句话说，我们无法改变数组名（表示的值），因为数组名是个常量，无法进行修改。

## 非数组的指针

下面有一段程序，指出它的错误：

```C
char *r;
r = malloc(strlen(s)+strlen(t));
strcpy(r,s);
strcat(r,t);
```

> 1. malloc有可能无法提供请求的内存，这种情况下malloc函数会通过返回一个空指针来作为“内存分配失败”事件的信号。
> 2. 给r分配的内存在使用完毕后应该及时释放。
> 3. 前面的例程在调用malloc函数时并未分配足够的内存，因为字符串还包含结束标志’\0’。

依据上述，我们有理由更改之：

```C
char* r = NULL;
r = (char*)malloc(strlen(s) + strlen(t) + 1);
if(r == NULL)
{
	complain();
    exit(1);
}
strcpy(r,s);
strcat(r,t);
// ...
free(r);
```

这提示我们，需要时刻警惕分配，最好是包装起来，成对使用是最好的。



## 作为参数的数组声明

1.下面列举的两种写法是等价的：

```C
char hello[] = "hello";
printf("%s\n",hello);//写法1
printf("%s\n",&hello);//写法2
```

**原因：数组名hello代表数组hello首元素的地址。**

2.下面的两种写法是等价的：

```C
int strlen(char s[])
{
	/*具体内容*/
}
int strlen(char *s)
{
	/*具体内容*/
}
```

3.注意下面的两种写法：

```C
extern char *hello;
extern char hello[];
```

这两种写法虽然是都是正确的，但是不同的形式传递给我们的意思却是完全不一致的，我们要根据具体情况进行使用。

## 空指针并非空字符串

注意：空指针不能对其进行解引用。

**同时注意不能出现下述写法：**

```
if(strcmp(p,(char*)0)==0)
	···
```

这种写法是非法的，原因在于库函数`strcmp`的实现中会包括一个操作，用于查看它的指针参数所指向的内容，即对空指针进行了解引用。

**也不能出现下述写法：**

假设p是空指针

```
printf(p);
printf("%s",p);
//当然，这两种写法是等价的
```

这种行为是未定义的。

## 当心深浅拷贝

​		这是C++的术语。我需要提及的是简单的拷贝指针实际上只是将之指向了同一处地点而已

## 边界计算与不对称边界

1. 在我们写循环是最好这样来写：

   ```
   int i = 0;
   for(i = 0; i < 10; i++)
   	···
   ```

   这样写能够更好的看出循环的次数，即10次。

2. 当数组中有10个元素时，下标的取值范围为0到9，但是当我们不需要引用这个元素时只需要引用这个元素的地址时，我们可以这样写

   ```
   int arr[10] = {1,2,3,4,5,6,7,8,9,10};
   for(int i = 0;&arr[i]<&(arr[10]);i++)
   	···
   ```

   ​		这样可以顺利打印出数组元素从1到10的数字，

   ​		ANSI C标准明确允许这种用法：数组中实际不存在的"溢界"元素的地址位于数组之外所占内存之后，这个地址可以用于进行赋值和比较。当然，如果要引用该元素，那就是非法的了。对于实际去读取这个元素的值，这种做法的结果是未定义的，**而且极少有编译器能偶检测出这个错误。当然，如果试图去修改这个元素，必然会导致程序崩溃，属于非法访问了！**

## 求值顺序

​		C语言中只有四个运算符(&&、||、?:和，)存在规定的求值顺序。运算符&&和运算符||首先对左侧操作数求值，只有在需要时才对右侧操作数求值。运算符?:有三个操作数：在a?b:c中。操作数a首先被求值，根据a的值再求操作数b或c的值（此时b或c两个表达式根据前面a表达式的结果只会执行一个）。**逗号运算符则首先对左侧操作数求值，然后"丢弃该值"，再对右侧操作数求值。**

​		**注意：分割函数的参数并非逗号运算符。例如，x和y在函数f(x,y)中的求值顺序是未定义的，而在函数g((x,y))中却是确定的先x后y的循序。在后一个例子中，函数g只有一个参数。这个参数的值是这样求得的：先对x求值，然后“丢弃”x的值，接着求y的值。**

​		这种求值顺序的存在使得某些“错误”的程序变为了正确，且在执行后得出正确的结果：

```
if(count!=0 && sum/count < smallaverage)
	···
```

​		注意：C语言中其它所有的运算符对其操作数求值的顺序是未定义的。特别是，赋值运算符并不保证任何求值循序。

​		例如：下面的这中从数组x中复制前n个元素到数组y中的做法是不正确的，因为它对求值顺序做了太多的假设：

```
i = 0;
while(i < n)
	y[i] = x[i++];
```

​		上面的代码假设y[i]的地址将在i的自增操作指向之前被求值，但这是不一定的，这依赖于编译器的具体实现。同样，下面的这种写法也是不正确的：

```
i = 0;
while(i<n)
	y[i++] = x[i];
```

​		修改成下面这种写法即可正常工作：

```
i = 0;
while(i<n)
{
	y[i] = x[i];
	i++;
}
```

​		当然，这种写法也可以简写为：

```
for(i = 0;i < n;i++)
	y[i] = x[i];
```

## 整数溢出

​		无符号整数不会发生溢出，这是C语言所规定的，如果结果大于所能表示的最大值M，则模(M+1)，也就是发生了截断现象。

​		两个有符号整数进行相加时会发生溢出，而且溢出的结果是未定义的。

​		下面是一种错误的检查方式：

```
if(a + b < 0)
	complain();	
```

因为当`a+b`却是发生溢出时，所有关于结果如何假设都不再可靠。

下面是两种正确的方式：

```
//方法一：
if((unsigned)a + (unsigned) > INT_MAX)
	complain();
//方法二：
if(a > INT_MAX - b)
	complain()
```

## 为函数提供返回值

C语言种常常通过return 返回一个值来告知操作系统的执行是成功还是失败，典型的处理方案是。返回值为0表示程序执行成功，返回值为非0则表示程序执行失败。**我们常常会在程序的末尾加上return 0操作。**

# 链接

## 什么是链接器

​		典型的链接器把由编译器或汇编器生成的若干个目标模块，整合成一个被称为载入模块或可执行文件的实体–该实体能够被操作系统直接执行。

![截图](./C语言高级特性(三剑客总结)/632f85953a38353d5b53c17cdeec96b8-1700210789484-127.png)		链接器通常把目标模块看成是由一组外部对象组成的。每个外部对象代表着机器内存中的某个部分，并通过一个外部名称来识别。因此，程序中的每个函数和每个外部变量，如果没有被声明为static，就都是一个外部对象。某些C编译器会对静态函数和静态变量的名称做一定改变，将它们也作为外部对象。由于经过了“名称修饰”，因此它们不会与其它源程序文件中的同名函数或同名变量发生命名冲突。

## 声明与定义

```
extern int a;
```

**上面的这段代码并不是对a的定义，而是说明a是一个外部整型变量。**换而言之，需要去程序的其他地方或者其他存储位置寻找变量定义8

**注意：引入之后，假如引入的位置在函数之外，就相当于在那个位置定义了全局变量，同样遵循局部变量优先原则，如果引入位置在某个函数之内，就相当于是一个局部变量，作用域与那个地方定义的局部变量相类似，此处讨论声明周期没有任何意义。**

```
int a;
extern int a;
```

上面的这两条语句既可以是在同一个源文件中，也可以位于程序的不同源文件之中。

注意：每个外部变量只能定义一次。如果外部变量的多个定义各指定一个初始值，例如：

```
int a = 7;
```

出现在一个源文件中，而

```
int a = 9;
```

出现在另一个源文件中，大多数系统都会拒绝接收该程序。但是，如果一个外部变量在多个源文件中定义却没有指定初始值，那么**某些系统会接受这个程序，而另外一些系统则不会接受。**所以，每个外部变量必须只定义一次。

## 命名冲突

### 命名冲突

如果在两个不同的源文件中都包括了定义

```
int a;
```

​		**那么它要么表示程序错误（如果链接器进制外部变量重复命名的话），要么在两个源文件中共享a的同一个实例（无论两个源文件中的外部变量是否应该被共享）。即使其中a的一个定义是出现在系统提供的库文件中，也仍然进行同样的处理。**

### static修饰符

```
static int a;
```

**static修饰a之后，a的作用域将被限制在一个源文件中，对于其它源文件，a是不可见的，且无法再被extern所引用，当然，static也适用于函数。**使用static之后，我们就可以在其它的源文件中定义和这个已经被static修饰后的同名的变量或者函数。

## 形参、实参、返回值

**如果我们使用的函数并未进行声明，但是已经在后面进行了定义，此时会默认函数返回类型为int型，这会造成极其严重的后果。**

**使用的函数如果在使用之前并未定义或者可能在其他的文件中，那么就要进行声明，函数声明的目的就是告知编译器函数的返回值的类型。**

注意：如果一个函数没有float、short、或者char类型的参数，在函数声明中完全可以省略掉参数类型的说明（注意，函数定义中不能省略参数类型的说明）。这种做法依赖于调用者能够提供数目正确且类型恰当的实参。这里，“恰当”并不意味着“等同”：float类型的参数会自动转换为double类型，short或者char类型的参数会自动转换为int类型。

在ANSI C标准发布之前，常常会有下面的这种声明和定义函数的方式：

```
int isvowel();//声明函数的方式

int isvowel(c)
char c;
{
	return c =='a' ;
}
```

实际上，上面这种写法与下面这种写法是等价的：

```
int isvowel(int i)
{
	char c;
	return c=='a';
}
```

上述两种方式在VS2019中都是支持的。

看下面的例子：

```
#include<stdio.h>
int main()
{
	int i;
	char c;
	for (i = 0; i < 5; i++)
	{
		scanf("%d", &c);
		printf("%d ", i);
	}
	printf("\n");
	return 0;
}
```

> 表面上，这个程序从标准输入设备读入5个数，在标准输出设备设备上写5个数：
>
> ```
> 0 1 2 3 4
> ```
>
> 实际上，这个程序并不一定得到上面的结果。例如，在某个编译器上，它的输出是（当然，在VS2019环境下程序会崩溃，因为非法修改了内存空间）
>
> ```
> 0 0 0 0 0 1 2 3 4
> ```
>
> 为什么呢？问题的关键在于，这里的c被声明为char类型，而不是int类型。如果程序要求scanf读入一个整数，应该传递给他一个指向整数的指针。而程序中scanf函数得到的却是一个指向字符的指针，scanf函数并不能分辨这种情况，它只是将这个指向字符的指针作为指向整数的指针而接受，并且在指针指向的位置存储一个整数。因为整数所占的存储空间要大于字符所占的存储空间，所以字符c附近的内存被覆盖。
>
> 字符c附近的内存中存储的内容是由编译器决定的，在本例中它所存放的是整数i的低端部分。因此，每次读入一个数值到c时，都会将i的低端部分覆盖为0，而i的高端部分本来就是0，相当于i每次被重新设置为0，循环将一直进行。当到达文件的结束位置后，scanf函数不再试图读入新的值到c。这时，i才可以正常的运行，最后终止循环。

## 检查外部类型

注意：保证一个特定类型的所有外部定义在每个目标模块中都有相同的类型，“相同的类型”也应该是严格意义上的相同。

例如，在一个文件中包含定义：

```
char filename[] = "/etc/passwd";
```

而在另一个文件中包含声明：

```
extern char *filename;
```

在定义时，filename是一个字符数组的名称。尽管在一个语句中引用filename的值将得到指向该数组起始元素的指针，但是filename的类型是”字符数组“，而不是字符指针。在第二个声明中，filename被确定为一个指针。这两种方式使用存储空间的方式是不同的，它们无法以一种合乎情理的方式共存。第一个例子字符数组filename的内存布局如下图所示： ![image-20220304221554347](./C语言高级特性(三剑客总结)/typora图床202203191543418-1700210789484-128.png)

第二种方式字符指针filename的内存布局如下图所示：

![image-20220304221842175](./C语言高级特性(三剑客总结)/typora图床202203191543924-1700210789484-129.png)

修改方法如下图所示：

```
char filename[] = "/etc/passwd";
extern char filename[];
```

也可以这样进行修改：

```
char*filename = "/etc/passwd";
extern char *filename;
```

## 头文件

注意：每个外部对象只在一个地方声明，这个声明的地方一般就在头文件种，需要用到该外部对象的所有模块也应该 包括在这个头文件。特别指出的是，定义该外部对象的模块也应该包括这个头文件。

# 库函数

## 返回整数的getchar函数

代码：

```
#include<stdio.h>
int main()
{
	char c;
	while((c = getchar())!=EOF)//getchar函数的返回值为整型
		putchar(c);
	return 0;
}
```

上述代码有三种可能：

1. 某些合法的输入字符在被“截断”后使得c的取值与EOF相同，程序将在复制的中途停止。
2. c根本不可能取到EOF这个值，陷入死循环。
3. 程序表面上能够正常工作，但完全是因为巧合。尽管函数geutchar的返回结果在赋给char类型的变量c时会发生“截断”操作，但在许多编译器下，它们在比较表达式中并不是比较c与EOF，而是比较getchar函数的返回值与EOF！，如果编译器采取的是这种做法，上面的例子就能够正常运行了。

## 更新顺序文件

在使用r+同时进行写入和读出文件的操作时，要使用fseek移动指针才行，因为在进行写入和读取的同时，文件指针指向的位置发生了改变。

## 缓冲输出与内存分配

​		程序输出有两种方式：一种是即时处理方式；另一种是先暂存起来，然后再大块写入的方式。

```
setbuf(stdout,buf);
```

​		**语句将通知输入/输出库。所有写入stdout的输出都应该使用buf作为输出缓冲区，直到buf缓冲区被填满或者程序员直接调用fflush(对于由写操作打开的文件，调用fflush将导致输出缓冲区的内容被实际的写入该文件)，buf缓冲区种的内容才实际的写入stdout中。缓冲区的大小由系统头文件<stdio.h>中的BUFSIZ定义。**

下面是实例：

```
#include<stdio.h>
int main()
{
	int c;
	char buf[BUFSIZ];
	setbuf(stdout,buf);
	while((c = getchar())!=EOF)
		putchar(c);
}
```

​		上面这个程序是错误的，因为buf缓冲区最后一次清空是再main()函数结束之后，在将控制权交给操作系统之前，C运行时库所必须进行清理工作的一部分。但是，在此之前buf字符数组已经被释放。

两种解决方案：

1. ```
   static char buf[BUFSIZ];
   ```

2. ```
   setbuf(stdout,(char*)malloc(BUFSIZ));
   //此处不需要检查malloc函数调用是否成功，因为setbuf函数的第二个参数取值可以为NULL,此时标准输出不需要进行缓冲。
   ```

## 库函数

C语言实现中包括signal库函数，将其作为捕获异步时间的一种方式。

```
#include<signal.h>//需要引用的头文件
signal(signal type , handler function);
```

这里的signal type代表系统头文件signal.h中定义的某些常量，这些常量用来标识signal函数将要捕获的信号类型。这里的handler function是当指定的事件发生时，将要加以调用的事件处理函数。

注意：信号甚至可能出现在某些复杂库函数(如malloc)的执行过程中。。因此，从安全的角度考虑，信号的处理函数不应该调用上述类型的库函数。

例如：假设malloc函数的执行过程被一个信号中断。此时，malloc用来跟中可用内存的数据结构很可能只有部分被更新。如果signal处理函数再调用malloc函数，结果可能是malloc函数用到的数据结构完全崩溃，后果不堪设想。

**结论：信号非常复杂棘手，而且具有一些从本质上而言不可移植的特性。所以我们应该让signal处理的函数尽可能的简单，并将它们组织在一起，这样，当需要适应一个新系统时，我们可以很容易的进行修改。**

关键点：宏只是对程序的文本起作用。

# 预处理器

## 不能忽视宏定义中的空格

观察下面宏定义：

```
#define f (x) ((x)-1)
```

f(x)代表

```
(x) ((x)-1)
```

而我们像要它代表的是

```
((x)-1)
```

原因就是在f和后面的(x)之间多了一个空格！所以，正确的定义方法是：

```
#define f(x) ((x)-1)
```

​		这一规则不适用于宏调用，而只适用于宏定义。所以，在上面完成宏定义之后，f(3)和f (3)求值后都等于2。注意：函数调用也是完全一样的，即假如我们定义了函数ADD，那么ADD(1,2)和ADD (1,2)求值后的结果都是3。

## 宏并不是函数

​		注意：宏定义中各个参数与整个结果表达式都被括号括起来。但仍然存在其它问题，比如副作用的自增和自减运算符，只要出现一次就进行一次自增或者自减，归根结底是因为宏是文本的替换，所以**要保证使用宏的参数没有副作用。**而函数则不是这样的，函数实参中的自增或者自减运算符只会执行一次，所以也要区分函数和宏。

​		根本上：就是宏只是起到了替换文本的作用。

## 宏不是语句

假如我们定义一个宏，能够在出错信息中包含文件名和断言失败处的行号，即

```
assert(x<y);
```

在x大于y时什么也不做，在其它情况下则会终止程序。

假如我们这样定义：

```
#define assert(e) if(!e) assert_error(__FILE,__LINE__)
```

但是当我们遇到下面这种情况时就会出错：

```
if(x > 0 && y > 0)
	assert(x > y);
else
	assert(y > x);
```

上面的写法在展开之后就是这个样子的：

```
if(x > 0 && y > 0)
	if(!(x>y)) assert_error("foo.c",37);
else
	if(!(y>x)) assert_error("foo.c",39);
```

把上面的代码进行缩排之后是下面这样的：

```
if (x > 0 && y > 0)
		if (!(x > y)) assert_error("foo.c", 37);
		else
			if (!(y > x)) assert_error("foo.c", 39);
```

很明显，上面的代码与我们想要表达的意思完全不一样了。

当然，貌似我们可以在宏assert的定义中用大括号把宏整个给括起来，就能避免这样的问题产生：

```
#define assert(e)\
	{if(!e) assert_error(__FILE,__LINE__);}
```

然而。这样就会带来新的问题了，我们上面提到的例子展开后就成了：

```
if(x > 0 && y > 0)
	{ if(!(x<y)) assert_error("foo.c",37);};
else
	{ if(!(y > x)) assert_error("foo.c",39);};
```

​		在else之前的分号是一个语法错误。要解决这个问题，一个办法就是对assert的额调用在后面加一个分号，但这样的用法显得有些”怪异“：

```
y = distence(p,q);
assert(y>0)
x = sqrt(y);
```

宏assert的正确定义很不直观，这个定义 看起来类似一个表达式，不是类似于一个语句：

```
#define assert(e)\
	((void)((e)||_assert_error(__FILE__,__LINE__)))
```

这个定义实际上利用了||运算符对两侧的操作数一次顺序求值的性质。

### 6.4 宏不是类型定义

**宏只是简单的文本替换，但是typedef则是定义新的类型，新类型与int、float等类型具有相同的地位。**

# 可移植性缺陷

## 字符是有符号整数还是无符号整数

一个常见的错误认知就是：如果c是一个字符变量，使用`(unsigned)`就可得到与c等价的无符号整数。

这是会失败的，因为在将字符c转换为无符号整数时，c将首先被转换为int型整数，而此时可能得到非预期的结果。

## 逻辑运算符

如果我们想进行逻辑右移操作，就把我们想要进行右移的数的类型设为无符号类型，左边就会填充0，如果想进行算术右移，就一般把类型设为有符号类型。（VS2019环境下）

注意：移位操作时，移位的数目，不应该超过当前数据的类型所占的字节数，比如int型有32个字节，那么移位操作的数目应该为0到31，这在编译器上属于未定义的操作，同时，移位的数目不可以是负数。

## 内存位置

除了赋值和比较运算外，出于其它任何目的使用`NULL`都是非法操作。

## 大小写转换

toupper是函数实现的，如下所示：

```
int toupper(int c)
{
	if(c >= 'a' && c <= 'z')
		return c+'A' - 'a';
	return c;
}
```

tolower与此类似

```
#define _toupper(c) ((c) + 'A' - 'a')
#define _tolower(c) ((c) + 'a' - 'A')
```

即使用toupper会对参数进行判定，如果不是小写字母就返回原来的参数，而_toupper则不会对函数进行判定。

## 附录

1. 下面有两行代码：

   ```
   printf(s);
   printf("%s",s);
   ```

   两者的含义并不相同。第一个例子将把字符串s中的任何%s字符视为一个格式项的标志，因而其后的字符会被视为格式码。如果除%%之外的任何格式码再字符串s中出现，而后面又没有对应的参数，将会带来麻烦。而第二个例子中将会打印出任何空字符结尾的字符串。

   结论：如果我们想要这样(printf(s))进行打印，那么我们就必须将s字符串中的%变为%%，否则会出现打印错误。

2. 如果一个short整数作为作为任何一个函数（也包括printf函数）的参数出现，它会被自动的扩展为一个正常长度的整数，即int型。

3. **宽度修饰符绝对不会截断一个输出域（即小数点前面的数字），当我们使用宽度修饰符来按列对齐一组数字时，如果一个数值太大而不能被它所在的栏所容纳，那么它就会挤占同一行右侧紧邻数值的位置。**

4. 对于%e、%E和%f格式项，精度修饰符制定了小数点后应该出现的数字位数。除非标志（Flag）另有说明，否则仅当精度大于0时打印的数值中才会实际出现小数点。下面是例子：

   ![image-20220306223404638](./C语言高级特性(三剑客总结)/130078bbf30751ceff350ea9de64d6f7-1700210789484-130.png)

5. 对于%g和%G格式符，精度修饰符制定了打印数值中的有效数字位数。除非标志另有说明，否则非有效数字的0将被丢掉。如果小数点后不跟数字，则小数点也将被删除。

   ![image-20220306224021458](./C语言高级特性(三剑客总结)/6b6bae5e1ee3f70215fb617f16522e3d-1700210789484-131.png)

6. 对于%格式项，精度修饰符(即小数点后面的数字)制定了将要从相应的字符串中打印的字符数。如果该字符串中包含的字符数少于精度修饰符所指定的字符数，输出的字符数就会少于精度修饰符所指定的数目。如果该字符串中包含的字符数多余精度修饰符所指定的字符数，输出的字符数将和精度修饰符所指定的字符数一致，即发生类似截断的情况。

   ![image-20220306225432533](./C语言高级特性(三剑客总结)/98ccd7e350362ba433455fcb48cd6d02-1700210789485-133.png)

7. 标志自读+(放在%后面)的作用是，规定每个待打印的数值在输出时都应该以它的符号(正号或负号)作为第一个字符。因此，非负数(包括0)打印出来后，应该在最前面有一个正号。负数前面有一个负号。

8. 空白字符作为标志字符时，它的含义是：如果某数是一个非负数，就在它的前面插入一个空白字符。如果标志字符+与空白字符同时出现在一个格式项中，最终的效果以标志字符+为准。

   例如：

   ![image-20220307095839128](./C语言高级特性(三剑客总结)/0941b0cbc769e10a069957d8f00b22c1-1700210789484-132.png)

   当在固定栏内按科学计数法打印数值，格式项% e和%+e要比正常的格式项%e有用的多。因为这时出现在非负数前面的正号(或者空白)保证了所有输出数值的小数点都会对齐。

   例如：

   ![image-20220307100958917](./C语言高级特性(三剑客总结)/6ed401beb2bdd5276b2824e33872f81a-1700210789485-134.png)

9. 标志字符#的作用是对数值输出的格式进行微调，具体的格式与特定格式项有关。给%o格式项加上标志字符#的效果是：当有必要时增加数值输出的精度（只需让输出的第一个数字为0就已经做到了）。

   注意：%#o与0%o并不相同，因为0%o把数值0打印成00，而%#o的打印结果是0。同理，%#x与%#X要求打印出来的十六进制数值前面分别加上0x或0X。

   标志字符#对浮点数格式的影响有两方面：

   - 它要求小数点必须被打印出来，即使小数点后没有数字也是如此
   - 如果用于%g或%G格式项，打印出的数值尾缀的0将不会被丢掉。

   例如：![image-20220307102051616](./C语言高级特性(三剑客总结)/288264fff11559b6045048d94ca84953-1700210789485-135.png)

10. 可变域宽与精度

    我们如果要通过宏定义的方式来控制打印字符串的长度，比如我们大概率是会像下面这样使用：

    ```
    #define NAMESIZE 14
    printf(".......%.NAMESIZE ...",...,name,...);
    ```

    但是这样写一点用处也没有，因为预处理器的作用范围不能达到字符串的内部。即预处理期间是无法替换字符串内的宏定义。

    解决方案：

    我们需要用*替换修饰符宽修饰符或精度修饰符其中之一。在这种情况下，printf函数首先从参数列表中取得将要使用的域宽或精度的实际数值，然后使用该数值来打印任务。因此，上面的例子可以写成这样：

    ```
    printf("%*.%*s\n",NAMESIZE,NAMESIZE,name);
    ```

    上面的这段代码与下面的这段代码是一样的：

    ```
    printf("%*.%*s\n",14,14,name);
    ```

    看下面一个例子：

    ```
    printf("%*%\n",n);
    ```

    上式将在宽度为n个字符的域内以有段对齐的方式打印除一个%负号，换言之，就是先打印n-1个空白字符，后面再跟一个%负号。

    注意：如果*用于替换域宽修饰符，而与其相对用的参数的值为负数，那么效果相当于把负号作为-标识符来处理。。因此，上例中如果n为负数，输出结果首先是一个%负号，后面再跟-n-1个空格

11. 有关于上面的总结：

    下面对几个进行区分：

    （1）%m.nd:m代表输出一共占m列，不够m列前面补空格，够m列不作任何处理，n代表这个数一共要有n列，不够前面补0，够n列不做任何处理。

    注意：m是把包括负号（正号、0x、0）在内一共是m个字符，而n是只算数字是总共n个数字。前者不够补空格，后者不够补0。

    ![image-20220307112620666](./C语言高级特性(三剑客总结)/dbac2a0713da7df913e717baa7690df7-1700210789485-136.png)

    **在大多数场合下，我们都可以用%.来代替%0，效果非常接近。**

    下面是例子：

    ![image-20220307114910383](./C语言高级特性(三剑客总结)/987767488abc28eedaf8fb839e8d6aa5-1700210789485-137.png)

    （2）%m.ns:m代表这个字符串一共输出m列，n代表取这个字符串前n个元素输出到整个m列的右侧，当n<m时，用空格补齐左边的余缺，当n>=m时，不做处理。

    下面是例子：

    ![image-20220307115944317](./C语言高级特性(三剑客总结)/afe35ca53b264a1b5293c4b6b4ce9fae-1700210789485-138.png)

    （3）%m.nf:m代表这个数一共要输出m列，包括小数点和小数的位数，n代表小数的个数，当浮点数的小数的位数大于n时，采用四舍五入（1-5舍掉，6-9进位），小于n时，后面补0

    下面是例子：

    ![image-20220307120249656](./C语言高级特性(三剑客总结)/6c509bad779a0d2d50211b6731c13e8a-1700210789485-139.png)

# C专家编程

## 第一章 C：穿越时空的迷雾

### **01 起源**

1）Multics项目（小规模硬件系统运行巨大操作系统）—MIT，GE，Bell。- “小即是美”

 2）UNIX，Ken Thompson；（BCPLB）；C语言，Dennis Ritchie 小结：“小即是美”、“（编译器）效率几乎是一切”

### **02 特性**

1）类型系统：帮助编译器设计者区分硬件支持的不同类型

 2）[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)下标：从0开始偏移量 

3）基本数据类型与硬件相对应 

4）auto：缺省的，现在几乎不用 

5）表达式中的数组名可以看作是指针：简化区分机制 

6）float自动转换为double 

7）不允许函数嵌套 

8）Register：简化了编译器，但程序员的任务加重

### **03 标准I/O库和预处理器**

C编译器不曾实现的功能，就得由其他途径实现。

#### 1）I/O最初由库函数提供，后来成为标准机制，由Make Lest编写

#### 2）C预处理器：

①字符串替换；

②头文件包括；

③通用代码模板扩展（注意宏空格）。

#### 3）宏：最好只用来对命名常量，应该大写，以区分函数名；

小结：宏扩展中，空格会对结果造成很大影响，宏不是C语句，后不可加分号‘；’

#### 04 K&R C

1）早期的C --> K&R C–> ANSI C --> C++；1978年The C Programming Language，该版本称为K&R C。

#### 05 今日之ANSI C

1）防止C变种为多个松散的语言–>确立标准 2）应该使用ANSI C的标准，即美国国家标准化组织（1989年）–>ISO C（C90）

#### 06 很棒，但符合标准吗

1）不可移植的代码：由编译器设计者决定采取何种行动 如，整型右移要不要扩展符号位，未确定的unspecified，参数求值的先后顺序 

2）坏代码：未定义的undefined–在某些不正确的情况下的做法，标准未规定怎么做。 

3）约束条件：不遵守就会成为未定义的 

4）可移植的代码：严格遵守标准的成率–>①只使用已确定的特性；②不产生任何由编译器定义的undefined或unspecified输出；③不突破任何由编译器实现的限制。

5）遵循标准：可以依赖一些某种编译器特有的不可移植的特性。

#### 07 编译限制

1）ANSI C对一个能够成功编译的程序的最小长度做了限制‘ 

2）每一个ANSI C编译器应该支持： ①函数定义形参上限至少为31个； ②函数调用实参上限至少为31个； ③一条源代码行里至少可以有509字符； ④表达式中至少可以支持32层嵌套的括号； ⑤long型整数不得低于32位。 08 ANSI C标准的结构 1）ANSI C标准出处和内容：总体介绍 

2）K&R C和ANSI C区别： ①原型，是对声明的扩展； ②新的关键字–enum等； ③“安静的改变”–类型转换和类型提升； 

## 第二章 这不是BUG，是语言特性（C语言本身存在的问题）

1）语言细节决定语言是可靠的还是容易滋生错误；

### 多做之过：

1）fall through（case不加break，就会顺序执行），switch语句会带来麻烦，break与多重判断和循环嵌套时候，易混淆；

2）相邻的字符串常量会被自动合并，末尾逗号‘，’；

3）太多缺省可见性—缺省函数名全局可见，extern可加可不加，对应static；

### 误做之过：

1）符号重载—static、extern、void、*、&、<、( )； 

2）运算符优先级问题–有些专家建议在C语言中记牢两个优先级就够了：乘除先于加减，在涉及其他的操作符时一律加括号。 

3）参数计算顺序—为了让编译器充分利用自身架构特点； 

4）gets(char *s)，不检查缓冲区的空间，而fgets(char *s, int n, FILE *stream)可以对读入的字符数设置一个上限n。fgets对缓冲大小进行限制的方式，更为安全。

### 少做之过：

1）空格—转义字符； 2）注释； 小结：即使可以保证你的编程语言100%可靠，你仍然可能成为算法中灾难的牺牲品。

## 第三章 分析C语言的声明

01 C语言声明的语法 1）“声明的形式和使用的形式相似”：如int *p[3]，使用时候*p[i] 2）存储类型说明符（storage-class）：extern，static， register，auto，typedef 3）类型限定符（type-qualifier）：const，volatile 4）“在函数调用时，参数按照从右到左的次序压到堆栈里”这种说法过于简单，参数在传递时首先尽可能地存放到寄存器中（追求速度） 02 组合声明 1）结构体：struct 结构标签（可选） { 类型 标识符； …… } 变量定义（可选）； 结构中允许存在位段、无名字段以及字对齐所需的填充字段； 位段的类型必须是int，unsigned int 或 signed int（或加上限定词）。

```
struct pid_tag {
          unsigned int inactive : 1;
          unsigned int : 1; // 1个位的填充
          unsigned int refcount : 6;
          unsigned int : 0; //填充到下一个字边界
          short pid_id;
          struct pid_tag *link;
 }
```

结构体变量最好不要省略关键字struct，容易阅读。 2）联合：外表和结构体很相似，内存布局上不同。 ①节省存储空间 ②提取单独的字节字段（联合不需要额外的赋值和强制类型转换，同一个数据可解释为两个不一样的东西）

```
union bits32_tag {
          int whole;  /* 一个32位的值 */
          struct {char c0, c1, c2, c3;} byte;  /* 4个8位的字节 */
} value;
```

3）枚举：把一串名字和一串整型值联系在一起。 ①缺省情况下，整型值从0开始，如果对列表某个标识符赋值了，那么紧挨后的标识符的值就比它大1，以此类推。 ②枚举名字通常一直在调试器中可见。 

03 优先级 规则：

```
A. 声明从它的名字开始读取，然后按照优先级顺序依次读取
B. 优先级从高到低依次是:
	B1：声明中被括号扩住的部分
	B2：后缀操作符()表示一个函数 []表示一个数组
	B3：前缀操作符，*表示”指向…的指针”
C. 如果const，volatile后面紧跟类型说明符(如int),则他做用于类型说明符，否则作用于它左边紧邻的指针星号
如分析：char * const *(*next) ();
```

04 typedef 和define 1）typedef：并不是创建一个新的变量，而是宣称这个名字是指定类型的同义词；复杂函数声明 2）Typedef缺点：容易将多个声明器塞进一个声明中； 3）Typedef不能对定义的类型名进行扩展；可以保证连续定义的几个变量属于同一类型 

05 typedef struct foo{…foo;}的含义 

1）C语言中存在多种名字空间： 标签名（label name) 标签（tag） 成员名 其他 

2）结构标签、结构类型、结构变量 对于typedef struct baz {int baz;} baz; 即相当于 typedef struct baz {int baz;} baz_type; typedef声明引入了baz_type作为struct baz {int baz;}的简写形式 struct baz xxxxx; 使用的是结构标签 baz yyyyy; 使用的是结构类型 小结：应该始终在结构的定义中使用结构标签，可以使代码更为清晰。

## 第四章 数组和指针并不相同

01 数组并非指针 1）对编译器而言，一个数组就是一个地址，一个指针就是一个地址的地址； 2）char *p = “abcdefgh”; …p[3] 先取符号表中p的地址；提取存储于此处的指针；把偏移量和指针相加，产生一个地址；访问这个地址，取得内容； 3）char a[] = “abcdefgh”; …a[3] 先取符号表中a的地址；把偏移量和这个地址相加，产生一个地址；访问这个地址，取得内容 4）注意两者区别：extern int *x;和extern int y[] 区别------声明x为int型指针，y为int型数组，长度未确定，存储在别处定义 02 声明和定义 1)声明相当于普通的声明：它所说明的并非本身，而是描述其他地方的创建的对象 2)定义相当于特殊的声明：它为对象分配内存 3)定义是声明的特殊情况，它分配内存空间，并可能提供一个初始值 03 左值 1）分类：可修改的左值（允许出现在复制语句左边）和不可修改的左值 2）数组名是左值，但不能作为赋值的对象（左值即为可取地址的值），编译器为每隔对象（变量）分配一个地址（左值） 3）左值在编译时候才知道，右值是存储地址内容的，在运行时才可知 4）举例，取得extern chara[10]的值和extern char *p的值，过程不一样–偏移，取地址的地址 04示例说明图 ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1700210789485-140.png)![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113875-14-1700210789485-141.png)![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113875-15-1700210789485-142.png)

05 其他（与第九章结合） 1）在C语言中，所有非数组形式的数据均以传值形式调用 2）多维数组初始化时，可省略最左边下标的长度（也只能是最左边），如int rhubarb = { {0, 0, 0}, {1, 1, 1},}; 3）指针数组就是Iliffe向量, char *pea[4] 4）指针数组必须用指向为字符串而分配的内存的指针进行初始化 5）“数组名被改写成一个指针参数”规则并不是递归定义的。数组的数组会被改写成为“数组的指针”，而不是“指针的指针” 6）向函数传递一个一位数组：增加一个额外的参数或者赋予数组最后一个元素一个特殊的值 7）向函数传递一个普通的多维数组：必须提供除了最左边一维以外多有维的长度。即多维数组最主要的一维长度不必显式书写

## 第五章 对连接的思考

### 编译器的组成：

预处理器（preprocessor）、语法和语义检查器（syntactic and semantic checker）、代码生成器（code generator）、汇编程序（assembler）、优化器（optimizer）、链接器（linker）。

### 使用和查看

1）-#选项查看编译过程的各个独立阶段 2）通过给编译器驱动器一个特殊的-W选项（表示传递这个选项到那个阶段）向各个阶段传递选项信息，如cc -W1, -m mainc > main.linker.map，其中-m选项是传递给链接-载入器的，要求其产生连接器映像

### 动态链接

1）动态链接：执行文件只是包含了文件名，让载入器在运行时能够寻找程序所在的函数库。 2）动态链接目的：动态链接的主要目的就是把程序与它们使用的特定函数库版本中分离出来。这种介于应用程序和函数库二进制可执行文件所提供的服务之间的接口，称之为二进制接口（Application Binary Interface, ABI） 3）函数库：libc（C运行时库）, libsys（其他系统函数）, libX（X Windowing), libnsl（网络服务） 4）创建：动态链接库，可由ld创建，后缀名约定以.so结尾，表示shared object，简单的可以通过cc的-G选项来创建 5）优点：体积小、共享单独的拷贝、函数库的版本升级更为容易

### 静态库

1）概念：函数的一份拷贝是可执行文件的物理组成部分 2）创建：静态库称作为archive，通过ar来创建和更新，后缀名约定以.a结尾 生成示例

```
cc -o libfruit.so -G tomoto.c
```

使用示例

```
cc test.c -L/home/swf -R/home/swf -lfruit, -L, -R 分别告诉链接器在链接和运行时从哪个目录找需要链接的函数库
```

### 函数库链接的秘密

1）动态库文件的扩展名是“.so”,而静态库文件名是“.a” 

2）传给C编译器的命令行参数里并没有提到函数的完整路径名。他甚至没有提到在函数库目录中该文件的完整名字； -lthread选项告诉编译链接到libthread.so，即libname.so对应于-lname

3）编译器期望在确定的目录找到库； 链接时一般使用-Lpathname，-Rpathname，默认读取系统变量LD_LIBRARY_PATH和LD_RUN_PATH等 4）观察头文件，确认所使用的函数库； ①头文件的名字通常并不与它所对应的函数库名相似。 ②函数库包含许多函数的定义，但这些函数的原型声明却散布于多个头文件中 

![在这里插入图片描述](./C语言高级特性(三剑客总结)/2020041817135484-1700210789485-143.png) 5)与提取动态库中的符号相比，静态库中的符号提取方法限制更严。

注意：始终将-1函数库选项放在编译命令行的最右边，很多人习惯<命令><选项><文件>，但链接器采用这个容易引起混淆。 nm工具可列出函数库中包含的函数, nm libc.so | grep xdr_reference 06 Interpositioning 就是就是通过编写与库函数同名的函数来取代该库函数的行为（与C++多态类似）。

## 第六章 运动的诗章：运行时数据结构

### 学习运行时系统目的：①优化代码，②理解其他，③分析问题

### a.out：

1）assembler output汇编程序输出缩写，实际为链接器输出 2）UNIX中可执行文件是以一种特殊的方式加上标签的，这样系统就能够确认它的属性。 ①为重要的数字定义标签，用独特的数字唯一地标识数据，是一种普遍采用的编程技。 ②标签所定义的数字通常被称为“神奇”数字 ③ELF （Executable and Linking Format）可执行文件和链接格式。UNIX中可man a.out 查看有关UNIX系统所使用的格式的信息。

### 段segments

1）概念： ①unix中，段表示一个二进制文件相关的内容块 ②Intel x86的内存模型中，段表示一个设计的结果，其中地址空间并非一个整体，而是分成了一些64K大小的区域，称之为段。 2）size a.out可查看可执行文件中的三个段大小（数据段data，文本段text，bss段） 3）BSS段这个名字是“Block Started by Symble” 由符号开始的块的缩写，其不保存在目标文件中（除了记录BSS段在运行时所需要的大小）。 4）查看可执行文件的内容，nm和dump工具也可以 5）各个段保存内容 ①　数据段保存在目标文件中，存储初始化的全局和静态变量以及它们的值 ②　BSS段不保存在目标文件中（除了记录BSS段在运行时所需要的大小） ③　文本段是最容易受优化措施影响的段，存储可执行文件的指令 ④　a.out文件的大小受调试状态下编译的影响，但段不受影响 局部变量不进a.out，他们在运行时创建。 6）操作系统里段就是一片连续的虚拟地址

### 操作系统在a.out里干了什么

1）文本段包含程序的指令，链接器把指令直接从文件拷贝到内存，以后再也不管它 2）数据段保存初始化的全局变量和静态变量以及它们的值，一般情况下，任何进程中数据段是最大的段 3）堆栈heap，保存局部变量、临时数据、传递到函数中的参数等。 4）可执行文件在内存中布局： ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113875-16-1700210789485-144.png)

### 运行时的a.out（可执行文件）

1）运行时数据结构：堆栈、活动记录、数据、堆 

2）堆栈段有三个主要用途：①为函数内部声明的局部变量提供存储空间；②进行函数调用时，堆栈存储与此相关的一些维护信息；③堆栈也可以被用作暂时存储区； 

函数调用： 

1）过程活动记录：可能不一定位于堆栈中，可能在寄存器中—提高速度； 

2）头文件/usr/include/sys/frame.h描述了过程活动记录在unix系统中的样子 

3）悬挂指针dangling pointer 

关键字auto和static 

1）static 可保证数据存在数据段中而不是堆栈中 2）auto 对于程序员来说，基本用不上，通常由编译器设计者使用，用于标记符号表的条目——它表示“在进入该块之后，自动分配存储”（与编译时静态分配或在堆上动态分配不同）  

控制线程 

1）setjmp()和longjmp()是通过操作过程活动记录来完成的，其在C++中变异为更普通的异常处理机制catch和throw 

2）goto语言不能跳出C语言当前的函数 

3）longjmp()可以跳回到曾经到过的地方 4）setjmp()/longjmp()最大的用途是错误恢复

### C语言工具

检查源码的工具、检查可执行文件的工具、帮助调试工具、性能优化工具

### 优化代码技巧

消除循环；函数代码就地扩展；公共子表达式消除、改进寄存器分配、省略运行时对数组边界的检查、循环不变量代码移动（loop-invariant code motion）、操作符长度削减（指针操作符转变为乘法操作，把乘法操作转变为位移操作或假发操作）。

### 其他

1）8086中有代码寄存器CS，数据寄存器DS，堆栈寄存器SS 

2）磁盘制造商都是采用十进制数而不是二进制数来表示磁盘的容量

3）/usr/ucb/pagesize可查看系统中页面大小，页就是操作系统在磁盘和内存之间移来移去或进行保护的单位。 

4)用于管理内存的调用是： ①malloc 和 free —— 从堆中获取内存以及把内存返回给堆 ②brk 和 sbrk —— 调用数据段的大小至一个绝对值

## 第七章 对内存的思考

### Intel 80x86系列

内存技术： ①虚拟模式—段寄存器不与偏移地址相加，而是为一个存放实际段地址的表提供索引，也称位保护模式 ②Intel 8086寻址模式

### Intel 80x86内存模型以及工作原理

#### 虚拟内存

1）提出：物理内存限制程序 2）原理：把暂时不用的数据搬到硬盘上，节约物理内存多层存储 3）内存媒介：磁带、磁盘、内存、cache存储器、CPU存储器（速度加快，价格高） 4）管理：CPU—MMU内存管理单元—虚拟地址—物理内存—物理磁盘。 ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113876-17-1700210789485-145.png)

### Cache存储器

1）多层存储器的扩展：容量小、速度快、价格高，位于cpu和内存之间，极快的缓冲区；

 ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113876-18-1700210789485-147.png)

### 数据段和堆

1）堆：用来完成数据段对象自动增长的任务，类似于堆栈自动增长

2）堆向下增长，由程序员动态分配malloc，为了圆整一般取2的乘方，堆的末端由一个break指针标识 

3）堆的位置 ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113876-19-1700210789485-146.png)

### 内存泄漏–堆

1）问题：①内存损坏—释放或改写正在使用的内存；②内存泄漏—未释放不再使用的内存； 

2）检测内存泄漏：swap查看可用交换空间-确定可疑进程

### 总线错误

1）总线错误：未对齐的读写问题-----字节对齐问题，未对齐内存访问，地址总线阻塞 

2）段错误：内存管理错误，指针非法值 

3）微妙：导致指针具有非法值通常由于变成错误引起，段错误像是间接症状；更微妙是未初始化指针恰好未对齐，会报总线错误而不是段错误。Cpu先看到地址，再发送给MMU 4)常见错误：①坏指针-未赋值就引用，②改写—越界读写，③-指针释放-同一块释放两次

## 第八章 为什么程序员无法分清万圣节和圣诞节

01 “寻常算术转换” 

1）小于int或double的的表达式：如printf(“%d”, sizeof ‘A’);----4 

2）类型提升：整形提升，除了float会到double 

3）参数也会类型提升：也是为何%d能适用几个不同类型short, char, int。 

4）注意点：隐式类型转换期初为了简化编译器 

原型之痛

1）主要风格：K&R C和 ANSI C 

2）问题：声明和定义不相符，容易混淆结果—实参和形参与期望不相符。 

03 不按回车符就得到一个字符 

1）Unix下一锅端，利于整行的输入 

2）I/O函数可供调用回显输入 

04 强制类型转换 

1）目的：消除歧义，类型转换，如(float) 3和(float) 3.0 

2）复杂类型转换：合理去除标识符和限定符

## 第九章 再论数组

### 01 数组和指针不相同的场景：

声明时候：有区别 1）数组的声明：外部数组声明，数组定义，函数参数声明。 2）注意相同情况：所有作为函数参数的数组名总是可以通过编译器转换为指针。 3）不同：其他情况都必须分开，决不能“一个文件定义为数组，在另一文件声明为指针”。

### 使用（语句或表达式引用中）时候：数组总是可以写成指针的形式，两者可以互换。

什么时候数组和指针相同：三个规则 1）“表达式中的数组名”就是指针； 2）C语言把数组下表作为指针的偏移量； 3）“作为函数参数的数组名”等同于指针

### 为什么C语言把数组当作形参

1）出于效率的考虑 \

2）数组/指针实参的一般用法 

3)数组名不可以被赋值，指针可以-指针变量，数组名一旦声明，不能改变

![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113876-20-1700210789485-149.png) 



### 数组和指针可交换性的总结

1）a[i]被编译器“改写”成*(a+i) 

2）指针始终是指针，可以用下标形式访问，但绝不可以写成数组； 

3）作为函数参数时候，数组声明可以看成指针 

4）函数参数，可以定义为指针或数组 

5）其他情况，声明和定义必须分开。若定义了数组，则在其他文件里对它声明也要为数组。

### 多维数组

1）存储：连续存储 2）分解：从最左边开始，逐层分解 3）数组初始化：长度和值的初始化 尤其注意二维字符串数组初始化的特殊性，与二维其他数组（如int)型数组不同。

## 第十章 再论指针

### 多维数组内存布局

1）说明：多维数组在编程中并不多见 2）布局：并非是想表格一样在各行中排列，而是线性的排布，如图： ![在这里插入图片描述](./C语言高级特性(三剑客总结)/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJsZXNKaG9uc29u,size_16,color_FFFFFF,t_70-1695520113876-21-1700210789485-148.png)![在这里插入图片描述](./C语言高级特性(三剑客总结)/20200418171647946-1700210789485-150.png)

### 指针数组是Iliffe向量

1）通过声明一个一维指针数组，其中每个指针指向一个字符串来取得类似二维数组的效果 2）小标方括号优先级高于星号：注意 char *p[23]和（char *）p[23]不同 3）squash[5](typora://app/typemark/window.html#)的四种形式： int squash[23](typora://app/typemark/window.html#); // int *squash[23]; //指针数组 int **squash; //二重指针 int (*squash)[12]; //数组指针 4）数组的数组和多维数组： 前者char a[5](typora://app/typemark/window.html#)表示a是一个包含4个元素的数组，每个元素是一个char型的数组。 后者char *p[4]表示p是一个字符串指针数组，包含4个元素的数组，每个元素为一个指向char的指针。

### 锯齿状数组–字符串指针数组

1）优点：各行长度可以不一样；可以向函数传递一个字符串数组； 2）数组和指针：编译器解析时候会将数组的数组改写为“数组的指针”； ![在这里插入图片描述](./C语言高级特性(三剑客总结)/20200418171806947-1700210789485-151.png) 实际情况：*(*(p + i) + j)

使用指针向函数传递一个多维数组：如将二维数组改写成一个指向向量的指针数组

使用指针从函数返回一个数组：不能返回指向局部变量的指针

NULL使得printf崩溃：因为C规定%s说明符的参数必须是指向字符串的指针

使用指针创建和使用数组：

注意const常量不能用在类似于case后以及数组下标a[]

## 第十一章 你懂C，C++不在话下

### 初识OOP

1）OOP（object-oriented- paradigm）：面向对象编程模型 2）特点：继承–类的派生、动态绑定–虚拟函数 3）术语： 抽象（abstraction）：去除对象不重要的细节过程，只保留对象关键点。设计活动 类（class）：用户定义的类型，类似于int，struct 对象（object）：某个类的特定变量，也称类的实例 封装（encapsulation）：把类型、数据、函数组合在一起，组成类。C的头文件 继承（inheritance）：允许类从一个更简单的基类中接收数据结构和函数

### 抽象

1）抽象–>面向对象设计–>面向对象编程 2）抽象：只记录能表现事物关键特征数据；本质特征；“黑盒子”；分工‘代码重用和共享；

### 封装

1）自上而下：把用户定义的类型中各种数据和方法组合在一起 2）自下而上：把各种数据和方法组合在一起实现一种用户定义类型 3）类：把代码和相关数据封装（捆绑）在一起

### 类 和 访问控制

1）类：用户定义类型+所有对该类型进行的操作 2）类实现形式：一个包含多个数据的结构+对这些数据进行操作的函数指针 3）编译器实行强类型：即该类型的数据只能进行该操作 4）访问控制关键字：public–外部可见，protected–该类的函数以及该类派生类的函数，private–只能被该类成员函数使用-外部可见但不可用，friend–不属于该类，但可以访问该类，virtual–虚拟函数

### 声明

1）类声明：就是正常的C声明，包括函数、类型、数据 2）注释：始于//，止于行尾 3）成员函数在外部实现：前缀:: 4）成员函数的调用：附上类名，如 melon.slice() 5）构造函数和折构函数：初始化和垃圾清理

### 继承

1）单继承：唯一基类 2）区别“类嵌套”和“类继承”：继承是类的变型 3）多重继承：

### 重载

1）概念：就是重复使用一个现存的名字 2）对象：函数名、操作符 3）编译时进行解析

### C++如何进行操作符重载

1）先定义操作原型----->为重载的操作符提供一个函数体

### C++的I/O

1）C++有自己的库，提供I/O接口 2）操作符：<< >>

### 多态

1）概念：一个函数或操作符只有一个名字，但可以用于几个不同的派生类型的能力；

 2）运行时决定用哪个成员函数，“后期绑定”； 

3）关键字：virtual 

4）与interposing有几分类似 

5）其他：模板template，异常exception，内联inline，new和delete，传引用调用call-by-reference

# 第2章 基本概念

## 2.1 环境

- ANSI C存在两种不同的环境
  - 翻译环境：源代码被转换为可执行的机器指令
  - 执行环境：用于实际执行代码
- 两种环境不必位于同一台机器上，例如交叉编译器

### 2.1.1 翻译

- 翻译分为以下几个步骤，图2.1描述了这个过程
  - 组成一个程序的每个（可能有多个）源文件通过编译过程分别转换为目标代码（object code）
  - 各个目标文件由链接器捆绑在一起，形成一个单一而完整的可执行程序。链接器会引入标准C库中的函数和程序员个人的程序库

![图2.1 编译过程](./C语言高级特性(三剑客总结)/img_2_1-1700210789486-153.png)

- 编译也分为以下几个步骤
  - 预处理器处理，在源代码上执行一些文本操作，例如`#define`和`#include`指令的执行
  - 源代码解析，这个阶段产生绝大多数错误和警告信息，随后产生目标代码
  - 优化器对目标代码进行进一步处理，提升效率

#### 一、文件名约定

- C源代码以`.c`扩展名保存，头文件使用`.h`扩展名保存
- 目标文件名：在UNIX中扩展名为`.o`，在MS-DOS中为`.obj`

#### 二、编译和链接

- 在UNIX中，C编译器被称为cc
- cc有以下几种方法调用：
  - 编译并链接一个完全包含一个源文件的C程序：`cc program.c`，该命令会产生a.out可执行文件，中间会生成program.o目标文件，但在链接过程完成后会被删除
  - 编译并链接几个C源文件`cc main.c sort.c lookup.c`，当源文件超过一个时，目标文件便不会被删除
  - 编译一个C源文件，并把它和现存的目标文件链接在一起`cc main.o lookip.o sort.c`
  - 编译单个C源文件，并产生一个目标文件（本例中为program.o）：`cc -c program.c`
  - 编译几个C源文件，为每个文件产生一个目标文件：`cc -c main.c sort.c lookup.c`
  - 链接几个目标文件：`cc main.o sort.o lookup.o`
- 以上的cc命令还可以加上`-o name`使链接器把可执行程序保存在`name`文件中，而不是`a.out`
- MS-DOC与UNIX不同：
  - 它的名字是bcc
  - 目标文件的名字是file.obj
  - 当单个源文件被编译并链接时，编译器并不删除目标文件
  - 在缺省情况下，可执行文件以命令行第一个源或目标文件名命名，可以使用`-e name`把可执行程序命名为`name.exe`

### 2.1.2 执行

- 执行过程分为：
  - 程序载入内存，由操作系统完成，那些**不是存储在堆栈中**的尚未初始化的变量将在这个时候得到初始值
  - 执行开始，执行小型启动程序，完成系列日常任务，然后调用main函数
  - 开始执行程序代码
  - 程序终止，“正常”环境的终止就是main函数的返回

## 2.2 词法规则

### 2.2.1

- 三字母词：就是几个字符的序列，合并起来表示另一个字符，如下图所示：

![图2.2 三字母词](./C语言高级特性(三剑客总结)/img_2_2-1700210789486-152.png)

- 转义序列（escape sequence）或字符转义（character escape），由反斜杠`\`加上一或多个其他字符组成

```
//转义字符
    \? 在书写连续多个问号时使用，防止它们被解释为三字母词
    \" 用于表示一个字符串常量内部的双引号
    \' 用于表示字符常量`
    \\ 用于表示一个反斜杠，防止它被解释为一个转义字符
    \a 警告字符，它将奏响终端铃声或产生其他一些可听见或可看见的信息
    \b 退格键
    \f 进纸字符，换页
    \n 换行符
    \r 回车符
    \t 水平制表符
    \v 垂直制表符
    \ddd ddd表示1~3个八进制数字，表示的字符就是给定的八进制值所代表的字符
    \xddd 与上类似，表示十六进制
```

### 2.2.2 注释

- 注释不能嵌套于另一个注释中

### 2.2.3 自由形式的源代码

- 预处理是以行定位的

## 2.3 程序风格

- 在函数定义中，返回类型出现于独立的一行中，而函数名则在下一行的起始处

## 2.4 总结

- 一个函数只能完整地出现在另一个源文件中
- 程序必须载入内存中才能执行，在宿主式环境中，这个任务由操作系统完成；在自由式环境中，程序常常永久存储于ROM中
- 经过初始化的静态变量在程序执行之前能获得它们的值
- 注释将被预处理器去除
- 标识符由字母、数字和下划线组成，但不能以数字开头

## 2.5 警告的总结

- 字符串常量中的字符被错误地解释为三字母词

# 第3章 数据

- 作用域、链接属性 —> 可视性（可以在什么地方使用）
- 存储类型 —> 生命期（值将保持多久）

## 3.1 基本数据类型

- 4种基本数据类型：整型、浮点型、指针和聚合类型（数组、结构）

### 3.1.1 整型家族

- 1.整型家族包括字符、短整型、整型和长整型，又分为有符号和无符号
  - a.字符：char、signed char、unsigned char（char和unsigend char长度不一样的）
  - b.短整型：short int（至少16位）、unsigned short int
  - c.整型：int、unsigned int
  - d.长整型：long int（至少32位）、unsigend long int
- 2.长度比较：`长整型 >= 整型 >= 短整型`
- 3.头文件limits.h说明了各种不同的整型类型的特点：变量范围的限制
- 4.char类型变量在本质上是小整型值
- 5.缺省的char要么是sigend char，要么是unsigend char，这取决于编译器
- 6.char变量的值位于sigend char和unsigend char的交集中，这个程序才是可移植的
- 7.移植问题：最佳方案是将char限制在sigend char和unsigend char交集内，并且只有char显示声明为sigend或unsigend时才对它执行算术运算

#### 一、整型字面值

- 字面值是字面值常量的缩写，区分与常量

- 整型字面值属于哪种类型，取决于字面值是如何书写的，可以通过添加一个后缀来改变缺省的规则

- 在整数字面值后面添加L或l使这个整数解释为long整型值；U或u解释为unsigned整型值；可两个一起用

- 十进制整型字面值可能是`int、long或unsigend long`，缺省是它最短类型但能完整容纳这个值

- 八进制和十六进制整型字面值可能是`int、unsigend int、long或unsigend long`，，缺省是它最短类型但能完整容纳这个值

- 字符常量的类型总是

  ```
  int
  ```

  ，不能添加unsigned或long后缀

  - 字符常量就是用一个单引号包围起来的单个字符（或字符转义序列或三个字母）例子在P31
  - 多字节字符常量的前面有一个L，那么它就是宽字符常量

#### 二、枚举类型

- 枚举类型就是指它的值为符号常量而不是字面值的类型
- 声明枚举类型:`enum Jar_Type { CUP, PINT, QUART }`
- 声明枚举类型的变量：`enum Jar_Type mikl_jug;`
- 匿名枚举类型声明

```
    enum { CUP, PINT, QUART }
        mikl_jug;
```

- 枚举类型实际上是整型方式存储，CUP是0，PINK是1
- 同时也可以给符号名赋值，如果某个符号名赋值了，但下一个没赋值，那么这个没赋值的符号名就比上一个赋值了的符号名的值大1

### 3.1.2 浮点类型

- 非整数或数远远超出了计算机整数所能表达的范围，可以用浮点数的形式存储
- 浮点数通常以一个小数以及一个以某个假设数为基数的指数组成
- 包括float、double、long double，表示单精度、双精度、扩张精度
- 长度比较：`float >= double >= long double`
- 所有浮点至少能容纳从`10E-37`到`10E37`之间的任何值
- float.h定义了浮点数家族的最大值、最小值
- 浮点字面值总是写成十进制的形式，必须有小数点或一个指数，或两个都有
- 浮点数字面值在缺省情况下都是double，除非跟了L或l（long double）和F或f（float）

### 3.1.3 指针

- 每个内存位置都由地址唯一确定并引用
- 指针只是地址的另一个名字
- 指针变量就是一个其值为另外一个（一些）内存地址的变量

#### 一、指针常量

- 指针常量与非指针常量在本质上是不同的
- 通过操作符获得一个变量的地址而不是直接把它的地址写成字面值常量的形式
- 指针常量表达式为字面值的形式几乎没有用处，所以C内部并没有特定第定义这个概念
- 例外：NULL指针，它可以用零值来表示

#### 二、字符串常量

- C不存在字符串类型，但C提供了字符串常量
- 字符串的概念：以NUL字节结尾的0个或多个字符
- 字符串通常存储在字符数组中
- 字符串内部不能有NUL字节
- 字符串常量的书写方式是用一对双引号包围一串字符`"Hello"`
- 字符串常量（不像字符常量）可以是空的，但是依然有NUL字节终止
- K&R C的字符串常量
  - 具有相同值的不同字符串常量在内存中是分开存储的
  - 编译器允许程序修改字符串常量
- ANSI C的字符串常量
  - 对一个字符串常量进行修改，其效果未定义
  - 它允许编译器把一个字符串常量存储于一个地方
  - 修改字符串常量很危险
  - 许多ANSI编译器不允许修改字符串常量
  - 如果需要修改字符串，请把它存于数组中
- 字符串常量会生成一个“指向字符的常量指针”
- 字符串常量出现在表达式中，表达式所使用的值是字符存储的地址
- 把字符串常量赋给一个“指向字符的指针”
- 不能把字符串常量赋给一个字符数组，因为字符串常量的直接值是一个指针，不是这些值本身

## 3.2 基本声明

- 在声明整型变量时，如果声明中已经至少有了一个其他的说明符，关键字int可以省略`unsigend short int a;`和`unsigned short a;`是相等的

- signed一般只用于char，因为其他类型在缺省情况下都是有符号数

- 相等的整型声明：

  - 表格：

  | signed                                                   | unsigend                               |
  | :------------------------------------------------------- | :------------------------------------- |
  | `short`、`signed short`、`short int`、`signed short int` | `unsigned short`、`unsigned short int` |
  | `int`、`signed int`、`sigend`                            | `unsigned int`、`unsigned`             |
  | `long`、`signed long`、`long int`、`signed long int`     | `unsigend long`、`unsigned long int`   |

### 3.2.1 初始化

### 3.2.2 声明简单数组

- 编译器并不检查程序对数组下标的引用是否在数组的合法范围之内

### 3.2.3 声明指针

- 声明指针应该`int *a;`而不应该`int* a;`
- 因为在`int* b,c,d;`会让人误以为b、c、d都是指针，其实这里只有b是指针，应该为`int *b,*c,*d;`

### 3.2.4 隐式声明

- 函数如果不显示地声明并返回值的类型，默认返回整型
- 旧风格声明函数的形式参数，如果忽略了参数的类型，默认为整型
- 编译器能得到足够信息，推断出一个语句是一个声明时，如果缺少类型名，会假设为整型
- 例子 P37

## 3.3 typedef

- typedef机制允许你为各种数据类型定义新名字

```
    typedef char *ptr_to_char;   //ptr_to_char作为指向字符的指针类型的新名字
    ptr_to_char a;   //a是一个指向字符的指针
```

- `#define`不法正确处理指针类型

```
    # define d_ptr_to_char  char *
    d_ptr_to_char a,b;  //这里只有a是字符指针，而b只是字符
```

- 复杂的类型名，如函数指针和指向数组的指针，使用typedef更合适

## 3.4 常量

- const关键字声明常量，`int const a;`和`const int a;`都可以
- 常量如何拥有一个值
  - 声明时对它进行初始化，`int const a = 15;`
  - 形参在函数调用时会得到实参的值
- 关于指针（const往前结合）

```
    int *pi;  //普通的指向整型的指针
    int const *pci;  //指向整型常量的指针
    int * const cpi;  //指向整型的常量指针
    int const * const cpci;  //指向整型常量的常量指针
```

- `#define`也可以创建名字常量`#define MAX 50`和`int const max = 50`一样

## 3.5 作用域

- 标识符的作用域就是程序中该标识符可以被使用的区域
- 4种作用域：文件作用域、函数作用域、代码块作用域、原型作用域
- 标识符声明的位置决定它的作用域

### 3.5.1 代码块作用域

- 花括号之间的所有语句称为一个代码块
- 任何在代码块开始位置声明的标识符都具有代码块作用域
- 代码块嵌套时，标识符同名，内层标识符隐藏外层标识符
- `k&R C`函数形参作用域开始于形参的声明处，位于函数体外，局部变量可以隐藏形参
- `ANSI C`形参作用域为函数最外层的那个作用域（整个函数体），局部变量不可能隐藏形参

### 3.5.2 文件作用域

- 代码块之外声明的标识符具有文件作用域
- 文件作用域：表示从标识符声明处起到源文件结尾都是可以访问的
- 文件中定义的函数名也具有文件作用域
- `#include`包含到其他文件中的声明就好像直接写在那些文件中一样，它们的作用域不局限于头文件的文件文件尾

### 3.5.3 原型作用域

- 原型作用域只适用于在函数原型中声明的参数名
- 原型中的参数名不必与函数定义中的参数名匹配

### 3.5.4 函数作用域

- 函数作用域只适合于语句标签
- 语句标签用于goto语句
- 函数作用域可以简化为一条规则：一个函数中的所有语句标签必须唯一

## 3.6 链接属性

- 标识符的链接属性决定如何处理在不同文件中出现的标识符
- 标识符的作用域和它的链接属性有关
- 3种：external、internal、none
- 没有链接属性的标识符(none)：总是当作独立的个体
- internal：同一个源文件内的所有声明都是指向同一个实体
- external：无论声明多少次，位于几个源文件都是表示同一个实体
- 函数定义中的函数调用a，a的链接属性是external，它实际链接到其他文件所定义的函数，或某个函数库



- 关键字`extern`和`static`用于声明中修改标识符的链接属性
- 具有external链接属性的标识符，加上static，变为internal
- static只对缺省属性为external的声明才会有改变链接属性的效果
- extern为一个标识符指定external链接属性
- extern用于标识符的第1次声明时，它指定标识符具有external链接属性；用于标识符的第2次或以后的声明时，不会改变第一次声明所指定的链接属性

```
    static int i;  //声明1
    int func()
    {
        extern int i; //不修改由声明1所指定的变量i的链接属性
    }
```

## 3.7 存储类型

- 变量的存储类型是指存储变量值的内存类型：普通内存、运行时堆栈、硬件寄存器
- 存储类型决定变量何时创建、何时销毁和值保持多久
- 变量的缺省存储类型取决于它的声明位置
  - 代码块之外缺省：静态内存，称为静态（static）变量
  - 代码块内部缺省：堆栈中，称为自动（auto）变量
- 在代码块内部声明的变量，加上`static`，自动变为静态（修改变量的存储类型不代表修改变量的作用域）
- 形式参数不能声明为静态
- `register`可以用于自动变量的声明，提示应该存储于硬件寄存器中，称为寄存器变量，但编译器不一定理睬
- 可以把函数的形式参数声明为寄存器变量
- 寄存器变量的创建和销毁时间和自动变量相同，但需要做一些额外工作：恢复先前存储的值

### 初始化

- 静态变量的初始化可以把初始化的值放在程序执行变量将会使用的位置，不显示地指定其初始值，静态变量将初始化为0
- 动态变量没有缺省值，如果不显示初始化，那么它们的值总是垃圾

## 3.8 static关键字

- static的作用
  - 对于函数定义或代码外之外的变量声明：链接属性`external--->internal`，存储类型和作用域不受影响
  - 对于代码块内部变量声明：存储类型`自动变量--->静态变量`，链接属性和作用域不受影响
- extern的作用
- - 对于代码块内部变量:链接属性`none--->external`，存储类型`自动变量--->静态变量`，说明它所引用的是个全局变量而非局部变量（变量声明可能在别的源文件中）

## 3.9 作用域、存储类型示例

- 对于函数，存储类型并不是问题，因为代码总是存储在静态内存中

## 3.10 总结

- 如果一个变量声明于代码块内部，在它前面添加一个`extern`将使它引用的是全局变量而非局部变量（有可能是别的源文件中的）

- 具有external链接属性的实体总是具有静态存储类型

- 作用域、链接属性和存储类型总结

  - 表：

  | 变量类型 | 声明的位置     | 是否存储于堆栈 | 作用域           | 如果声明为static                                   | 如果声明为extern             |
  | :------- | :------------- | :------------- | :--------------- | :------------------------------------------------- | :--------------------------- |
  | 全局     | 所有代码块之外 | 否             | 从声明处到文件尾 | 不允许从其他源文件访问，变为internal               | —                            |
  | 局部     | 代码块起始处   | 是             | 整个代码块       | 变量不存储于堆栈中，它的值在程序整个执行期一直保持 | 引用的是全局变量而非局部变量 |
  | 形式参数 | 函数头部       | 是             | 整个函数         | 不允许                                             | —                            |

## 3.12 编程提示的总结

- 除了实体的具体定义位置外，在它的其他声明位置都要使用`extern`关键字

# 第4章 语句

- 本章没有什么需要记录的内容

# 第5章 操作符和表达式

## 5.1 操作符

### 5.1.1 算数操作符

- 1.`+ - * / %`
- 2.`%`只能用于整数类型

### 5.1.2 位移操作符

- 1.`<<`左移操作，移出界的丢弃

- 2.

  ```
  >>
  ```

  右移，左边移入新位时有两种方案

  - a. 逻辑移位：左边移入的用0填充
  - b. 算数移位：左边移入的由原先的符号位决定

- 3.位移操作符的两个操作数都必须是整形类型

- 4.无符号值都是逻辑位移，有符号值由编译器决定

- 5.`a << -5`这个位移的值是不可预测的

### 5.1.3 位操作符

- 1.AND、OR、XOR; `&、|、^`

### 5.1.4 赋值

- 1.赋值是表达式的一种，而不是某种类型的语句（没有赋值语句）
- 2.赋值是表达式，所以它就具有一个值，赋值表达式的值就是左操作数的新值，可以作为其他赋值操作符的右操作数，如`a = x = y + 3`,即`a = ( x = y + 3 )`
- 3.`a = x = y + 3`认为a和x被赋予相同的值的说法是错误的，因为可能变量类型不同，比如x是字符型变量，那么y+3的值就会被截去一段，所以以下代码是错误的（具体参照P70）

```
   char ch;
   ...
   while( ( ch = getchar() ) != EOF )...
```

- 4.复合赋值符：`+=、<<=、&=`等等，`a += expression`等于`a += a + ( expression )`

### 5.1.5 单目操作符

```
!、++、-、&、sizeof、~、--、+、*、(类型)
```

- 1.`~`:按位取反
- 2.`-`：负值
- 3.`+`:正值，与`-`相对
- 4.`&`:取地址
- 5.`*`:间接访问操作符，与指针一起用
- 6.`sizeof`:操作数的类型长度，字节为单位;`sizeof (int)`、`sizeof x`;当操作数为数组名时，返回数组的长度，以字节为单位;判断表达式的长度不需要对表达式求值，所以`sizeof( a = b + 1 )`并没有向a赋值
- 7.`(类型)`：强制类型转换
- 8.`++和--`:操作数必须是个“左值”；前缀形式：操作数的值被增加，表达式是操作数增加后的值；后缀形式：操作数的值被增加，表达式是增加前的值；增值操作符都是复制一份变量值的拷贝，用于表达式的值正式这份拷贝，前缀后缀只是复制的时间不一样，因此`++a = 10`是错误的，因为不能向一个拷贝值进行赋值（P73）

### 5.1.6 关系操作符

```
> >= < <= != ==
```

- 这些操作符产生的结果都是整型值1或0，不是布尔值

### 5.1.7 逻辑操作符

```
&& ||
```

- 短路求值

### 5.1.8 条件操作符

```
expression1 ? expression2 : expression3
```

### 5.1.9 逗号操作符

```
,
```

- 逗号操作符将多个表达式分隔开来，这些表达式自左向右逐个进行求值
- `if( b + 1, c / 2, d > 0)`这里看的是`d > 0`

### 5.1.10 下标引用、函数调用和结构函数

- C的下标值总是从0开始，并且不会对下标值进行有效性验证
- 除了优先级不同外，下标引用操作和间接访问表达式是等价的
  - `array[ 下标 ]`和`*( array + ( 下标 ) )`
- `.`和`->`操作符用于访问一个结构的成员，当你拥有一个指向结构体的指针而不是结构体本身时，使用`->`访问它的成员

## 5.2 布尔值

- C不具备显示的布尔类型，使用整数代替
- 零是假，任何非零值为真
- 注意这类写法，flag为1以外的其他非零值，这个if语句也是不执行的：

```
    #define FALSE 0
    #define TRUE 1
    if( flag == TRUE)
```

## 5.3 左值和右值

- 左值就是那些能够出现在复制符号左边的东西，右值同理
- “表达式不能作为左值”这句话是错的：`a[ b + 10 ] = 0`中的左值就是表达式，这些操作符包括间接访问操作符和下标引用

## 5.4 表达式求值

### 5.4.1 隐式类型转换

- 整型升级：字符型加法运算时，会提升为普通整型

### 5.4.2 算术转换

- 寻常算术转化（P80）

### 5.4.3 操作符的属性

- 复杂表达式的求值顺序3个决定因素：操作符的优先顺序、操作符的结合性（`L-R`、`R-L`）、操作符是否控制执行的顺序（`&&`、`||`）
- 操作符优先级表 p81

### 5.4.4 优先级和求值的顺序

- `c + --c`根据编译器的不同会产生不同的结果

## 5.5 总结

- `&&`、`||`和`?:`对求值过程施加控制
- 逗号操作符，整个表达式的值是最右那个子表达式的值
- 各个不同类型之间的值不能直接进行运算，除非其中一个的操作数转换为另一个操作数的类型（寻常算术转换）
- 表达式的结果如果依赖于求值的顺序，那么它在本质上就是不可移植的，应该避免使用（P86）
- 不要混用整型和布尔型值

# 第6章 指针

## 6.1 内存和地址

- 字节：8个位
- 字：许多机器以字为单位存储整数，每个字一般由2个或4个字节组成
- 尽管一个字包含了4个字节，它仍然有一个地址，或是最左边那个字节或是最右边那个字节
- 边界对齐
- 内存中的每个位置都由一个独一无二的地址标识；内存中的每个位置都包含一个值

## 6.2 值和类型

- 不能简单地通过检查一个值的位来判断它的类型，为了判断值的类型，必须观察程序中这个值的使用方式

## 6.3 指针变量的内容

- 一个变量的值就是分配给这个变量的内存位置所存储的数值，要区分与指针的内容

## 6.4 间接访问操作符

- 通过一个指针访问它所指向的地址的过程称为间接访问或解引指针，使用`*`

## 6.5 未初始化和非法的指针

```
    int *a;
    ...
    *a =12;
```

- 是错误的，因为没有对a进行初始化

## 6.6 NULL指针

- 要使一个指针变为NULL，你可以给它赋一个零值
- 为了测试一个指针变量是否为NULL，你可以将它与零值进行比较
- 对一个NULL指针进行解引用操作是非法的

## 6.7 指针、间接访问和左值

- 间接访问操作符所需要的操作数是一个右值，但这个操作符所产生的结果是个左值

## 6.8 指针、间接访问和变量

- `*&a = 25`和`a = 25`从结果上来说是一样的

## 6.9 指针常量

- `*100 = 25`是非法的
- `*(int *)100 = 25`是合法的
- 指针常量通常用来根据已经设备的设备地址来访问设备

## 6.10 指针的指针

- 声明：`int **c`
- 声明为register的指针变量，不可以再使用&取址（P99）

## 6.11 指针表达式

- cp作为字符指针，`++cp`是不能成为左值的，这个运行结果的返回值是原cp指向地址的下1个地址

- cp作为字符指针，`cp--`是不能成为左值的，这个运行结果的返回值是原cp指向的地址

- 对于`*++cp`、`*cp++`、`++*cp`参考P103

- 由于后缀

  ```
  ++
  ```

  的优先级高于

  ```
  *
  ```

  ,所以

  ```
  *cp++
  ```

  分为三步：

  - 1. ++操作产生cp的一份拷贝
  - 1. 然后++操作符增加cp的值
  - 1. 最后，在cp的拷贝上执行间接访问操作

- `++*++cp`、`++*cp++`参考P104

## 6.12 实例

## 6.13 指针运算

- 指针加上一个整数的结果是另一个指针，如果p是个指向float的指针，那么p+1就指向下一个float

### 6.13.1 算术运算

- C的指针算术运算只限于两种形式：1.`指针 +/- 整数`；2.`指针 - 指针`

- ```
  指针 +/- 整数
  ```

  - 标准定义这种形式只能用于指向数组中某个元素的指针
  - 这类表达式的结果类型也是指针

- ```
  指针 - 指针
  ```

  - 只有当两个指针都指向同一个数组中的元素时，才允许一个指针减去另一个指针
  - 结果类型是ptrdiff_t，一种有符号整数类型
  - 减法运算的值时两个指针在内存中的距离，以数组元素的长度为单位，不是以字节为单位
  - ptrdiff_t = 实际内存差 / 数组类型长度
  - 存在`p1 - p2 = 负数`的情况，只要两个指针都指向同一个数组的元素

### 6.13.2 关系运算

- `< <= > >=`
- 前提是指向同一个数组中的元素
- 比较表达式将告诉你哪个指针指向数组中更前或更后的元素

## 6.14 总结

- 无法通过值的位模式来判断它的类型，类型是通过值的使用方式隐形确定的
- 声明一个指针变量并不会自动分配任何内存，在指针执行间接访问前，指针必须进行初始化，或使它指向现有的内存，或给它分配动态内存
- NULL指针执行间接访问操作的后果因编译器而异，常见后果为：返回内存位置零的值或终止程序
- 指针常量：通过把整型值强行转换为指针类型来创建它
- 指针加法运算，如果指针指向数组最后一个元素后面的那个内存位置仍是合法的
- 

## 6.15 警告

- 错误地对一个未初始化的指针变量进行解引用

- 错误地对一个NULL指针进行解引用

- 向函数错误地传递NULL指针

- 未检测到指针表达式的错误，从而导致不可预料的结果

- ## 对一个指针进行减法运算，使它非法地指向了数组第1个元素的前面的内存位置

# 第7章 函数

## 7.1 函数定义

- 函数的定义就是函数体的实现
- 函数声明出现在函数被调用的地方，函数声明向编译器提供函数的相关信息，用于确保函数被正确地调用
- 存根(stub)：应该就是一个空函数。编写这类存根，或者说为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性，以便于你编译和测试程序的其他部分

```
    function_name()
    {
    }
```

- 过程类型的函数：没有返回值
- 真函数：从表达式内部调用的，必须返回一个值，用于表达式的求值

## 7.2 函数声明

### 7.2.1 原型

- 第2种向编译器提供函数信息的方法是使用函数原型（第1种应该是函数定义）
- 使用原型最方便的方法是把原型置于一个单独的文件，使用`#include`指令包含该文件
- `int func( int i );`中`;`区分了函数原型和函数定义的起始部分
- 原型中的参数名字并不是必需的
- 函数原型具有文件作用域，所以原型的一份拷贝可以作用于整个源文件
- 函数原型必须与函数定义匹配
- `int *func()`不能表示一个没有参数的函数的原型，因为旧式风格的有参函数是可以这样声明的，一个没有参数的函数原型应该写成`int *func(void)`

### 7.2.2 函数的缺省认定

- 当程序调用一个无法见到原型的函数时，编译器认为该函数返回一个整型值
- 所有的函数都应该具有原型，尤其是那些返回值不是整型的函数
- 如果编译器认定函数返回一个整型值，它将产生整型数指令操作这个值（如果返回的不是整型值，那将会出错，例子参考P121）

## 7.3 函数的参数

- 1.所有参数均以“传值调用”方式进行传递，这意味着函数将获得参数值的一份拷贝
- 2.数组并不会得到一份拷贝，而是得到数组首地址的一份拷贝，这个行为被称为“传值调用”，因为数组名的值实际上是一个指针，传递给函数的就是这个指针的一份拷贝
- 3.记住两个规则：
  - a.传递给函数的标量参数是传值调用的
  - b.传递给函数的数组参数在行为上就像它们是通过传址调用的那样
- 4.在函数参数声明中，声明数组参数时不指定它的长度是合法的，因为函数并不为数组元素分配内存

## 7.4 ADT和黑盒

- C可以用于设计和实现抽象数据类型（ADT，abstract data type），也被称为黑盒设计
- 抽象数据类型的基本想法：模块具有功能说明和接口说明
- 限制对模块的访问是通过`static`关键字的合理使用实现的，它可以限制那些并非接口的函数和数据的访问

## 7.5 递归

- C通过运行时堆栈支持递归函数的实现，递归函数就是直接或间接调用自身的函数。

```
#include <stdio.h>
void
binary_to_ascii( unsigned int value)
{
	unsigned int quotient;
	
	quotient = value / 10;
	if( quotient != 0 )
		binary_to_ascii( quotient );
	putchar( value % 10 + '0' );
}
```

### 7.5.1 追踪递归函数

- 追踪一个递归函数执行过程的关键是理解函数中所声明的变量是如何存储的，因此可以通过画堆栈图来理解（参考P128的例子）

- 假设调用函数`binary_to_ascii( 4267 );`

- 当函数开始执行时，堆栈的内容如下图所示：

  ```
  步骤1：
  ```

![7.5.1 追踪递归函数图1](./C语言高级特性(三剑客总结)/img_7_5_1_1-1700210789486-155.png)

- 步骤2：

![7.5.2 追踪递归函数图2](./C语言高级特性(三剑客总结)/img_7_5_1_2-1700210789486-154.png)

- 步骤3：

![7.5.3 追踪递归函数图3](./C语言高级特性(三剑客总结)/img_7_5_1_3-1700210789486-156.png)

- 步骤4：

![7.5.4 追踪递归函数图4](./C语言高级特性(三剑客总结)/img_7_5_1_4-1700210789486-157.png)

- 步骤5：

![7.5.5 追踪递归函数图5](./C语言高级特性(三剑客总结)/img_7_5_1_5-1700210789486-158.png)

- 步骤6：

![7.5.6 追踪递归函数图6](./C语言高级特性(三剑客总结)/img_7_5_1_6-1700210789486-159.png)

- 步骤7：

![7.5.7 追踪递归函数图7](./C语言高级特性(三剑客总结)/img_7_5_1_7-1700210789486-161.png)

- 步骤8：

![7.5.8 追踪递归函数图8](./C语言高级特性(三剑客总结)/img_7_5_1_8-1700210789486-160.png)

- 步骤9：

![7.5.9 追踪递归函数图9](./C语言高级特性(三剑客总结)/img_7_5_1_9-1700210789486-162.png)

- 步骤10：

![7.5.10 追踪递归函数图10](./C语言高级特性(三剑客总结)/img_7_5_1_10-1700210789486-164.png)

### 7.5.2 递归与迭代

- 1.递归函数调用将涉及一些运行时开销
  - a.参数必须压到堆栈中
  - b.为局部变量分配内存空间
  - c.寄存器的值必须保存
- 2.因此递归函数的开销是十分大的
- 3.尾部递归：当一个函数在递归调用返回之后不再执行任何任务，这样的递归函数叫尾部递归
- 4.尾部递归可以很方便地转换成一个简单循环，完成相同任务，但开销更小
- 5.迭代实现往往比递归实现效率更高，但代码可读性稍差
- 6.如果一个问题相当复杂，难以用迭代形式实现时，此时递归实现的简便性可以补偿它所带来的运行时开销

## 7.6 可变参数列表

- 1.宏是由预处理器实现的
- 2.可变参数列表是通过宏来实现的，这些宏定义于stdarg.h头文件，它是标准库的一部分
- 3.分别有一个类型`va_list`和三个宏`va_start`、`va_arg`和`va_end`
- 4.参数列表中的省略号提示此处可能传递数量和类型未确定的参数，编写函数原型时，也要使用同样的记法
- 5.可变参数必须从头到尾按顺序逐个访问，半途终止是可以的，但不能一开始就访问参数列表中的中间的参数
- 6.由于可变参数部分没有原型，可变参数传递给函数的值都将执行缺省参数类型的提升（//TODO 不明白什么意思）
- 7.这些宏存在两个基本限制，是由“一个值的类型无法简单地通过检查它的位模式来判断”导致的
  - a.这些宏无法判断实际存在的参数的数量
  - b.这些宏无法判断每个参数的类型
- 8.要回答`7.`中的两个问题，就必须使用命名参数

```
#include <stdarg.h>

float
average ( int n_values, ...)
{
    //用于访问参数列表的未确定部分
    va_list var_agr;
    int count;
    float sum = 0;
    
    //使用va_start来初始化，第1个参数是va_list变量的名字，第2个参数是省略号前最后一个有名字的参数，初始化过程把var_arg变量指向可变参数部分的第1个参数
    va_start( var_agr, n_values );
    
    for( count =0; count < n_values; count +=1 ){
        //访问参数，第1个变量va_list变量，第2个变量，参数列表中下一个参数的类型。va_arg返回这个参数的值，并使var_arg指向下一个可变参数
        sum += va_arg( var_arg, int );
    }
    //访问完毕最后一个可变参数之后，需要调用va_end
    va_end( var_arg );
    
    return sum / n_values;
}
```

## 7.7 总结

- 1.参数列表有两种可以接受的形式：K&R C风格和新风格
- 2.函数声明也有两种可以接受的形式：
  - a.K&C C每个没有参数列表，只声明了返回值的类型
  - b.新风格又称为函数原型，包含了参数列表的声明
- 3.对于那些没有原型的函数，传递给函数的实参将进行缺省参数提升
  - a.char和short转换为int
  - b.float转换为double

# 第8章 数组

## 8.1 一维数组

### 8.1.1 数组名

- 数组名的值是一个指针常量，也就是数组第1个元素的地址，int数组的数组名就是“指向int的常量指针”
- 数组和指针是不相同的，不同的特征：
  - 1.数组具有确定数量的元素，而指针只是一个变量值
  - 2.数组名只有在表达式中使用，编译器才会产生一个指针常量
- 两种场合下，数组名并不用指针常量来表示
  - 1.`sizeof`：返回整个数组的长度
  - 2.`&`:指向数组的指针，而不是指向某个指针常量的指针，也就是说若array为数组名，那么`array == &array`,但也存在区别，看[数组名a和&a的区别](http://blog.csdn.net/wanwenweifly4/article/details/6424058)
- 考虑下面例子：

```
    int a[10];
    int b[10];
    int *c;
    ...
    c = &a[0];  //和 c = a 是一样的；b = a 是非法的； a = c是非法的，a是常量不能修改
```

### 8.1.2 下标引用

- 除了优先级外，下标引用和间接访问完全相同,如下是相同的：

```
    array[ subscript ]
    * ( array + ( subscript ) )
    int array[10];
    int *ap = array + 2;
    
    ap[0]; //对等*(ap+(0))，即array[2]
    *ap+6; //array[2]+6
    ap[-1]; //array[1]
```

- C的下标检查所涉及的开销比你刚开始想象的要多
- `2[array]`是合法的，等于`( 2 + ( array ) )`，就是`*( array + 2 )`,也就是`array[2]`

### 8.1.3 指针与下标

- 下标绝对不会比指针更有效率，但指针有时会比下标更有效率
- 例子 P145

### 8.1.4 指针的效率

- 指针有时比下标更有效率，前提是它们被正确地使用
- 不要为了效率上的细微差别而牺牲可读性
- 可以对指针使用寄存器变量，但是指针必须被声明为局部变量

#### 结论

- 当你根据某个固定数目的增量在一个数组中移动时，使用指针变量比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这点表现更为突出
- 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高
- 如果你可以通过测试一些已经初始化并经过调整的内容来判断是否应该终止循环，那么你就不需要使用一个单独的计数器
- 那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高

### 8.1.5 数组和指针

- 指针和数组并不是相等的
- 声明一个数组时，为数组保留内存空间，再创建数组名，它的值是一个常量，指向这段空间的起始位置
- 声明一个指针变量时，只为指针本身保留内存空间，并不为它分配内存空开，它如果是自动变量，它甚至不会被初始化

### 8.1.6 作为函数参数的数组名

- 传递给函数的是一份该指针的拷贝
- 所有的参数都是通过传值方式传递的
- 无论函数对参数（指针）如何进行修改，都不会修改调整程序的指针实参本身（但可能修改它所指向的内容）

### 8.1.7 声明数组参数

- `int func( char *string )`和`int func( char string[] )`在当前的上下文环境中是相等的，但使用指针声明更为准确
- 对函数中参数指针使用`sizeof string`的值是指向字符的指针的长度，而不是数组的长度
- 数组参数可以与任何长度的数组匹配，这种实现方式使函数无法知道数组的长度

### 8.1.8 初始化

- `int vector[5] = { 1, 2, 3, 4, 5 };`

#### 静态和自动初始化

- 初始化方式：取决于它们的存储类型
  - 静态内存中的数组只初始化1次，未初始化时，自动设为零
  - 自动变量，缺省情况下未初始化
- 对于那些非常庞大的数组，它的初始化时间可能非常可观
- 需要权衡利弊，数组的初始化局部于一个函数（或代码块）时，是不是值得，如果不值得，就把数组声明为static

### 8.1.9 不完整的初始化

- 初始化值的数组和数组元素的数目并不匹配
- 只允许省略最后几个初始值（局部变量也可以，如果最后没有初始化，那么就初始化为0）

### 8.1.10 自动计算数组长度

- 如果声明中并未给出数组的长度，编译器就把数组的长度设置为刚好能容纳所有的初始值的长度

### 8.1.11 字符数组的初始化

- `char m[] = {`H`,`I`};`
- `char m[] = "HI";`,尽管这个看上去是一个字符串常量，实际上不是

```
    char m1[] = "HELLO"; //初始化一个字符数组的元素
    char *m2 = "HELLO"; //真正的字符串常量
```

## 8.2 多维数组

### 8.2.1 存储顺序

- 多维数组的元素存储顺序按照最右边的下标率先变化的原则，称为行主序
- `int matrix[6][10]`是6行10列还是10行6列，都对，只要每次都坚持使用一种方法，这两种解释都是可行的，但并不会改变数组的存储顺序

### 8.2.2 数组名

### 8.2.3 下标

- `matrix[x][y]`等于`*( *( matrix + x) + y )`
- `&matrix[0][0]`等于`matrix`
- `&matrix[x]`等于`matrix+x`
- `matrix[x]`等于`*(matrix+x)`
- `&matrix[x][y]`等于`*(matrix +x) + y`
- `matrix[4,3]`等于`matrix[3]`，因为逗号表达式是最后一个子表达式的值

### 8.2.4 指向数组的指针

```
    int v[10], *vp = v;  //合法
    int m[3][10], *mp = m; //非法，mp是指向整型的指针，而m是一个指向整型数组的指针
    int (*p1)[10] = m;  //合法
    int (*p2)[] = m;  //应该避免这种类型的声明，不能执行指针运算
```

### 8.2.5 作为函数参数的多维数组

```
    int matrix[3][10];
    ...
    func2( matrix );
    
    //那么func2的声明可以是：
    void func2( int (*mat)[10] );
    void func2( int mat[][10] );
    //但以下方式是错误的
    void func2( int **mat ); //指向整型指针的指针和指向整型数组的指针并不是一回事
```

### 8.2.6 初始化

- 初始化多维数组时，数组的存储顺序非常重要
- 初始化例子：`int m[2][3] = { 1, 2, 3, 4, 5, 6};`
- 初始化也可以是：

```
    int m[2][5] = {
        { 1, 2, 3, 4, 5},
        { 6, 7, 8, 9, 10}
    };
```

- 如果使用了这些花括号，每个子初始化列表都可以省略尾部的几个初始值，每一维的初始列表都各自都是一个初始化列表

### 8.2.7 数组长度自动计算

- 数组长度只有第1维才能根据初始化列表缺省地提供，其余的几个维必须显示写出
- 如果别的维也想缺省，编译器是允许这样做的，但是每个列表中的子初始值列表至少有一个要以完整的形式出现（不得省略末尾的初始值）
- 如果我们要求除第1维之外的其他维的大小都显示提供，所有的初始值列表都无需完整

## 8.3 指针数组

- 声明指针数组`int *api[10]`，api是数组名，数组元素是整型指针；区别与二维数组`int (*api)[10]`，api是指针名，指向的是一个长度为10的整型数组
- 区别：
  - 字符串以矩阵存储还是以指针常量方式存储（需要两种方式占用内存空间方面的区别，图在P164）

```
    //指针常量
    char const *keyword1[] = {
        "do",
        "for"
    }
    //矩阵,每行必须与最长字符串的长度一样，不需要指针
    char const keyword2[][5] = {
        "do",
        "for"
    }
```

- 哪种更好？
  - 字符串长度差不多：矩阵，因为无需使用指针
  - 字符串长度千差万别：指针数组

## 8.4 总结

- `sizeof`返回整个数组占用的字节而不是指针的字节；`&`返回一个指向数组的指针，而不是一个指向数组第1个元素的指针的指针（形参是指针，但是传入的数组的情况除外）
- 数组形参既可以声明为数组，也可以声明为指针，这两种声明形参只有当它们作为函数的形参时才相等
- 如果初始化列表包含的值的个数少于数组元素的个数，数组最后几个元素就用缺省值进行初始化

## 8.5 警告的总结

- 当访问多维数组时，误用逗号分隔下标，`a[3,5]`其实是`a[5]`
- 在一个指向未指定长度的数组的指针上执行指针计算`int (*p)[] = matrix`

## 8.6 编程提示的总结

- 源代码的可读性几乎总是比程序的运行时效更为重要
- 只要有可能，函数的指针形参都应该声明为const
- 对维数组初始化使用多层花括号能提高可读性

# 第9章 字符串、字符和字节

- C语言没有显示的字符串数据类型
- 字符串以字符串常量的形式出现或者存储于字符数组中，字符串常量适合用于不会对它们进行修改的字符串

## 9.1 字符串基础

- 字符串就是一串零个或多个字符，并且以一位模式全为0的NUL字节结尾，但它本身不是字符串的一部分，所以字符串的长度并不包括NUL字节
- `string.h`包含了字符串函数所需要的原型和声明，但是并非必须

## 9.2 字符串长度

- 字符串的长度就是它所包含的字符个数，不包括NUL
- `size_t strlen( char const *string )`
- 返回类型为`size_t`，定义在头文件`stddef.h`，是一个无符号整数类型
- `if( strlen( x ) - strlen( y ) >= 0)`这条语句永远是true，因为strlen返回的是无符号数，而无符号数是绝对不可能是负的
- `if( strlen( x ) >= 10 )`与`if( strlen( x ) -10 >= 0 )`不相等，原因与上同，可以将返回值强制转换为int就可以解决这个问题
- 标准库函数有时是用汇编语言实现的，目的就是充分利用某些机器所提供的字符串操作指令，从而追求最大的速度

## 9.3 不受限制的字符串函数

### 9.3.1 复制字符串

- `char *strcpy( char *dst, char const *src);`
- 由于dst参数是需要修改的，所以不能使用字符串常量
- 必须保证目标字符数组的空间足以容纳需要复制的字符串。如果超长，多余的字符仍然被复制，会覆盖原先存储于数组后面的内存空间的值

### 9.3.2 连接字符串

- `char *strcat ( char *dst, char const *src);`
- 如果src和dst的位置发生重叠，其结果是未定义的

### 9.3.3 函数的返回值

- strcpy和strcat返回第1个参数的一份拷贝，就是一个指向目标字符数组的指针
- 所以这些函数都可以嵌套地调用这些函数

### 9.3.4 字符串比较

- `int strcmp( char const *s1, char const *s2 );`
- 两个字符串对应的字符逐个进行比较，直到发现不匹配为止
  - 最先不匹配的字符较“小”的那个字符所在的那个字符串被认为“小于”另外一个字符串
  - 其中一个字符串是另一个字符串前面一部分，那么它也被认为“小于”另外一个字符串
- s1小于s2，返回一个小于零的值（不一定是-1）；s1大于s2，返回一个大于零的值（不一定是1）；两个字符串相等，则函数返回零

## 9.4 长度受限的字符串函数

- 这些函数接受一个现实的长度参数
- 如果源参数和目标参数发生重叠，strcpy和strncat的结果就是未定义的

```
char *strncpy( char *dst, char const *src, size_t len );
char *strncat( char *dst, char const *src, size_t len );
int *strncmp( char const *s1, char const *s2, size_t len );
```

- 如果strlen(src)的值小于len，dst数组就用额外的NUL字节填充到len长度
- 如果strlen(src)的值大于或等于len，那么只有len个字符被复制到dst中，注意！它的结果不会以NUL字节结尾
- 在使用不受限的函数之前，你首先必须确定字符串实际上是以NUL字节结尾的，但长度受限函数不需要
- strncat总是在结果字符串后面添加一个NUL字节，并且不会像strcpy用NUL字节进行填充

## 9.5 字符串查找基础

### 9.5.1 查找一个字符

```
/*
在字符串str中查找字符ch第一次出现的位置，找到后返回一个指向该位置的指针
如果不存在，则返回NULL
*/
char *strchr ( char const *str, int ch);
//与strchr功能相似，但是是最后一次出现的位置
char *strrchr ( char const *str, int ch);
```

### 9.5.2 查找任何几个字符

```
/*
查找任何一组字符第1次在字符串中出现的位置
返回一个指向str中第1个匹配group中任何一个字符的字符位置
未匹配，返回NULL
*/
char *strpbrk( char const *str, char const *group );
```

### 9.5.3 查找一个子串

```
/*
如果s2并没有完整地出现在s1的任何地方，函数返回NULL
如果s2是一个空字符串，返回s1
*/
char *strstr( char const *s1, char const *s2 );
```

- 标准库中并不存在strrstr或strrpbrk

## 9.6 高级字符串查找

### 9.6.1 查找一个字符串前缀

- strspn和strcspan用于在字符串的起始位置对字符计数
- strspn()从参数str字符串的开头计算连续的字符，而这些字符都完全是group 所指字符串中的字符。简单的说，若strspn()返回的数值为n，则代表字符串s开头连续有n 个字符都是属于字符串group内的字符

```
//返回str起始部分匹配cgroup中任意字符的字符数
size_t strspn( char const *str, char const *group );
//对str字符串起始部分中不与group中任何字符匹配的字符数
size_t strcspn( char const *str, char const *group );

int len1,len2;
char buffer[] = "25,142,330,Smith,J,239-4123";
len1 = strspn (buffer, "0123456789" );  //结果为2，因为只有"25"
len1 = strspn (buffer, ",0123456789" ); //结果为11,因为"25,142,330,"

//计算一个指向字符串中第1个非空白字符的指针
ptr = buffer + strspn( buffer, "\n\r\f\t\v"); 
```

### 9.6.2 查找标记

- strtok:从字符串中隔离各个单独的称为标记（token）的部分，并丢弃分隔符

```
char *strtok( char *str, char const *sep)

void print_tokens( char *line )
{
	static char whitespace[] = " \t\f\r\v\n";
	char *token;

	for( token = strtok( line, whitespace ); token !=NULL; token = strtok( NULL, whitespace ) )
	{
		printf("Next token is %s\n", token);
	}
}
```

- sep参数是个字符串，定义了用作分隔的字符集合
- strtok找到str的下一个标记，并将其用NUL结尾，然后返回一个指向这个标记的指针
- 它将会修改它所处理的字符串
- 如果strtok函数的第1个参数不是NULL，函数将找到字符串的第1个标记，strtok同时保存它在字符串中的位置
- 如果strtok函数的第1个参数是NULL，函数就在同一个字符串中从这个被保存的位置开始像前面一样查找下一个标记
- 如果字符串内不存在更多的标记，strtok返回一个NULL指针



- 你可以在每次调用strtok时使用不同的分隔符集合
- 由于strtok函数保存它所处理的函数的局部状态信息，所以你不能用它同时解析两个字符串，因此，如果for循环的循环体内调用了一个在内部调用strtok函数的函数，程序会失败

## 9.7 错误信息

- 当调用一些函数，请求操作系统执行一些功能，如果出现错误，操作系统是 通过设置一个外部的整型变量errno进行错误代码报告的
- strerror把其中一个错误代码作为参数并返回一个指向用于描述错误的字符串的指针
- `char *strerror ( int error_number );`

## 9.8 字符操作

- 标准库包含了两组函数用于操作单独的字符：对字符分类和转换字符
- ctype.h

### 9.8.1 字符分类

- 每个分类函数接受一个包含字符值的整型参数
- 函数测试这个字符并返回一个整型值
- `isspace`、`isupper`等函数
- 字符分类函数 表 P184

### 9.8.2 字符转换

- 转换函数把大写字母转换为小写字母，或反过来

```
int tolower( int ch );
int toupper( int ch );
```

- 如果参数并不是一个处于适当大小写状态的字符（不是大写或小写字母），函数将不修改参数直接返回
- 直接测试或操纵字符将会降低程序的可移植性

## 9.9 内存操纵

- 它们的操作与字符串函数类型，但这些函数能够处理任意的字节序列（可以包括NUL）

```
//length是以字节为单位的
void *memcpy( void *dst, void const *src, size_t length );
void *memmove( void *dst, void const *src, size_t length );
void *memcmp( void const *a, void const *b, size_t length );
void *memchr( void const *a, int ch, size_t length );
void *memset( void *a, int ch, size_t length );
```

- 它们在遇到NUL字节时并不会停止操作
- memcpy中如果src和dst以任何形式出现了重叠，它的结果是未定义的
- 任何类型的指针都可以转换为void*型指针
- memmove的行为和memcpy差不多，但它的源和目标操作数可以重叠，它可能比memcpy慢一些，但源和目标参数真的可能存在重叠，就应该使用memmove。原理：把源操作数复制到一个临时位置，这个临时位置不会与源或目标操作数重叠，然后再把它从这个临时位置复制到目标操作数
- memcmp按照无符号字符逐字节进行比较，函数的返回类型和strcmp一样。如果比较不是单字节的数据如整型或浮点数时就可能出现不可预料的结果
- memset把从a开始的length个字节都设置为字符值ch

## 9.10 总结

- 字符串的长度就是它所包含的字符的数目，不包括NUL
- strncpy中，如果源字符串比指定长度更长，结果字符串将不会以NUL字节结尾
- strncat它的结果始终以一个NUL字节结尾

## 9.11 警告的总结

- 应该使用有符号数的表达式中使用strlen函数，返回值类型size_t是无符号整型
- 把strcmp函数的返回值当做布尔值进行测试，是错误的
- 把strcmp函数的返回值与1或-1进行比较，是错误的
- 使用strcpy函数产生不以NUL字节结尾的字符串
- 忘了strtok函数将会修改它所处理的字符串
- strtok函数是不可再入的，即连续几次调用中，即使它们的参数相同，其结果也可能不同

## 9.12 编程提示的总结

- 使用字符分类和转换函数可以提高函数的移植性

# 第10章 结构和联合

## 10.1 结构基础知识

- 聚合数据类型能够同时存储超过一个的单独数据，如数组和结构
- 结构的值称为它的成员，各个成员可能具有不同的类型，可以通过名字来访问
- 和数组名不同，当一个结构变量在表达式中使用时，它并不能替换成一个指针
- 结构变量属于标量类型，你可以声明指向结构的指针，取一个结构变量的地址

### 10.1.1 结构声明

- `struct tag { member-list } variable-list;`
- 两个成员列表完全相同的结构体，也是不同的类型
- 声明结构体时可以用typedef创建一种新的类型

```
    typedef struct {
        int a;
        char b;
    } Simple;
    
    Simple x;
```

### 10.1.2 结构成员

- 一个结构的成员的名字可以和其他结构的成员的名字相同

### 10.1.3 结构成员的直接访问

- 结构变量的成员是通过点操作符`(.)`访问的

### 10.1.4 结构成员的间接访问

- 拥有一个指向结构的指针
  - `struct COMPLEX *cp`
  - 可以`(*cp).f`
  - 也可以`cp->f`
  - 后者称为`->操作符`，左操作数必须是一个指向结构的指针

### 10.1.5 结构的自引用

```
//非法
struct SELF_REF1 {
    int a;
    struct SELF_REF1 b;
    int c;
}

//合法
struct SELF_REF2 {
    int a;
    struct SELF_REF2 *b;  //注意这里是指针
    int c;
}

//非法，类型名直到生命的末尾才定义，所以在结构体生命的内部它尚未定义
struct {
    int a;
    struct SELF_REF3 *b;  
    int c;
} SELF_REF3

//合法
struct SELF_REF3_TAG {
    int a;
    struct SELF_REF3_TAG *b;  
    int c;
} SELF_REF3
```

### 10.1.6 不完整的声明

- 相互之间存在依赖的结构，需要使用不完整声明

```
struct B;

struct A {
    struct B *partner;
}

struct B {
    struct A *partner;
}
```

### 10.1.7 结构的初始化

- 这些值根据结构成员列表的顺序写出，如果初始列表的值不够，剩余的结构成员将使用缺省值进行初始化

```
struct INIT_EX {
    int a;
    short b[10];
    simple c;
} x = {
    10,
    { 1, 2, 3 };
    { 25, `x`, 1.9 }
};
```

## 10.2 结构、指针和成员

```
typedef struct {
    int a;
    short b[2];
} Ex2;
typedef struct EX {
    int a;
    char b[3];
    Ex2 c;
    struct EX *d;
} Ex;

Ex x = { 10, "Hi", { 5, { -1,25 } }, 0 };
Ex *px = &x;
```

### 10.2.1 访问指针

- `px + 1`表达式并不是一个合法的左值
- 右值：如果px指向一个结构数组的元素，这个表达式将指向该数组的下一个结构，但仍然是非法的，因为我们没法分辨内存下一个位置所存储的是这个结构元素之一还是其他东西

### 10.2.2 访问结构体

- 访问结构体：`*px`
- `*px + 1`是非法的
- `*(px + 1)`由于x是标量，所以这个表达式实际上是非法的

### 10.2.3 访问结构成员

- `px->a`和`x.a`相等

- 比较

  ```
  *px
  ```

  和

  ```
  px->a
  ```

  - a的地址和结构的地址是一样的
  - 尽管两个地址是相等的，但它们的类型不同
  - `int *pi; pi = px;`是非法的，因为它们的类型不匹配
  - `pi = &px->a`是合法的，这个操作之后pi和px具有相同的值，但是类型不同，`*px`结果是整个结构，`*pi`结果是一个单一的整型值

### 10.2.4 访问嵌套的结构

### 10.2.5 访问指针成员

## 10.3 结构的存储分配

- 编译器安装成员列表的顺序一个接一个地给每个成员分配内存。只有当存储成员时需要满足正确的便捷对齐要求时，成员之间才可能出现填充的额外内存空间

```
struct ALIGN {
    char a;
    int b;
    char c;
}
```

- 如果某个机器的整型值长度为4个字节，并且它的起始存储位置必须能够被4整除，那么这个结构体在内存中的存储将如下所示
- `[a][][][][b, , , ][c][][][]`
- 系统禁止编译器在一个结构体的起始位置跳过几个字节来满足边界对齐要求，因此所有结构的起始存储位置必须是结构中边界要求最严格的数据类型所要求的位置，因此a必须存储于一个能够被4整除的地址
- sizeof操作符能够得到一个结构的整体长度，包括因边界对齐而跳过的那些字节
- 确定结构体某个成员的实际位置，应该考虑边界对齐因素，可以使用offsetof宏（定义于stddef.h）
- `offsetof( type, member );`
- type就是结构的类型，member就是你需要的那个成员名，表达式的结果是一个size_t，表示这个指定成员开始存储的位置距离结构体开始存储的位置偏移几个字节
- `offsetof( struct ALIGN, b)`的结果是4

## 10.4 作为函数参数的结构

- 一般传指针，可以传值，但是效率低
- 向函数传递指针的缺陷在于函数现在可以对调用程序的结构体进行修改，可以使用const来防止
- `void print_receipt ( register Transaction const * trans)`
- 参数声明为寄存器变量，可以进一步提高指针方案的效率

## 10.5 位段

- 位段（bit field）
- 位段的声明和结构类似，但它的成员是一个或多个位的字段，这些不同长度的字段实际上存储于一个或多个整型变量中
- 位段成员必须声明为int、signed int或unsigned int
- 在成员名的后面是一个冒号和一个整数，这个整数指定该位所占用的位的数目
- 如果位段声明为int，编译器决定是有符号还是无符号
- 注重可移植性的程序应该避免使用位段
- 位段中的成员在内存中是从左向右分配还是相反，在不同机器上是不同的
- 位段声明的例子：

```
    struct CHAR {
        unsigned ch     : 7;
        unsigned font   : 6;
        unsigned size   : 19;
    };
    
    struct CHAR ch1;
```

- 使用位段的理由：
  - 它能够把长度为奇数的数据包装在一起，节省存储空间
  - 可以很方便地访问一个整型值的部分内容

## 10.6 联合

- 联合的所有成员引用的是内存中相同位置

```
    union {
        float f;
        int i;
    }
```

- 如果f被使用，这个数就作为浮点值访问，如果i被使用，就作为整型值访问
- 如果联合的各个成员具有不同的长度，联合的长度就是它最长成员的长度

### 10.6.1 变体记录

- 变体记录：内存中某个特定的区域将不同的时刻存储不同类型的值，它们的每一个都是完整的结构
- 如果这些成员的长度相差悬殊，当存储短成员时，浪费的空间相当可观
- 为了节省空间，更好的办法是在联合中存储指向不同成员的指针而不是直接存储成员本身，因为所有指针的长度都是相同的

### 10.6.2 联合的初始化

- 联合变量可以被初始化，但这个初始化必须是联合第1个成员的类型，而且必须在一对花括号里

```
    union {
        int a;
        float b;
        char c[4];
    } x = { 5 };
```

- 如果给出的初始值时任何其他类型，它就会转换（如果可能的话）成一个整数并复制给x.a

## 10.7 总结

- 结构标签是一个名字，它与一个成员列表相关联
- 结构不能包含类型也是这个结构的成员，但它的成员可以是一个指向这个结构的指针，常常用于链式数据结构中
- 编译器为一个结构变量的成员分配内存时要满足它们的边界对齐要求
- sizeof返回的值包含了结构中浪费的内存空间
- 位段是结构的一种，但它的成员长度以位为单位指定。位段声明在本质上是不可移植的

## 10.8 警告

- 具有相同成员列表的结构声明产生不同类型的变量
- 使用typeof为一个自引用的结构定义名字时应该小心

## 10.9 编程提示的总结

- 把位段成员显示地声明为signed int或unsigned int类型

# 第11章 动态内存分配

- 数组被声明时，它所需要的内存在编译时就分配
- 也可以使用动态内存分配在运行时为它分配内存

## 11.1 为什么使用动态内存分配

## 11.2 malloc和free

- malloc和free分别用于执行动态内存分配和释放，这些函数维护一个可用的内存池
- malloc从内存池中提取一块合适的内存，返回这块内存起始位置的指针
- 如果这块内存需要初始化，要么手动进行初始化，要么使用calloc
- free函数把malloc等函数分配的内存还给内存池
- 这些函数原型在stdlib.h中
- `void *malloc ( size_t size ); //以字节为单位`
- `void free( void *pointer );`
- malloc实际分配的内存有**可能**比你请求的稍微多一点，由编译器定义
- 如果内存池是空的，或者它的可用内存无法满足请求，那么：
  - malloc向系统请求要求得到更多内存，并在这块新内存上执行分配任务
  - 系统无法向malloc分配更多内存，malloc就返回一个NULL
- free的参数
  - NULL，函数不会产生任何效果
  - malloc、calloc、realloc返回的值
- malloc不知道内存的数据类型，返回void *类型的指针，可以转换为其他任何类型的指针
- malloc所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求

## 11.3 calloc和realloc

```
void *calloc( size_t num_element, size_t element_size);
void realloc( void *ptr, size_t new_size);
```

- malloc和calloc区别：
  - 后者在返回指向内存的指针之前把它初始化为0
  - 它们请求内存数量的方式不一样，calloc的参数包括所需元素的数量和每个元素的字节数
- realloc用于修改一个原先已经分配的内存的大小，扩大或缩小
  - 如果原先的内存无法改变大小，realloc将分配另一块正确大小的内存，并把原先那块内存的内容复制到新的快上
  - 如果第一个参数是NULL，那么它的行为就和malloc一模一样

## 11.4 使用动态分配的内存

- NULL定义于stdio.h，实际上是字面值常量0
- malloc等函数分配出来的内存，不仅可以使用指针，也可以使用下标

## 1.5 常见的动态内存错误

- 常见错误
  - 对NULL指针进行解引用操作
  - 对分配的内存进行操作时越过边界
  - 释放并非动态分配的内存
  - 试图释放一块动态分配的内存的一部分
  - 一块动态内存被分配之后被继续使用
- 传递给free的指针必须是malloc、calloc或realloc返回的指针，让它释放一块并非动态分配的内存可能导致程序终止或在晚些时候终止
- free释放一块内存的一部分是不允许的，动态分配的内存必须整体一块释放
- realloc可以缩小动态分配的内存，有效地释放它尾部的部分内存

### 内存泄漏

- 分配内存但在使用完毕后不释放将引起内存泄漏（memory leak）

## 11.6 分配内存实例

- free联合的任一成员都可以，因为free不会理会指向内容的类型

## 11.7 总结

- malloc函数返回时内存并未以任何方式进行初始化
- realloc增加内存块大小时可能采取的方式是把原来内存块上的所有数据复制到一个新的、更大的内存块上
- 内存泄漏是指内存被动态分配以后，当它不再使用时未被释放，内存泄漏会增加程序的体积，有可能导致程序或系统的崩溃

# 第12章 使用结构和指针

- 本章代码较多，涉及大多是链接插入操作的优化方法，复习本章更好的方法是看书

## 12.1 链表

- 链表就是一些包含数据的独立结构（通常称为节点）的集合
- 通过链或指针连接在一起
- 通常节点是动态分配的，但也有由节点数组构建的链表
- 通过指针来遍历链表

## 12.2 单链表

- 在单链表中，每个节点包含一个指向链表下一个节点的指针
- 链表最后一个节点的指针字段的值为NULL
- 为了记住链表的起始位置，可以使用一个根指针
- 根指针指向链表的第1个节点
- 链表中的节点可能分布于内存的各个地方
- 单链表无法从相反的方向进行遍历

## 12.3 双链表

- 在一个双链表中，每个节点都包含两个指针，一个指向前一个节点的指针和一个指向后一个节点的指针
- 链表第1个节点的bwd字段和最后一个节点的rwd字段都为NULL

## 12.4 总结

- 语句提炼是一种简化程序的技巧，其方法是消除程序中的冗余语句

## 12.5 警告的总结

- 从if语句中提炼语句可能会改变测试结果

## 12.6 编程提示的总结

- 不要仅仅根据代码的大小评估它的质量

# 第13章 高级指针话题

## 13.1 进一步探讨指向指针的指针

## 13.2 高级声明

```
//f是一个函数，这个函数的返回值是一个指向整型的指针
int *f();
//f是一个函数指针，它所指向的函数返回一个整型值
int (*f)();
//f是一个函数指针，它所指向的函数返回一个整型指针
int *(*f)();
//f是一个数组，数组的元素是整型指针
int *f[];
//f是一个函数，函数的返回值是一个整型数组，但是这个是非法的，因为函数只能返回标量，不能返回数组
int f()[];
//f是一个数组，数组的元素时返回值为整型的函数，但这个是非法的，因为数组元素必须具有相同的长度，但不同的函数显然可能具有不同的长度
int f[]();
//f是个数组，数组元素是函数指针，指针所指向的类型是返回值为整型的函数，其中int ()为指针指向的类型
int (*f[])();
//f是个数组，数组元素是函数指针，指针所指向的类型是返回值为整型指针的函数，其中int * ()为指针指向的类型
int *(*f[])();
```

## 13.3 函数指针

- 函数指针的用途：转换表和作为参数传递给另一个函数

```
int f( int );
//初始化，在函数指针的初始化之前具有f的原型是很重要的，否则编译器无法检查f的类型是否与pf所指向的类型一致
int (*pf)( int ) = &f;  
```

- 初始化表达式中&操作符是可选的，因为函数名被使用时总是由编译器把它转换为函数指针
- 三种方式调用函数

```
int ans;
ans = f( 25 );
//把指针函数转焕为一个函数名，这个转焕并不是真正需要的，因为编译器在执行函数调用操作符之前会把它转换为函数指针
ans = (*pf)( 25 );
ans = pf( 25 );
```

### 13.3.1 回调函数

- 回调函数：把一个函数指针作为参数传递给其他函数，被传递的这个函数称为回调函数

### 13.3.2 转移表

- 转换表就是一个函数指针数组
- 转换表需要两步操作
  - 声明并初始化函数指针数组
  - 用下面这条语句替换前面整条switch语句`result = oper_func[ oper ]( op1, op2 );`

## 13.4 命令行参数

### 13.4.1 传递命令行参数

- C程序的main函数具有两个参数：
  - `argc`：表示命令行参数的数目
  - `agrv`：指向一组参数
  - `int main( int argc, char **argv )`
- 在有些系统中，参数字符串是挨个存储的，这样当你把指向第1个参数的指针向后移动，越过第1个参数的尾部时，就达到了第2个参数的起始位置，即`++*argv`。但这个是由编译器决定的，不能依赖
- 为了徐州一个参数的起始位置，你应该使用数组中适合的指针，即`*++agr`，指向下一个数组元素，然后使用间接访问操作获得字符串指针

## 13.5 字符串常量

```
//它的结果是个指针，指向字符串中第2个字符：y
"xyz"+1;
//它的结果一个字符，即x
*"xyz";
//以下结果为字符z
"xyz"[2]
//偏移量4超出了这个字符串的范围，是一个不可预测的字符
*("xyz"+4)
```

## 13.6 总结

- 字符串常量的值时一个常量指针，它指向字符串的第1个字符，和数组名一样，你既可以用指针表达式也可以用下标来使用字符串常量

# 第14章 预处理器

- 编译一个C程序的第1步称为预处理阶段
- C预处理器在编译代码之前对其进行一些文本性质的操作
- 主要任务包括：
  - 删除注释
  - 插入被`#include`指令包含的文件的内容
  - 定义和替换由`#define`指令定义的符号
  - 确定代码的部分内容是否应该根据一些条件编译指令进行编译

## 14.1 预定义符号

- 预处理符号
  - `_FILE_`:进行编译的源文件名
  - `_LINE_`:文件当前行的符号
  - `_DATE_`:文件被编译的日期
  - `_TIME_`:文件被编译的时间
  - `_STDC_`:如果编译遵循ANSI C，其值就为1，否则未定义

## 14.2 #define

- `#define name stuff`
- 使用`#define`指定，可以把任何文本替换到程序中
- 如果定义的stuff很长，可以分行，每行的末尾使用`\`

### 14.2.1 宏

- `#define`机制允许把参数替换到文本中，称为宏或者定义宏
- `#define name(parameter-list) stuff` 左括号必须与name紧邻，不能有空格
- 一定要用宏替换产生的文本，来检查正确性
- 所有用于对数值表达式进行求值的宏定义都应该使用括号
- 宏，其作用域和变量不一样，宏是从定义的地方开始到代码块结束都是有效的。没有什么局部之分

### 14.2.2 `#define`替换

- 宏参数和`#define`定义可以包含其他`#define`定义的符号，但宏不可以出现递归

- 预处理器搜索

  ```
  #define
  ```

  定义的符号时，字符串常量的内容并不进行检查，如果想把宏参数插入到字符串常量中，可以

  - 方法1：利用邻近字符串自动连接的特性，把一个字符串分为几段，每一段实际上都是一个宏参数

```
    #define PRINT(FORMAT,VALUE) printf( "The value is " FORMART "\n", VALUE)
    int x = 22;
    PRINT("%d", x+3 );
    
    //输出为：The value is 25
-   方法2：`#argument`这种结构被预处理器翻译为`argument`
     #define PRINT(FORMAT,VALUE) printf( "The value of " #VALUE "is" FORMART "\n", VALUE)
    int x = 22;
    PRINT("%d", x+3 );
    
    //输出为：The vaule of x+3 is 25
```



- `##`结构把位于两边的符号连接成一个符号
- 这种连接必须产生一个合法的标识符

```
#define ADD_TO_SUM( sum_number, value ) \
        sum ## sum_number += value
...
//把25加到变量sum5中
ADD_TO_SUM( 5, 25 );
```

### 14.2.3 宏与函数

- 宏比函数的优势：
  - 规模和速度
  - 函数参数必须指定类型，而宏与类型无关
- 宏比函数的劣势：每次使用宏都要代码拷贝

### 14.2.4 带副作用的宏参数

- 当宏参数在宏定义中出现的次数超过一次时，如果这个参数具有副作用，那么使用这个宏就可能出现危险
- 副作用是在表达式求值时出现永久性效果

### 14.2.5 命名约定

- 一个常见的约定就是把宏名字全部大写
- 宏和函数的不同之处（参考P285 表14.2）：
  - 代码长度
  - 执行速度
  - 操作符优先级
  - 参数求值
  - 参数类型

### 14.2.6 #undef

- 移除一个宏定义`#undef name`

### 14.2.7 命令行定义

- `int array[ARRAY_SIZE];`
- 可以使用两种方式来编译前定义
  - `-Dname`
  - `-Dname=stuff`
- `cc -DARRAY_SIZE=100 prog.c`

## 14.3 条件编译

- 使用条件编译可以选择代码的一部分被正常编译还是完全忽略

```
/*
常量表达式由预处理器进行求值，非零为真，为真则编译，否则忽略，常量表达式可以是字面值常量或#define定义的符号
*/
#if 常量表达式  
    语句
#endif

/*
#elif出现次数不限
#else语句只有前面所有的常量表达式的值都是假才会被编译
*/
#if 常量表达式
    语句
#elif 常量表达式
    其他语句
#else 
    其他语句
#endif
```

### 14.3.1 是否被定义

- 测试一个符号是否已经被定义

```
if defined(symbol)
#ifdef symbol

#if !defined(symbol)
#ifndef symbol
```

- 每对定义的两条语句等价，但`#if`形式更强

### 14.3.2 嵌套指令

- 为每个`#endif`加上一个注释标签是很有帮助的

## 14.4 文件包含

- `#include`指令替换执行的方式：预处理器删除这条指令，并包含文件的内容取而代之，一个头文件如果被包含到10个源文件中，它实际上被编译了10次
- 这样会涉及一些开销，但是这个开销只是在程序被编译时才存在，对运行时效率并无影响

### 14.4.1 函数库文件包含

- 两种不同类型的`#include`文件包含：函数库文件和本地文件
- 函数库头文件：`#include <filename>`，标准库文件以一个`.h`后缀结尾，运行于UNIX系统上的C编译器在/usr/include目录查找函数库头文件

### 14.4.2 本地文件包含

- `include "filename"`
- 处理本地头文件的一种常见策略是在源文件所在的当前目录进行查找，未找到就按照查找函数库头文件一样在标准位置查找本地头文件
- 可以在所有的`#include`语句中使用双引号而不是尖括号，但对于函数库头文件，查找效率变低
- 也可以使用绝对路径`#include absolute_path`
- 如说使用绝对路径，那么正常的目录查找就被跳过

### 14.4.3 嵌套头文件包含

- 标准要求必须支持失少8层头文件嵌套，但它并没有限制嵌套深度的最大值
- 嵌套的不利之处
  - 它使得很难判断源文件之间的真正依赖关系
  - 一个头文件可能会被多次包含
- 解决多重包含，可以使用条件编译
  - 例如，以下为某个头文件：

```
    #ifndef _HEADERNAME_H
    #define _HEADERNAME_H 1   // <-----这里也可以直接 #define _HEADERNAME_H
    #include <stdio.h>
	//  头文件具体内容
    #endif
```

## 14.5 其他指令

- `#error`允许你生产错误信息`#error text of error message`

- `#line number "string"`:该语句通知预处理器number是下一行输入的行号，`"string"`预处理器把它当做当前文件名。该语句会修改`_LINE_`和`_FILE_`

- ```
  #progma
  ```

  用于支持因编译器而异的特性，它的语法也是因编译器而异，有些编译器使用

  ```
  #progma
  ```

  指令

  - 在编译过程中打开或关闭清单显示
  - 把汇编代码插入到C程序中

- `#progma`是不可移植的

- 无效指令就是一个

  ```
  #
  ```

  符号开头，但后面不跟任何内容的一行

  - 例如：

```
    #
    #include <stdio.h>
    #
```

## 14.6 总结

- 为了防止可能出现表达式中的于宏有关的错误，在宏完整定义的两边应该加上括号，在宏定义中每个参数的两边也要加上括号

## 14.7 警告的总结

- 不要在一个宏定义的末尾加上分号，使其成为一条完整的语句

# 第15章 输入\输出函数

- 本章讨论ANSI C的输入和输出函数

## 15.1 错误报告

- 标准库函数在一个外部整型变量errno（定义在errno.h）中保存错误代码之后把这个消息传递给用户程序，提示操作失败的准确原因
- `void perror( char const *message );`定义于stdio.h
- perror打印message字符串，后面跟一个分好和一个空格，然后打印一条用于解释error当前错误代码的信息
- `perror( "data3" );`的结果是`data3: No such file or directory`
- 只有当被调用的函数提示有错误发生时检查errno的值才有意义

## 15.2 终止执行

- `void exit( int status )`定义于stdlib.h
- status用于提示程序是否正常完成，这个值和main函数返回的整型状态值相同，`EXIT_SUCCESS`和`EXIT_FAILURE`分别表示成功和失败
- 调用perror之后再调用exit终止程序

## 15.3 标准I/0函数库

- 在设计ANSI函数库时，可移植性和完整性是两个关键的考虑内容

## 15.4 ANSI I/0概念

- stdio.h包含了与ANSI函数库的I/O部分有关的声明

### 15.4.1 流

- 字节流被称为流
- 绝大多数流是完全缓冲的，意味着“读取”和“写入”是从一块被称为缓冲区的内存区域来回复制数据
- 用于输出流的缓冲区只有写满时才会被刷新（flush，物理写入）到设备或文件中
- 输入缓冲区当它为空时通过设备或文件读取下一块较大的输入，重新填充缓冲区
- 请求输入时同时刷新输出缓冲区，这样在用户必须进行输入之前，提示用户进行输入的信息和之前写入到缓冲区中的内容将出现在屏幕上
- 每个用于调试的printf函数之后立即调用fflush
- fflush迫使缓冲区的数据立即写入，不管它是否已满

#### 一、文本流

- 流分为两种：文本流和二进制流
- 文本流特性不同系统不同
  - 文本的最大长度：标准规定至少254个字符
  - 文本行的结束方式：UNIX使用换行符结尾

#### 二、二进制流

- 二进制流中的字节将完全根据程序编写它们的形式写入到文件或设备中，而且根据它们从文件或设备读取的形式读入到程序中，并未作任何改变
- 这种类型的流适合非文本数据

### 15.4.2 文件

- FILE是一个数据结构，用于访问一个流
- 每个流都有一个相关的FILE与它关联
- 运行时系统提供至少三个流：标准输入（stdin）、标准输出（stdout）、标准错误（stderr），它们都是一个指向FILE结构的指针
- 标准输入是缺省的输入的来源，标准输出是缺省的输出设置
- 通常标准输入为键盘设备，标准输出为终端或屏幕
- 程序运行时修改缺省的输入输出设备：`program < data > answer`，data作为标准输入，answer作为标准输出
- 标准错误就是错误信息写入的地方，标准输出和标准错误在缺省情况下是相同的

### 15.4.3 标准I/0常量

- `EOF`提示到了文件尾，EOF所选择的实际值比一个字符要多几位，为了避免二进制值被错误地解释为EOF
- 一个程序最多能打开多少个文件和编译器有关，同时打开至少`FOPEN_MAX`个文件，它的值至少是8
- FILENAME_MAX：一个字符数组应该多大以便容纳编译器所支持的最长合法文件名

## 15.5 流I/O总览

- 文件I/O
  - 每个文件声明一个指针变量，其类型为`FILE *`
  - 流通过调用fopen函数打开，必须指定访问方式
  - 调用fclose关闭流
- 标准I/0，并不需要打开或关闭
- I/O函数三种基本形式：单个字符、文本行、二进制数据
- P301 表15.1列出了每种I/O形式的函数家族
  - 字符：`getchar`、`putchar`：读取（写入）单个字符
  - 问本行：`gets`、、`puts`:文本行未格式的输入（输出）；`scanf``printf`：文本行格式化的输入（输出）
  - 二进制数据：`fread`、`fwrite`：读取（写入）二进制数据
- 每个族函数里都包含了各种函数变种用于执行下面的任务，这些函数的区别在于输入的来源或写入的地方不同
  - 只用于stdin或stdout
  - 随作为参数的流使用
  - 使用内存中的字符串而不是流
- P301 表15.2 输入/输出函数家族列出了每个函数族中的变种函数

## 15.6 打开流

- `FILE *fopen( char const *name, char const *mode)`打开一个特定的文件，并把一个流和这个文件相关联

- mode提示流是只读、只写、既读又写；是文本流还是二进制流

  - 如下：

  - | 读取   | 写入 | 添加 |      |
    | :----- | :--- | :--- | :--- |
    | 文本   | “r”  | “w”  | “a”  |
    | 二进制 | “rb” | “wb” | “ab” |

- 如果一个文件打开是用于写入的，如果它原先存在，那么原来的内容会被删除，如果原先不存在，那就创建一个新文件

- 无论哪种情况，数据只能在文件的尾部写入

- mode为“a+”表示文件打开用于更新，既允许读也可以写

- 如果你已经从该文件读了一些数据，在你开始写入之前，必须调用其中一个文件定位函数（fseek、fsetpos、rewind）

- 在你向一个文件写一些数据后，如果又想从该文件读，必选先调用fflush或文件定位函数之一

- fopen执行失败，则返回NULL，errno会提示问题的性质

- `FILE *freopen( char const *filename, char const *mode, FILE *stream );`用于打开（重新打开）一个特定的文件流，stream参数可以是fopen打开的流，也可以是标准流。该函数首先关闭这个流，然后用指定的文件和模式重新打开这个流，如果打开成功，函数就返回它的第3个参数值

## 15.7 关闭流

- `int fclose( FILE *f );`关闭流
- 在文件关闭之前刷新缓冲区，如果成功，返回零值，否则返回EOF

## 15.8 字符I/O

- 当一个流被打开后，它可以用于输入和输出
- 字符输入是由getchar家族执行的

```
int fgetc( FILE *stream );
int getc( FILE *stream );
//只用于标准输入
int getchar( void );
```

- 以上函数，如果流中不存在更多的字符，返回EOF
- 它们返回一个int型值而不是char，是为了允许函数报告文件的末尾（EOF）
- 把单个字符写入流中，使用putchar函数家族

```
int fputc( int character, FILE *stream );
int putc( int character, FILE *stream );
//只用于标准输
int putchar( int character ); 
```

- 以上函数把这个整型参数裁剪未一个无符号字符整型值
- `putchar(`abc`)`只打印一个字符（至于是哪一个由编译器决定）
- 函数失败，返回EOF

### 15.8.1 字符I/O宏

- fgetc和fputc是真正的函数，程序长度更胜一筹
- getc、putc、getchar、putchar都是宏，执行效率更高

### 15.8.2 撤销字符I/O

- `int ungetc( int character, FILE *stream);`把一个先前读入的字符返回流中，这样它可以在以后被重新读入
- 每个流都允许至少一个字符被退回
- 如果一个流允许退回多个字符，那么这些字符再次被读取的顺序就以退回时的反序进行（类似栈，先进后出，先退后出）

## 15.9 未格式化的行I/O

- 行I/O可以用两种方式执行：未格式化的和格式化的
- 未格式化的I/O简单读取或写入字符串
- 格式化的I/O执行数字和其他变量的内部和外部表示形式之间的转换

```
/*
fgets从指定的stream读取字符并复制到buffer中
当它读取第一个换行符并存储到缓冲区之后就不再读取
如果缓冲区存储的字符数达到buffer_size-1也停止读取
在任何一种情况下，一个NUL将添加到缓冲区数据的末尾，使之成为一个字符串
如果在任何字符读取之前就达到了文件尾部，则fgets返回NUL；否则返回第1个参数
*/
char *fgets( char *buffer, int buffer_size, FILE *stream );
//用于标准输入
char *gets( char *buffer ); 
/*
如果fputs的字符串包含好几个换行符，所有的换行符都会被写入
fputs既可以一次写入一行的一部分，也可以一次写入一行，也可以一次写入好几行
出错时返回EOF，否则返回一个非负值
*/
char *fputs( char *buffer, FILE *stream );
//用于标准输出
char *puts( char *buffer );
```

- 以上函数用于操作字符串。
- 如果函数需要计算被复制的行的数目，太小的缓冲区将产生一个不正确的计数，因为一个长行可能会被分成数段进去读取
- fgets无法把字符串去读到一个长度小于2个字符的缓冲区，因为其中一个字符需要为NUL保留
- gets和puts为的是允许向后兼容，它们与其他两个函数的功能性区别是：
  - 当gets读取一行时，并不在缓冲中存储结尾的换行符；当puts写入一个字符串时，它在字符串写入之后再添加一个换行符
  - gets没有缓冲长度参数，如果一个长输入行读到一个短的缓冲区，多出来的字符将被写入到缓冲区后面的存储位置

## 15.10 格式化的行I/O

- scanf和printf并不仅限于单行，也可以在行的部分或多行上执行I/O操作

### 15.10.1 scanf家族

- 一下每个原型中的`...`表示一个可变长度的指针列表。从传入的转换而来的值逐个存储到这些指针参数所指向的内存位置

```
//输入源为stream
int fscanf( FILE *stream, char const *format, ...);
//输入源为标准输入
int scanf( char const *format, ...);
//输入源为string字符串
int sscanf( char const *string, char const *format, ...);
```

- 这些函数都是从输入源读取字符并根据format字符串给出的格式码对它们进行转换
- 当格式化字符串到达末尾或读取的输入不再匹配格式字符串所指定的类型时，输入停止
- 被转换的输入值的数目作为函数的返回值；转换之前文件就已经到达尾部，则返回EOF
- scanf函数的参数前面为什么要加一个&是因为要转为指针列表

### 15.10.2 scanf格式代码

- format字符串可能包含下列内容
  - 空白字符：与输入中的零个或多个空白字符匹配，处理过程中被忽略
  - 格式代码：指定函数如何解释接下来的字符
  - 其他字符：当任何其他字符休闲在格式字符串中时，下一个输入字符必须与它匹配。如果匹配，该输入字符随后被丢弃。如果不匹配，函数就不再读取直接返回
- scanf的格式代码都以一个百分号开头，后面可以是
  - 一个可选星号，将转换后的值丢弃，用于跳过不需要的输入字符
  - 一个可选宽度，限制被读取用于转换的输入字符的个数，未给宽度，就连续读入直到遇到下一个空白字符
  - 一个可选限定符，用于修改有些格式代码的含义，为了指定参数的长度，P309 表15.3 scanf限定符
  - 格式代码，就是一个单字符，用于指定输入字符如何被解释，P310 表15.4 scanf格式码
- 例子：

```
nfields = fscanf( input, "%d4 %d4 %d4", &a, &b, &c);
//若输入为12345 67890
//a为1234，b为5，c为6789，nfields为3，最后的0保持在未输入状态
```

### 15.10.3 printf家族

```
//输出源为stream
int fprintf( FILE *stream, char const *format, ...);
//输出源为标准输入
int printf( char const *format, ...);
//输出源为string字符串
int sprintf( char const *string, char const *format, ...);
```

- 返回值是实际打印或存储的字符数
- sprintf缓冲区大小并不是它的一个参数，如果输出结果很长溢出缓冲区时，就可能改写缓冲区后面内存位置中的数据
- prinf函数家族的格式代码和scanf函数家族的格式代码用法不同
- 参数类型与对应的格式代码不匹配，这个错误将导致输出结果是垃圾，也有可能导致程序失败

### 15.10.4 printf格式代码

- 格式代码由一个百分号开头，后面跟
  - 零个或多个标志符号，用于修改有些转换的执行方式。决定填充是空白还是零以及它出现在值的左边还是右边
  - 一个可选的最小字段宽度，是一个十进制整数，用于指定将出现在结果中的最小字符数，值的字符数少于字段宽度，就对它进行填充以增加长度
  - 一个可选的精度，以一个句点`.`开头，后面跟一个可选的十进制整数，缺省值为零
  - 一个可选的修改符，P314 表15.7 printf格式代码修改符，用于指定整数和浮点数参数的准确长度，当打印长整数值时，最好坚持使用`l`修改符
  - 转换类型
- P313 表15.5:printf格式代码表；表15.6:prinf格式标志表
- 对于`d、i、u、o、x、X`类型的转换，精度指定将出现在结果中的最小的数字个数并覆盖零标志
- 对`e、E、f`类型的转换，精度决定出现在小数点知乎的位数
- 对`g、G`类型的转换，精度决定出现在结果中的最大有效位数
- 对`s`类型的转换，精度指定将被转换的最多字符数
- 字符或短整数值作为printf函数的参数时，它们在传递给函数之前先转换为整数
- P314 表15.8 printf转换的其他形式

### 15.11 二进制I/O

- 二进制形式写入效率最高，二进制输出避免了再数值转换为字符串过程中所涉及的开销和精度损失
- 二进制I/O只有当数据将被另一个程序按顺序读取时才能使用

```
/*
@buffer:保存数据的内存位置的指针
@size:缓冲区中每个元素的字节数
@count:读取或写入的元素数
@返回值：实际读取或写入的元素（并非字节）数目，如果输入过程中遇到文件尾货输出过程中出错，这个数字可能比请求的元素数目要小
*/
size_t fread( void *buffer, size_t size, size_t count, FILE *stream );
size_t fwrite( void *buffer, size_t size, size_t count, FILE *stream );
```

### 15.12 刷新和定位函数

- `int fflush( FILE *stream )`迫使一个输出流的缓冲区内的数据进行物理写入，不管缓冲区是否已经写满
- 调用fflush保证调试信息实际打印出来，而不是保存在缓冲区中直到以后才打印
- C支持随机访问I/O，以任意顺序访问文件的不同位置，通过读取或写入先前定位到文件中需要的位置来实现

```
long ftell( FILE *stream );
int fseek ( FILE *stream, long offset, int from);
```

- ftell返回流的当前位置，即下一个读取或要写入将要开始的位置距离文件起始位置的偏移量
  - 在二进制流中，这个值就是当前位置距离文件起始位置的字节数
  - 在文本流中，值表示一个位置，但并不一定准确地表示当前位置和文件起始位置之间的字符数
- ftell返回值总是可以用于fseek函数中
- fseek允许你在一个流中定位
  - 定位到一个文件起始位置之前是一个错误
  - 定位到文件尾之后并进行写入将拓展这个文件
  - 定位到文件尾之后并进行读取将导致返回一条“达到文件尾”的信息
  - fseek参数：`SEEK_SET`、`SEEK_CUR`、`SEEK_END`
- fseek带来三个副总用
  - 行末指示字符被清除
  - 如果在fseek之前使用ungetc把一个字符返回流中，那个这个被退回的字符将会被丢弃
  - 定位允许你从写入模式切换到读取模式，或回到打开的流以便更新

```
//将读/写指针设置回指定流的起始位置，同时清除流的错误提示标志
void rewind( FILE *stream );
//ftell的替代方案
int fgetpos( FILE *stream, fpos_t *position );
//fseek的替换方案
int fsetpos( FILE *stream, fpos_t const *position );
```

- fgetpos、fsetpos与ftell、fseek主要区别
  - 这对函数接受一个指向fpos_t的指针作为参数
  - fgetpos在这个存储位置的当前位置
  - fsetpos把文件位置设置为存储在这个位置的值
- fpos_t表示一个文件位置的方式并不是由标准定义的，可能是字节偏移量，也可能不是
- 使用fgetpos返回的fpos_t的值的唯一安全用法是把它作为参数传递给后续的fsetpos

## 15.13 改变缓冲方式

```
void setbuf( FILE *stream, char *buf );
int setvbuf( FILE *stream, char *buf, int mode, size_t size );
```

- 以上函数可以用于对缓冲方式进行修改，只有当指定的流被打开但还没有在它上面执行任何其他操作前才能被调用
- setbuf设置了另一个数据，用于对流进行缓冲
  - 这个数组的字符长度必须为BUFSI（在stdio.h定义）
  - 为一个流自行指定缓冲区可以防止I/O函数库为它动态分配缓冲区
  - 如果用NULL参数调用函数，setbuf将关闭流的所有缓冲方式，字符准确地将程序所规定的方式进行读取和写入
- setvbuf更为通用
  - mode用于指定缓冲流的类型。`_IOFBF`完全缓冲的流。`_IONBF`不缓冲的流。`_IOLBF`行缓冲流，即每当一个换行符写入到缓冲区时，缓冲区便进行刷新
  - buf和size用于指定需要使用的缓冲区

## 15.14 流错误函数

```
//流当处于文件尾时，feof返回真，这个状态可以通过fseek、rewind或fsetpos来清除
int feof( FILE *stream );
//报告流的错误状态，如果出现任何读/写错误函数就返回真
int ferror( FILE *stream );
//对指定流的错误标准进行重置
void clearerr( FILE *stream );
```

## 15.15 临时文件

- `FILE *tmpfile( void );`
- 这个函数创建一个文件，当文件被关闭或程序终止时这个文件便自动删除
- 该文件以`wb+`模式打开，可用于二进制和文本数据
- 临时文件的名字可以用`char *tmpnam( char *name );`创建

## 15.16 文件操作函数

```
//删除一个指定的文件
int remove( char const *filename );
改变一个文件的名字
int rename( char const *oldname, char const *newname );
```

- 如果执行成功，返回零；失败，返回非零值

## 15.17 总结

- 所有的I/O操作都是一种在程序中移动或移除字节的事物
- 通常一个函数家族的各个变型包括接受一个流参数的函数，一个只用于标准流之一的函数以及一个使用内存中的缓冲区而不是流的函数
- ungetc用于把一个字符退回流中，这个被退回的字符是下一个输入操作所返回的第1个字符，改变流的位置将导致这个被退回的字符被丢弃
- fgets函数更为安全，它把缓冲区长度作为参数之一，因此可以保证一个长输入行不会溢出缓冲区，而且数据不会丢失。长输入行的超出缓冲区的那部分将被fgets下一次调用读取
- gets去除它所读取的行的换行符，puts在写入到缓冲区的文本后加一个换行符
- 二进制I/P直接读写的各个位，而不必把值转换为字符，但二进制输出的结果非人眼所能阅读
- fsetpos函数的参数只有当它是先前一个作用于用一个流的fgetpos的返回值才是合法的
- tmpnam为临时文件创建合适的文件名，这个名字不会与现存的文件名冲突

## 15.18 警告的总结

- 忘了在一条调试用的printf后面跟一个fflush调用
- 在任何scanf系列函数的每个非数组、非指针参数前忘了加上&符号
- 注意在使用scanf系列函数转换double、long double、short、long整型时，在格式代码中加上合适的限定符
- 混淆printf和scanf格式代码
- 在有些长整数长于普通整数的机器上打印长整数值时，忘了在格式代码中指定`l`修改符

## 15.19 编程提示的总结

- 当你打印长整数时，坚持使用`l`修改符可以提高可移植性

# 第16章 标准函数库

## 16.1 整型函数

- 分为三类：算数、随机数、字符串转换

### 16.1.1 算数

```
//绝对值
int abs( int value );
//绝对值，作用对象是长整数
long int labs( long int value );
//即计算numberator/denominator，用一个div_V结构体返回，与/的区别是对运算结果精确定义：如果不能整除，商将是所有小于代数商的整数中最靠近它的那个整数
div_t div ( int numberator, in denominator );
//与div相同，作用对象是长整数
ldiv_t ldiv( long int number, long int denom );
```

### 16.1.2 随机数

- 以下两个函数何在一起使用能够产生伪随机数，“伪”是因为它们通过计算产生随机数，因此可能重复出现，并不是正真的随机数

```
//返回一个范围在0和RAND_MAX（至少为32767）之间的伪随机数
//为了得到一个更小范围的伪随机数，首先把这个函数的返回值根据所需要的范围的大小进行取模，再通过加上或减去一个偏移量进行调整获得
int rand( void );
//该函数使用seed参数对随机数发生器进行初始化
void srand( unsigned int seed );
//一般使用每天的时间作为随机数产生器的种子
srand( ( unsigned int )time( 0 ) );
```

### 16.1.3 字符串转换

```
//把字符转换为整数
int atoi( char const *string );
//把字符转换为长整数
long int atol( char const *string );
/*
把字符转换为长整数
@unused：保存一个指向转换值后面第1个字符的指针unused，这个指针允许字符串的剩余部分进行处理而无需推测转换在字符串的哪个位置终止
@base:转换所执行的基数（即什么进制，例如十进制、二进制），若基数为0，任何在程序中用于书写整数字面值的形式都被接收，包括指定数字基数的形式，如0x2af4和0377；否则基数值应该在2到36的范围内
*/
long int strtol( char const *string, char **unused, int base );
//与strtol相同，但作用对象是无符号长整数
unsigned long int strtoul( char const *string, char **unused, int base );
//x为9947（以12进制来计算），指向字母e的指针保存在*next中
x = strtol( "     590bear", next, 12 );
```

- 若第1个参数包含前导空白字符，将被跳过；存在任何非法尾缀字符，也将被忽略
- 如果这些函数的string不包含一个合法的数值，函数就返回0
- 被转换的值无法表示，则在errno中存储ERANGE这个值，并返回特定值，这些值在[P329,表16.1,strtol和strtoul返回的错误值]中

### 16.2 浮点型函数

- 定义域错误：如果一个函数的参数不在该函数的定义域之内
  - `sqrt( -6.0 );`
  - 当出现定义域错误时，函数返回一个由编译器定义的错误值，并在errno中存储EDOM
- 范围错误：如果一个函数的结果值过大或过小，无法用double类型表示
  - `exp( DBL_MAX )`
  - 值过大，函数将返回HUGE_VAL
  - 值过小，无法用double表示，返回0，但errno会不会设置为ERANGE取决于编译器

### 16.2.1 三角函数

### 16.2.2 双曲函数

### 16.2.3 对数和指数函数

```
//e值的x次幂
double exp( double x );
//x以e为底的对数，loge x
double log( double x );
//x以10为底的对数，log10 x
double log10( double x );
```

### 16.2.4 浮点表示形式

```
double frexp( double value, int *exponent );
double ldexp( double fraction, int exponent );
//把浮点值分成整数和小数两个部分，每个部分具有和原值一样的符号。整数部分以double类型存储于ipart指向的内存位置，小数部分作为函数的返回值返回
double modf( double value, double *ipart );
```

### 16.2.5 幂

```
//x的y次幂
double pow( double x, double y );
//返回x的平方根
double sqrt( double x );
```

### 16.2.6 底数、顶数、绝对值和余数

```
//返回不大于其参数的最大整数值
double floor( double x );
//返回不小于其参数的最小整数值
double ceil( double x );
//返回参数的绝对值
double fabs( double x );
//返回x除以y所产生的余数，这个除法的商被限制为一个整数值
double fnid( double x, double y );
```

### 16.2.7 字符串转换

```
double atof( char const *string);
//将string转换为一个double值，保存一个指向字符串中被转换的值后面的第1个字符的指针
double strtod(char const *string, char **unuserd );
```

- string中前导空白符和缀尾非法字符被忽略
- 如果值太大或太小，无法用double表示，errno存储ERANGE
- 如果值太大，返回HUGE_VAL；值太小，返回零

## 16.3 日期和时间函数

### 16.3.1 处理器时间

```
clock_t clock( void )
```

- 返回值为近似值
- 如果机器无法提供处理器时间或时间值太大，无法用clock_t表示，返回-1
- clock的返回值为处理器时钟滴答的次数，若要转换为秒，要除以常量`CLOCKS_PER_SEC`

### 16.3.2 当天时间

```
time_t time( time_t *returned_value );
```

- 如果参数非NULL，时间值也会存储到参数中
- 无法提供，或值太大，time_t无法表示，返回-1

#### 日期和时间的转换

- 以下的函数用于操作time_h值

```
/
*
返回值为一个指向字符串的指针，字符串的格式为 Sun Jul 4 04:02:48 1976\n\0
该字符串存储在一个静态数组中，下次调用ctime后，旧值会被覆盖
*/
char *ctime( time_t const *time_value );
//计算time1-time2的差，并转为秒
double difftime( time_t time1, time_t time2 );
```

- 以下两个函数把一个time_t结构转换为tm结构
- 月份从0开始计算，即0表示1月，11表示12月
- tm结构的字段位于[P334,表16.2,tm结构的字段]
- tm_year是从1900年后的年数，为了计算实际年份，需要加上1900

```
//转为世界协调世界（UTC），即格林尼治标准时间
struct tm *gmtime( time_t const *time_value );
//转为当地世界
struct tm *localtime( time_t const *time_value );
```

- 当拥有一个tm结构之后，可以使用以下函数

```
//返回一个类似Sun Jul 4 04:02:48 1976\n\0的字符串，与ctime的一样，ctime在内部应该就是调用了asctime实现自己的功能的
char *asctime( struct tm const *tm_ptr );
/*
把tm转换为一个根据某个格式字符串而定的字符串
如果转换结果字符串的长度小于maxsize，则结果字符串复制到string中，返回值为字符串的长度；否则返回-1
*/
size_t strftime( char *string, size_t maxsize, char const *format, struct tm const *tm_ptr );
```

- strftime的格式代码包括一个%字符，位于[P335,表16.3,strftime格式代码]

```
//tm转换为time_t
time_t mktime( struct tm *tm_ptr );
```

## 16.4 非本地跳转

- setjmp和longjmp提供了类似goto语句的机制，但并不局限于一个函数的作用域之内，这些函数常用于深层嵌套的函数连用链

```
int setjmp ( jmp_buf state );
void longjmp( jump_buf state, int value );
```

- 声明一个jmp_buf，并调用setjmp对它进行初始化，setjmp返回零，setjmp把程序的状态信息保存到跳转缓冲区中，你调用setjmp所处的函数称为你的“顶层”函数
- 调用longjmp将导致jmp_buf这个保存的状态重新恢复，longjmp的效果就是使执行流通过再次从setjmp函数返回，从而跳回到顶层函数中
- setjmp第1次被调用时，返回0；当setjmp作为longjmp的执行结果再次返回时，它的返回值是longjmp的第2个参数，它必须是一个非零值

### 16.4.1 实例

```
jmp_buf restart;

int main()
{
    int value;
    //确定一个我们希望在longjmp的调用之后恢复执行的地点
    value = setjmp( restart );
    
    switch( setjmp( restart ) ){
    default:
        //longjmp被调用--致命错误
        break;
    case 1:
        //longjmp被调用---小错误
        break;
    case 0:
        //最初从setjmp返回的地点：执行正常的处理，若出错，调用类似longjmp( restart, 1 );会跳回顶层函数，并调用case 1
    }
}
```

### 16.4.2 何时使用非本地跳转

- 当顶层函数（调用setjmp的那个）返回时，保存在跳转缓冲区的状态信息便不再有效，在此之后再调用longjmp可能失败

## 16.5 信号

- 信号表示一个时间，它可能异步地发生，也就是并不与程序执行过程的任何事件同步
- 如果程序未安排怎样处理一个特定的信号，会做出一个缺省反应，一般缺省反应为终止程序
- 程序可以设置一个信号处理函数，当信号发生时程序就调用这个函数，而不选择缺省反应

### 16.5.1 信号名

- 同步表示信号在程序内部发生
- 异步表示它们在程序的外部产生，通常是程序的用户触发，表示用户试图向程序传递一些信息
- 以下为[P338,表16.4]

| 同步或异步 | 信号    | 含义                   | 产生原因                     |
| :--------- | :------ | :--------------------- | :--------------------------- |
| 同步       | SIGABRT | 程序请求异常终止       | 由abort函数引发              |
| 同步       | SIGFPE  | 发生一个算术错误       | 算术上溢或下溢或除零         |
| 同步       | SIGILL  | 检测到非法指令         | CPU试图执行一条非法的指令    |
| 同步       | SIGSEGV | 检测到对内存的非法访问 | 程序试图非法访问内存         |
| 异步       | SIGINT  | 收到一个交互性注意信号 | 用户试图中断程序             |
| 异步       | SIGTERM | 收到一个终止程序的请求 | 用户另一种请求终止程序的信息 |

- SIGINT和SIGTERM的区别
  - SIGINT定义一个信号处理函数，目的是执行一些日常维护工作并在程序退出前保存数据
  - SIGTERM不配备信号处理函数，这样当程序终止时便不必执行这些日常维护工作

### 16.5.2 处理信号

```
//用于显示地引发一个信号，将引发参数所指定的信号
int raise( int sig );
```

- 当一个信号发生时，程序可以使用三种方式作出反应
  - 缺省：由编译器定义，通常是终止程序
  - 可以被忽略
  - 可以设置一个信号处理函数

```
//用于指定程序希望采取的反应
void ( *signal ( int sig, void ( *handle )( int ) ) )( int );
```

- 下面拆开分析signal函数

```
/*
@sig:为表16.4的信号之一
@void ( *handle )( int ):为sig信号设置的信号处理函数，是一个函数指针。当信号发生时，信号的代码作为参数传递给信号处理函数
*/
signal ( int sig, void ( *handle )( int ) ) 

/*
下面将原型的参数去掉
signal函数返回一个指向该信号以前的处理函数的指针，通过保存这个返回值，可以为信号设置一个处理函数并在将来恢复为先前的处理函数
*/
void ( *signal() )( int );
```

- signal.h还定义了宏

  ```
  SIG_DFL
  ```

  和

  ```
  SIG_IGN
  ```

  ，可以作为siganl函数的第2个参数

  - `SIG_DFL`:恢复对该信号的缺省反应
  - `SIG_IGN`：该信号被忽略

### 16.5.3 信号处理函数

- 当一个已经设置了信号处理函数的信号发生时
  - 首先，恢复对该信号的缺省行为
  - 然后，信号处理函数被调用，信号代码作为参数传递给函数
- 信号处理函数可能执行的工作类型是很有限的
  - 异步信号，不应该调用除siganl之外的任何库函数
  - 信号处理函数除了向一个类型为`volatile sig_atomatic_t`静态变量赋值外，可能无法访问任何其他静态变量
  - 信号处理函数能做的就是对这些变量之一进行设置然后返回
  - 类型`sig_atomatic_t`定义了一种CPU可以以原子方式访问的数据类型

#### 一、volatile数据

- `volatile`关键字告诉编译器，变量的值不能确保在两条相邻的程序语句中具有相同的值，防止编译器以一种可能修改程序含义的方式“优化”程序

#### 二、从信号处理函数返回

- 从一个信号处理函数返回导致程序的执行流从信号发生的地点恢复，这个规则的例外情况是SIGFPE

## 16.6 打印可变参数列表

```
int vprintf( char const *format, va_list arg );
int vfprintf( FILE *stream, char const *format, va_list arg );
int vsprintf( char *buffer, char const *format, va_list arg );
```

- arg参数必须使用`va_start`进行初始化
- 不需要调用`va_end`

## 16.7 执行环境

### 16.7.1 终止执行

- 以下三个函数与正常或不正常的程序终止有关

```
//用于不正常地终止一个正在执行的程序，引发SIGABRT信号，可以设置信号处理函数，在程序终止之前采取任何你想要的动作
void abort( void );
//该函数可以把一些函数注册为退出函数，当程序将要正常终止时，退出函数被调用
void atexit( void (func)( void ) );
/*
用于正常终止程序
如果程序以main函数返回一个值结束，那么其效果相当于用这个值作为参数调用exit函数
*/
void exit( int status );
```

- 当exit函数被调用（函数终止过程）
  - 所有被atexit函数注册为退出函数的函数将按照它们注册的顺序的反序依次调用
  - 所有流的缓冲区被刷新
  - 所有打开文件被关闭
  - 用tmpfile创建的文件被删除
  - 退出状态返回宿主环境，程序停止执行

### 16.7.2 断言

- 断言就是声明某种东西应该为真
- ANSI C实现了一个assert宏
- `void assert( int expression );`
- 当它被执行时，这个宏对表达式参数进行测试。
- 如果为假（零），就向标准错误打印一条诊断信息并终止程序；如果为真（非零），就不打印任何东西，程序继续执行
- `assert( value != NULL );`，如果value为NULL，则会打印`Assertion failed: value != NULL, file.c line 280`
- assert只适合用于验证必须为真的表达式
- 可以在编译时通过定义NDEBUG消除所有的断言，以下任一操作，预处理器将丢弃所有的断言
  - 使用`-D NDEBUG`编译器命令行选项
  - 在源文件中头文件assert.h被包含之前增加`#define NDEBUG`

### 16.7.3 环境

- 环境就是 由一个编译器定义的`名字/值`对的列表
- 该列表由操作系统进行维护
- `getenv`函数在这个列表中查找一个指定的名字，如果找到，返回一个指向其值对应的指针；如果未找到，返回NULL
- `char *getenv( char const *name );`

### 16.7.4 执行系统命令

- system函数把它的字符串参数传递给宿主操作系统，这样它就可以作为一条命令，由操作系统的命令处理器指执行
- `void system( char const *command );`
- system可以用一个NULL参数调用，用于询问命令处理器是否实际存在

### 16.7.5 排序和查找

- qsort函数在一个数组中以升序方式对数据进行排序，和数组中的数据类型无关

```
/*
@base:指向需要排序的数组
@n_elements:指定数组中元素的数目
@el_size:每个元素的长度（以字节为单位）
@compare：函数指针，用于带需要排序的元素进行比较。比较函数返回一个整数，大于零、等于零和小于零分别表示第1个参数大于、等于和小于第2个参数
*/
void qsort( void *base, size_t n_elements, size_t el_size, int (*compare)( void const *, void const * ) );
```

- bsearch函数在一个已经**排好序**的数组中用二分法查找一个特定的元素
- 如果数组未排序，其结果是未定义的

```
/*
@key:指向需要查找的值
@base:指向查找所在的数组
@n_elements:指定数组中元素的数目
@el_size:每个元素的长度（以字节为单位）
@compare：函数指针，用于带需要排序的元素进行比较。比较函数返回一个整数，大于零、等于零和小于零分别表示第1个参数大于、等于和小于第2个参数
@返回值：一个指向查找到的数组元素的指针，若不存在，则返回NULL
*/
void *bsearch( void const *key, void const *base, size_t n_elements, size_t el_size, int (*compare)( void const *, void const * ) );
```

## 16.8 locale

- 为了使C语言在全世界的范围内更为通用，定义了locale标准，是一组特定的参数，每个国家可能各不相同
- 缺省情况下是“C” locale

```
/*
用于修改整个或部分locale
@category:指定locale哪个部分需要修改，可以的值包括LC_ALL：整个locale；LC_COLLATE:对照序列，将影响strcoll和strxfrm函数，更多参照[P346,表16.5,setlocale类型]
@locale:若不是NULL，它指定需要使用的新locale
@返回值：返回一个指向给定类型的当前locale的名字的指针
*/
char *setlocale( int category, char const *locale );
```

### 16.8.1 数值和货币格式

- `struct lconv *localeconv( void );`用于获取根据当前的locale对非货币值和货币值进行核实的格式化所需要的信息，它只提供一些如何进行格式化的信息

### 16.8.2 字符串和locale

- 一台机器的字符集的对照序列是固定的，但locale提供了一种方法指定不同的序列

```
//对两个根据当前locale的LC_CIKKATE类型参数指定的字符串进行比较
int strcoll( char const *s1, char const *s2 );
/*
把根据当前的locale解释的s2转换为另一个不依赖于locale的字符串（把一个当前对照序列的字符串转换为一个位于缺省对照序列的字符串）
尽管转换后的字符串的内容是未确定的，但使用strcmp函数对这种字符串进行比较和使用strcoll对原先的字符串比较的结果是相同的
*/
size_t strxfrm( char *s1, char const *s2, size_t size );
```

### 16.8.3 改变locale的效果

- 可能使得字符集增加字符
- 打印的方向可能会改变
- printf和scanf函数家族使用当前定义的小数点符号
- isalpha、islower、isspace、isupper函数可能比之前包括更多的字符
- 字符集的对照序列可能会改变
- strftime所产生的日期和时间格式的许多方面都是特定于locale的

## 16.9 总结

- div和ldiv用于执行整数除法。和`/`操作符不同，当其中一个参数为负时，商的值是精确定义的
- frexp用于计算一个给定值的表示形式，ldexp用于解释一个表示形式，恢复它的原先值，modf把浮点值分隔成整数和小树部分
- tm结构包含了日期和时间的所有组成部分
- 一个信号处理函数中修改的变量应该声明为`volatile`
- locale包括了
  - 定义数值如何进行格式化的参数，他们描述的值包括非货币值、本地货币值和国际货币值
  - 可以指定一个和机器的缺省序列不同的对照序列

## 16.10 警告的总结

- longjmp不能返回一个已经不再处于活动状态的函数
- 从异步信号的处理函数中调用exit或abort是不安全的（处理函数不要再调用除siganl之外的任何库函数）
- 当每次信号发生时，你必须重新设置信号处理函数
- 避免exit函数的多重调用

# 第17章 经典抽象数据类型

- 经典抽象数据类型有链表、堆栈、队列和树等，链表在第12章已经介绍过，本章会讨论剩余的ADT
- 由于本章是介绍堆栈、队列和树的实现，代码较多，如果复习本章，推荐重看一遍

## 17.1 内存分配

- ADT存储方式：
  - 静态数组：长度固定，长度在编译时确定，最简单最不易出错
  - 动态分配数组：运行时才决定长度，可动态改变数组长度
  - 动态分配链式结构：最大灵活性，需要时才单独分配，但链式结构的链接字段需要消耗一定的内存，访问特定元素的效率不如数组

## 17.2 堆栈

- 堆栈特点：后进先出（Last-In First-Out,LIFO）

### 17.2.1 堆栈接口

- 传统接口
  - push：把一个新值压入到堆栈的顶部
  - pop：把堆栈顶部的值移出堆栈并返回这个值
- 另一类堆栈接口
  - push：把一个新值压入到堆栈的顶部
  - pop：把堆栈顶部的值移出堆栈但不返回这个值
  - top：返回顶部的值，但不把顶部元素移除
- 还需要两个额外的函数:堆栈是否为空、堆栈是否已满

#### 一、数组堆栈

- 所有不属于外部接口的内容都声明为static，可以防止用于使用预定义接口之外的任何方式访问堆栈中的值
- 数组实现的堆栈使用下标记录栈的顶部，这个值的初始化为`static int top_element = -1`

#### 二、动态数组堆栈

- 动态数组堆栈还需要
  - 创建堆栈函数`void create_stack( size_t size );`
  - 销毁堆栈函数`void destroy_stack( void );`

#### 三、链式堆栈

- 不再需要`create_stack`函数，但可以实现`destroy_stack`函数用于清除堆栈
- 由于链式堆栈不会填满，所以`is_full`函数始终返回假

## 17.3 队列

- 队列是 一种先进先出（First-In First-Out,FIFO）的结构

### 17.3.1 队列接口

- 插入和删除函数并没有被普遍接受的名字
- 对于插入应该在队列的头部还是在尾部也没有完全一致的意见，在队列的尾部插入以及在头部删除更容易记忆
- 传统接口：delete函数从队列的头部删除一个元素并将其返回
- 另一种接口：delete函数从队列的头部删除一个元素，但并不返回它；first函数返回第1个元素但并不将它从队列删除

### 17.3.2 实现队列

- 让队列的尾部“环绕”到数组的头部，新元素可以存储到以前删除元素所留出来的空间，这个方法称为循环数组
- 有两种方法实现循环：

```
//下面定义的QUEUE_SIZE都表示数组的长度
//方法1：
rear += 1;
if( rear >= QUEUE_SIZE )
    rear = 0;

//方法2：
rear = ( rear + 1 ) % QUEUE_SIZE;
```

- 判断队列是否为空、是否已满也有两种方法
  - 方法1：引入新的变量，用于记录队列中的元素数量
  - 方法2：重新定义“满”的含义，使数组中的一个元素始终保持不用

```
//方法2：
//队列为空
( rear + 1 ) % QUEUE_SIZE == front
//队列已“满”
( rear + 2 ) % QUEUE_SIZE == front
```

## 17.4 树

- 二叉搜索树（binarg search tree，BST）
- 树是一种数据结构，它要么为空，要么具有一个值并具有零个或多个孩子，每个孩子本身也是树
- 二叉树是树的一种特殊形式，它的每个节点至多具有两个孩子，分别称为左孩子和右孩子
- 二叉搜索树具有额外的属性：每个节点的值比它的左子树的所有节点的值都要大，但比它的右子树的所有节点的值都要小
- 没有孩子的节点称为叶节点或叶子

### 17.4.1 在二叉树搜索树中插入

- 基本算法如下：

```
如果树为空：
    把新值作为根节点插入
否则：
    如果新值小于当前节点的值：
        把新值插入到当前节点的左子树
    否则：
        把新值插入到当前节点的右子树
```

### 17.4.2 从二叉搜索树删除节点

- 处理三种情况：
  - 删除没有孩子的节点：删除一个叶节点不会导致任何子树断开，所以不存在重新连接的问题
  - 删除只有一个孩子的节点：把这个节点的双亲节点和它的孩子连接起来
  - 删除有两个孩子的节点：不删除这个节点，删除它的左子树中值最大的那个节点，并用这个值替代原先应被删除的那个节点的值

### 17.4.3 在二叉搜索树中查找

- 基本算法如下：

```
如果树为空：
    这个值不存在于树中
否则：
    如果这个值和根节点的值相等：
        成功找到这个值
    否则：
        如果这个值小于根节点的值：
            查找左子树
        否则：
            查找右子树
```

### 17.4.4 树的遍历

- 遍历方法包括：前序、中序、后序和层次遍历，可以从树的根节点或你希望开始遍历的子树的根节点开始
  - 前序（pre-order）：`根->左->右`
  - 中序（in-order）：`左->根->右`
  - 后序（post-order）：`左->右->根`
  - 层次遍历（breadth-first）：逐层检查树的节点，一层从左到右扫过

### 17.4.6 实现二叉搜索树

#### 一、数组形式的二叉搜索树

- 用数组表示数的关键是使用下标来寻找某个特定值的双亲和孩子

```
//从数组下标1开始计算的树
节点N的双亲节点N/2（整除操作符将截取小数部分）
节点N的左孩子是节点2N
节点N的右孩子节点2N+1
//从数组下标0开始计算的树
节点N的双亲节点(N+1)/2-1（整除操作符将截取小数部分）
节点N的左孩子是节点2N+1
节点N的右孩子节点2N+2
```

- 数组形式的树问题在于数组空间常常利用得不够肠粉，空间被浪费是由于新值必须插入到树中特定的位置，无法随便防止到数组中的空位置
- 不平衡的树空间浪费严重

#### 二、链式二叉搜索树

- 链式实现消除了数组空间利用不充分的问题

#### 三、树接口的变型

- find函数只用于验证值是否存在于树中
- 树中的元素实际上是一个结构，它包括一个关键值和一些数据
- find函数必须设法比较每个节点元素的关键值部分，解决办法是编写一个函数执行这个比较
- TreeNode结构和指向树根节点的指针都必须声明为公用，以便用户遍历该树
- 通过函数向用户提供根指针，可以防止用户自行修改根指针，从而导致丢失整棵树

## 17.5 实现的改进

### 17.5.4 标准函数库的ADT

- 泛型是一种编写一组函数，但数据类型暂时可以不确定的能力，这组函数随后用用户需要的不同类型进行实例化或创建，但C语言未提供泛型，可以用`#define`定义近似地模拟这种机制
- 泛型是面向对象编程语言处理得比较完美的问题之一

## 17.6 总结

- 数组可以用于实现BST，但如果树不平衡，会浪费很多内存空间，链式BST可以避免这种浪费

# 第18章 运行时环境

## 18.1 判断运行时环境

- 第1步：从你的编译器获得一个汇编语言列表
- 第2步：阅读你的机器上的汇编语言代码

### 18.1.1 测试程序

- C代码

```
//静态初始化
int static_variable = 5;

void f()
{
    register int i1, i2, i3, i4, i5, i6, i7, i8, i9, i10;
    register char *c1, *c2, *c3, *c4, *c5, *c6, *c7, *c8, *c9, *c10;
    extern inta_very_long_name_to_see_how_long_they_can_be;
    double dbl;
    intfunc_ret_int();
    double func_ret_double();
    char *func_ret_char_ptr();
    
    //寄存器变量的最大数量
    i1 = 1; i2 = 2; i3 = 3; i4 = 4; i5 = 5;
    i6 = 6; 71 = 7; i8 = 8; i9 = 9; i10 = 10;
    c1 = (char *)110; c2 = (char*)120;
    c3 = (char *)130; c4 = (char*)140;
    c5 = (char *)150; c6 = (char*)160;
    c7 = (char *)170; c8 = (char*)180;
    c9 = (char *)190; c10 = (char*)200;
    
    //外部名字
    int a_very_long_name_to_see_how_long_they_can_be = 1;
    
    //函数调用/返回协议，堆栈帧（过程活动记录）
    i2 = func_ret_int( 10, i1, i10 );
    db1 = func_ret_double();
    c1 = func_ret_char_ptr( c1 );
}

int
func_ret_int( int a, int b, register int c )
{
    int d;
    
    d = b - 6;
    return a + b + c;
}

double 
func_ret_double()
{
    return 3.14;
}

char *
func_ret_char_ptr( char *cp )
{
    return cp + 1;
}
```

- 汇编代码

```
    .data
    .even
    .global _static_variable
_static_variable:
    .long 5
    .text
    
    .globl _f
_f: 
    link   a6, #-88
    moveml #0x3cfc,sp@
    moveq  #1,d7
    moveq  #2,d6
    moveq  #3,d5
    moveq  #4,d4
    moveq  #5,d3
    moveq  #6,d2
    movl   #7,a6@(-4)
    movl   #8,a6@(-8)
    movl   #9,a6@(-12)
    movl   #10,a6@(-16)
    movl   #110,a5
    movl   #120,a4
    movl   #130,a3
    movl   #140,a2
    movl   #150,a6@(-20)
    movl   #160,a6@(-24)
    movl   #170,a6@(-28)
    movl   #180,a6@(-32)
    movl   #190,a6@(-36)
    movl   #200,a6@(-40)
    movl   #1,_a_very_long_name_to_see_how_long_they_can_be
    movl   a6@(-16),sp@-
    movl   d7,sp@-
    pea    10
    jpsr   _func_ret_int
    lea    sp@(12),sp
    movl   d0,d6
    jpsr   _func_ret_double
    movl   d0,a6@(-48)
    movl   d1,a6@(-44)
    pea    a5@
    jpsr   _func_ret_char_ptr
    addqw  #4,sp
    movl   d0,a5
    moveml a6@(-88),#0x3cfc
    unlk   a6
    rts
    
    .globl _func_ret_int
_func_ret_int:
    link   a6, #-8
    moveml #0x80,sp@
    movl   a6@(16),d7
    movl   a6@(12),d0
    subql  #6,d0
    movl   d0,a6@(-4)
    movl   a6@(8),d0
    addl   a6@(12),d0
    addl   d7,d0
    moveml a6@(-8),#0x80
    unlk   a6
    rts
    
    .globl _func_ret_double
_func_ret_double:
    link   a6, #0
    moveml #0,sp@
    movl   L2000000,d0
    movl   L2000000+4,d1
    unlk   a6
    rts
L2000000:.long  0x40091eb8,0x51eb851f

    .globl _func_ret_char_ptr
_func_ret_char_ptr:
    link   a6, #0
    moveml #0,sp@
    movl   a6@(8),d0
    addql  #1,d0
    unlk   a6
    rts
```

### 18.1.2 静态变量和初始化

```
//静态初始化
int static_variable = 5;
    .data   //进入程序的数据区
    .even   //确保变量开始于内存的偶数地址
    .global _static_variable    //变量被声明为全局类型，变量名以下划线开始
_static_variable:   //编译器为变量创建空间
    .long 5     //进行初始化
```

### 18.1.3 堆栈帧

- 一个函数分为三个部分：
  - 函数序：用于执行函数启动需要的一些工作,如为局部变量保留堆栈中的内存
  - 函数体：用于执行有用工作的地方
  - 函数跋：用于在函数即将返回之前清理堆栈

```
void f()
{
    register int i1, i2, i3, i4, i5, i6, i7, i8, i9, i10;
    register char *c1, *c2, *c3, *c4, *c5, *c6, *c7, *c8, *c9, *c10;
    extern inta_very_long_name_to_see_how_long_they_can_be;
    double dbl;
    intfunc_ret_int();
    double func_ret_double();
    char *func_ret_char_ptr();
    .text   //表示进入程序的代码（文本）段
    
    .globl _f   //函数名的全局声明，也有下划线
_f: 
    link   a6, #-88     //第1条可执行指令，为函数创建堆栈帧，堆栈帧是堆栈中的一个区域，函数在那里存储变量和其他值（寄存器），link在堆栈帧中保留了88个字节的空间，用于存储局部变量和其他值
    /*
    把指定寄存器中的旧值复制到堆栈中，68000处理器有8个用于操作数据的寄存器,d0至d7；8个用于操作地址的寄存器，a0至a7
    0x3cfc即二进制0011110011111100，分别表示[a7,a6,a5,a4,a3,a2,a1,a0,d7,d6,d5,d4,d3,d2,d1,d0]的使用情况
    可以看到d2至d7、a2至a5需要被存储，被存储的即时“其他值”
    */
    moveml #0x3cfc,sp@  
```

- 局部变量声明和函数原型不会产生任何汇编代码,所以下面这些C代码不会产生汇编代码。

```
register int i1, i2, i3, i4, i5, i6, i7, i8, i9, i10;
    register char *c1, *c2, *c3, *c4, *c5, *c6, *c7, *c8, *c9, *c10;
    extern inta_very_long_name_to_see_how_long_they_can_be;
    double dbl;
    intfunc_ret_int();
    double func_ret_double();
    char *func_ret_char_ptr();
```

- 如果任何局部变量在声明时进行了初始化，那么这里也会出现指令用于执行赋值操作

### 18.1.4 寄存器变量

```
    //寄存器变量的最大数量
    i1 = 1; i2 = 2; i3 = 3; i4 = 4; i5 = 5;
    i6 = 6; 71 = 7; i8 = 8; i9 = 9; i10 = 10;
    c1 = (char *)110; c2 = (char*)120;
    c3 = (char *)130; c4 = (char*)140;
    c5 = (char *)150; c6 = (char*)160;
    c7 = (char *)170; c8 = (char*)180;
    c9 = (char *)190; c10 = (char*)200;
    moveq  #1,d7    //值1至6倍存放在数据寄存器，最多只有6个整型值可以被存放在数据寄存器
    moveq  #2,d6
    moveq  #3,d5
    moveq  #4,d4
    moveq  #5,d3
    moveq  #6,d2
    /*
    7至10倍存放在其他地方
    a6称为帧指针，它指向堆栈帧内部的一个“引用”位置，堆栈中的所有值都是通过这个引用位置加上一个偏移量进行访问的
    a6@(-4)表示偏移地址-4
    使用偏移地址，可以建立一张映射表，准地地显示堆栈中的每个值相对于帧指针a6的位置
    */
    movl   #7,a6@(-4)   
    movl   #8,a6@(-8)
    movl   #9,a6@(-12)
    movl   #10,a6@(-16)
    movl   #110,a5      //前4个值被存放在地址寄存器，最多运行4个指针变量放在寄存器，指针的长度是固定的，任何类型的指针都可以放在寄存器中
    movl   #120,a4
    movl   #130,a3
    movl   #140,a2
    movl   #150,a6@(-20)    //被存放在其他地方
    movl   #160,a6@(-24)
    movl   #170,a6@(-28)
    movl   #180,a6@(-32)
    movl   #190,a6@(-36)
    movl   #200,a6@(-40)
```

- 前面提到的`moveml #0x3cfc,sp@`即是将寄存器的旧值保存到堆栈中，函数必须对任何将用于存储寄存器变量的寄存器进行保存，这样它们原先的值可以在函数返回到调用函数前恢复，即`moveml a6@(-88),#0x3cfc`语句，这样就能保留调用函数的寄存器变量
- d0-d1、a0-a1以及a6-a7并未用于存储寄存器
  - a6用作帧指针，即平时所说的ebp
  - a7是堆栈指针（别名SP），即平时所说的esp
  - d0、d1用于从函数返回值
  - a0、a1用于其他某种目的

### 18.1.5 外部标识符的长度

```
	//外部名字
    int a_very_long_name_to_see_how_long_they_can_be = 1;
    movl   #1,_a_very_long_name_to_see_how_long_they_can_be
```

- 外部名字的最终限制是链接器施加的，它很可能接收任何长度的名字但忽略除前几个字符以外的其他字符

### 18.1.6 判断帧布局

- 运行时堆栈保存了每个函数运行时所需要的数据，包括它的自动变量和返回值
- 下面将分析两个部分
  - 堆栈帧的组织形式
  - 调用和从函数返回的协议

#### 一、传递函数参数

```
//函数调用/返回协议，堆栈帧（过程活动记录）
    i2 = func_ret_int( 10, i1, i10 );
    movl   a6@(-16),sp@-    //i10存在a6@(-16)，所以是把参数i10压入堆栈
    movl   d7,sp@-  //i1存在d7，所以是把i1压入堆栈
    pea    10   //pea指令简单地把它的操作数压入堆栈，所以这里将参数10压入堆栈
    /*
    跳转子程序，把返回值压入到堆栈中（即main函数中_func_ret_int函数返回后下一条指令的地址），并跳转到_func_ret_int的起始位置
    当被调用函数结束任务后需要返回到它的调用位置，需要用到压入到堆栈中的返回值
    堆栈的情况如图18.2所示
    */
    jpsr   _func_ret_int    
```

- 图18.1显示了到目前为止所创建的内容
  - 低内存地址位于顶部而高内存地址位于底部
  - 当值压入堆栈时，堆栈向低地址方向生长（向上）
  - 在原先的堆栈指针以下的内容是未知的

![图18.1 压入参数后的堆栈帧](./C语言高级特性(三剑客总结)/img_18_1-1700210789486-163.png)

![图18.2 在跳转子程序指令之后的堆栈帧](./C语言高级特性(三剑客总结)/img_18_2-1700210789486-165.png)

#### 二、函数序

- 接下来，执行流来到被调用函数的函数序：

```
int
func_ret_int( int a, int b, register int c )
{
    int d;
    .globl _func_ret_int
_func_ret_int:
    /*
    link指令分成三步
    1.a6的内容被压入到堆栈中（旧的a6值被压入）
    2.堆栈指针的当前值被复制到a6（a6指向SP当前位置，当前位置为a6@(0)，也就是将当前栈顶变为新的栈底），图18.3显示了目前为止的堆栈帧状态
    3.link指令从堆栈指针中减去8（SP指向a6@(-8)），这将创建空间用于保存局部变量和被保存的寄存器的旧值，图18.4显示了目前为止的堆栈帧状态
    */
    link   a6, #-8
    /*
    0x80二进制为10000000，表示[d7,d6,d5,d4,d3,d2,d1,d0]的使用情况，所以这里是把d7寄存器的旧址存储在堆栈的顶部，它提示堆栈帧的顶部就是寄存器值保存的位置
    */
    moveml #0x80,sp@    
    /*
    从堆栈把第三个参数复制到d7，因为第三个参数声明为寄存器变量
    从图18.4.1可以看到参数的偏移值
    */
    movl   a6@(16),d7   
```

![图18.3 link指令期间的堆栈帧](./C语言高级特性(三剑客总结)/img_18_3-1700210789486-166.png)

![图18.4 link指令之后的堆栈帧](./C语言高级特性(三剑客总结)/img_18_4-1700210789486-167.png)

- 图18.4.1如下

![图18.4.1](./C语言高级特性(三剑客总结)/img_18_4_1-1700210789486-168.png)

#### 三、堆栈中的参数次序

- 被调用函数使用帧指针（a6）加一个偏移量来访问参数
- 当参数以反序压入到堆栈时，参数列表的第1个参数便位于堆栈中这堆参数的顶部，它距离帧指针的偏移量是一个常数。任何一个参数距离帧指针的偏移量都是一个常数，这和堆栈中压入多少个参数并无关系
- 如果参数以相反的顺序（正序）压入到堆栈中，第1个参数距离帧指针的偏移量就和压入到堆栈的参数数量有关

#### 四、最终的堆栈布局

```
    d = b - 6;
    return a + b + c;
}
    movl   a6@(12),d0   //把第2个参数复制到d0，即参数b
    subql  #6,d0    //将d0中的值减去6，即 b - 6
    movl   d0,a6@(-4)   //将结果存储到布局变量d，即 d = b - 6
    movl   a6@(8),d0    //将a的值放到d0
    addl   a6@(12),d0   //将a6@(12)的值与d0相加，即 a + b
    addl   d7,d0    //将d7中的值与d0相加，即 a + b + c，这个运行结果存放在d0中，之后return的时候会用到
    ------------------------------------从下面开始为函数跋
    moveml a6@(-8),#0x80
    unlk   a6
    rts
```

- 从上面可以看出，d0的作用，其实d0主要有两个作用，这两个作用也是它不能用于存放寄存器变量的原因之一：
  - 计算过程中的“中间结果暂存器”或临时位置，即上面汇编代码中看到的
  - 存返回值，后文将看到

#### 五、函数跋

```
    /*
    用于恢复以前被保存的寄存器值
    如图18.4.1所示，a6@(-8)指向寄存器旧值
    将这个旧值恢复到d7中
    */
    moveml a6@(-8),#0x80    
    unlk   a6   //把a6的值复制给堆栈指针SP，并把从堆栈中弹出的a6旧值装入a6中，这时SP指向原a6@(0)位置
    rts     //通过把返回地址从堆栈中弹出到程序计数器，从而从该函数返回，这时SP指向原a6@(4)位置
```

- 下面执行流将从调用程序的地点继续。注意此时堆栈尚未被完全清空（参数还没清空）

```
    i2 = func_ret_int( 10, i1, i10 );
    /*
    把12加到堆栈指针，在此之前SP指向原a6@(4)，在此之后SP指向原a6@(16)
    三个参数值从堆栈中弹出
    在此之前，被调用函数并没有从堆栈中完全清除它的整个堆栈帧，参数还留在那里等待调用函数清除
    */
    lea    sp@(12),sp
    movl   d0,d6    //把d0的值复制到d6中，即把d0的值复制到变量i2
```

#### 六、返回值

- 函数跋并没有使用d0，因此它依然保存着函数的返回值
- 函数返回一个值时把它放在d0，这是d0不能用于存放寄存器变量的另一个原因



- 下一个被调用的函数返回一个double值

```
    db1 = func_ret_double();
    c1 = func_ret_char_ptr( c1 );
    /*
    这个函数没有任何参数，所以没有什么东西被压入到堆栈中
    */
    jpsr   _func_ret_double
    /*
    double长度是8个字节，无法放入一个寄存器中
    因此要返回这种类型的值，必须同时使用d0和d1寄存器
    */
    movl   d0,a6@(-48)  
    movl   d1,a6@(-44)
    
    //函数_func_ret_char_ptr说明了指针变量是如何返回的
    pea    a5@  //将参数c1压入堆栈
    jpsr   _func_ret_char_ptr   //跳转子程序
    addqw  #4,sp    //将参数c1弹出堆栈
    movl   d0,a5    //将返回值复制到a5，即变量c1
```

### 18.1.7 表达式的副作用

```
//尽管这个函数存在一个巨大错误，但仍然能在某些机器上正确地运行
int
erroneous( int a, int b )
{
    int x;
    
    x = a + b;
    //这里返回语句没有指定返回哪个变量的值
    return;
}
```

- 这个函数实际上可以返回计算结果的值
- d0被用于计算x，并且由于这个表达式是最后进行求值的，所以当函数结束时d0仍然保存了这个结果值
- 这个函数很意外地调用函数返回了正确的值
- 若在return语句之前加入`a + 3;`，那么d0倍修改，就会返回错误的值

## 18.2 C和汇编语言的接口

- 为了编写能够调用C程序或被C程序调用的汇编语言，必须遵守的规则
  - 汇编程序中的名字必须遵循外部标识符的规则，例如以一个下划线开始
  - 汇编程序必须遵循正确的函数调用/返回协议
- 为了编写一个由C程序调用的汇编程序
  - 保存任何你希望修改的寄存器（除d0、d1、a0和a1之外）
  - 参数值从堆栈中获得，因为调用它的C函数把参数压入到堆栈中
  - 如果函数应该返回一个值，它的值应该保存在d0中（在这种情况下，d0不能进行保存和恢复）
  - 在返回之前，函数必须清除任何它压入到堆栈中的内容
- 在一个由C程序调用的汇编程序里，你必须访问C函数放置在那里的参数
- 以下为C程序调用汇编程序的例子

```
//C代码
sum = sum_three_values( 25, 14, -6 );
//汇编代码
    .text
    
    .globl  _sum_three_values
_sum_three_values:
    movl    sp@(4),d0   //第1个参数复制到d0中
    addl    sp@(8),d0   //d0与第2个参数相加
    addl    sp@(12),d0  //d0与第2个参数相加
    rts                 //函数返回
```

## 18.3 运行时效率

- 虚拟内存是由操作系统实现的，它需要把程序的活动部分放入内存并把不活动的部分复制到磁盘中，这样就允许系统允许大型的程序
- 由于虚拟内存，随着程序的增大，它的执行效率逐渐降低

## 18.5 警告的总结

- 是链接器而不是编译器决定外部标识符的最大长度
- 你无法链接由不同编译器产生的程序