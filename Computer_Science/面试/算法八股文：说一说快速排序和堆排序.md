# ç®—æ³•å…«è‚¡æ–‡ï¼šè¯´ä¸€è¯´å¿«é€Ÿæ’åºå’Œå †æ’åº

## å¿«é€Ÿæ’åº

â€‹	å¿«é€Ÿæ’åºçš„åŸºæœ¬æ€è·¯å…¶å®ä¸éš¾ï¼Œæ€»ä½“è€Œè¨€ï¼Œæ€è·¯å°±æ˜¯åˆ†è€Œæ²»ä¹‹ï¼Œé€’å½’æ±‚è§£

> ä»åºåˆ—ä¸­é€‰å‡ºä¸€ä¸ªâ€œ**åŸºå‡†å€¼ï¼ˆpivotï¼‰**â€ï¼Œå°†æ•°ç»„åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä½¿å¾—ï¼š
>
> - å·¦è¾¹æ‰€æœ‰å…ƒç´  â‰¤ pivotï¼›
> - å³è¾¹æ‰€æœ‰å…ƒç´  â‰¥ pivotï¼›
>
> ç„¶åå¯¹è¿™ä¸¤éƒ¨åˆ†åˆ†åˆ«é€’å½’æ’åºã€‚

â€‹	æ‰€ä»¥ï¼Œç°åœ¨æˆ‘ä»¬å®é™…ä¸Šåˆ†å‡ºæ¥äº†ä¸‰ä¸ªæ­¥éª¤ï¼š

- Partitionï¼šå¯¹pivotå·¦å³ä¸¤ä¾§çš„æ•°è¿›è¡Œæ’åºï¼Œ
- ç”±Partitionæ­¥éª¤è¿”å›æœ€ç»ˆçš„Indexï¼Œä½œä¸ºæ–°çš„pivot
- å†é€’å½’çš„å¯¹å·¦å³è¿›è¡Œæ’åº

### Partitionè¿™ä¸ªæ­¥éª¤

â€‹	Partitionå°±æ˜¯ç®€å•çš„é€‰å®šä¸€ä¸ªpivotï¼Œç„¶åå°†æ¯”è¿™ä¸ªæ•°å°çš„å·¦ä¾§æ”¾åˆ°pivotçš„å·¦è¾¹ï¼Œæ¯”è¿™ä¸ªæ•°å¤§çš„æ”¾åˆ°å³è¾¹ï¼Œæˆ‘ä»¬åˆå§‹å°† pivot æ”¾åœ¨æœ€å³ä¾§ï¼Œå¾ªç¯è¿‡ç¨‹ä¸­æš‚ä¸åŠ¨å®ƒï¼Œç­‰åˆ°åˆ†ç±»å®Œæˆåå†å½’ä½ï¼ˆç¬”è€…ä¹ æƒ¯é€‰åœ¨æœ€å·¦ä¾§ï¼‰è¿™æ ·å°±æ»¡è¶³äº†æˆ‘ä»¬çš„æ¡ä»¶äº†

```cpp
int partition(std::vector<int>& vec, int left, int right) {
	int prev_pivot_value = vec[right]; // æˆ‘ä»¬æ€»æ˜¯é€‰æ‹©æœ€å³ä¾§çš„æ¸¸æ ‡æ¥å®Œæˆæˆ‘ä»¬çš„å·¥ä½œ
	int new_pivot = left; // æˆ‘ä»¬è®¾ç½®å·¦è¾¹çš„å°±æ˜¯æ–°çš„æ¸¸æ ‡

	for (int i = left; i < right; i++) {
		if (vec[i] < prev_pivot_value) {
			std::swap(vec[new_pivot], vec[i]); // äº¤æ¢ï¼Œå› ä¸ºç«™é”™ä½ç½®äº†
			new_pivot++;
		}
	}
	std::swap(vec[new_pivot], vec[right]); // äº¤æ¢ä¸€ä¸‹ï¼Œå°†pivotè¿›è¡Œå½’ä½ï¼Œè¿™æ˜¯æˆ‘ä»¬çš„æ–°pivotä¸‹è¡¨
	return new_pivot; // åå‡ºå»ï¼Œåé¢åˆ†æ²»ä½¿ç”¨
}
```

â€‹	æˆ‘ä»¬æ‹¿åˆ°äº†æ–°æ¸¸æ ‡ä¹‹åï¼Œå°±æ˜¯è¿›è¡Œå·¦å³çš„é€’å½’æ’åºï¼š

```cpp
void my_quick_sort(std::vector<int>& vec, int left, int right) {
	if (left >= right)
		return; // only one left, we dont need to sort
	int new_pivot = partition(vec, left, right);

	// sort left
	my_quick_sort(vec, left, new_pivot - 1);
	my_quick_sort(vec, new_pivot + 1, right);
}
```

â€‹	è¿™æ ·æˆ‘ä»¬çš„å¿«æ’å°±å†™å¥½äº†ã€‚é€’å½’çš„è§¦æ§æ¡ä»¶å°±æ˜¯ï¼šå‰©ä¸‹ä¸€ä¸ªçš„æ•°ç»„å¤©ç„¶æœ‰åºï¼Œç›´æ¥é€€å‡ºå»å°±å¥½äº†ã€‚

## æ”¹è¿›æˆ‘ä»¬çš„å¿«é€Ÿæ’åº

### 1ï¸âƒ£éšæœºåŒ–åŸºå‡†å€¼ï¼šé˜²æ­¢åœ¨è¿‘ä¼¼æœ‰åºçš„æƒ…å†µä¸‹å‘ç”ŸO(N^2é€€åŒ–)

â€‹	å½“è¾“å…¥æ•°ç»„æ˜¯**æœ‰åº/è¿‘ä¹æœ‰åº**æ—¶ï¼Œå¦‚æœæ€»æ˜¯é€‰æ‹©æœ€å·¦æˆ–æœ€å³ä½œä¸º pivotï¼Œæ—¶é—´å¤æ‚åº¦é€€åŒ–ä¸º **O(nÂ²)**ã€‚è¿™ä¸ªæ—¶å€™é—®é¢˜ä¹Ÿå¾ˆç®€å•ï¼Œå’±ä»¬éšä¾¿é€‰ä¸€ä¸ªå°±è¡Œäº†

- åœ¨ `left ~ right` åŒºé—´å†…**éšæœºé€‰ä¸€ä¸ªå…ƒç´ ä½œä¸º pivot**
- ç„¶åå°†å…¶ä¸ `right` ä½ç½®å…ƒç´ äº¤æ¢ï¼Œç…§å¸¸æ‰§è¡Œ

```cpp
int random_partition(std::vector<int>& vec, int left, int right) {
    int rand_idx = left + rand() % (right - left + 1); // [left, right]
    std::swap(vec[rand_idx], vec[right]);
    return partition(vec, left, right); // ç”¨æˆ‘ä»¬ä¹‹å‰é‚£ä¸ª partition
}
```

### 2ï¸âƒ£ **ä¸‰æ•°å–ä¸­æ³•ï¼ˆMedian-of-Threeï¼‰**

- ä¹‹å‰ä»‹ç»çš„éšæœºæ•°å¯èƒ½ä»ä¸ç¨³å®šï¼ˆæœ¬è´¨ä¸Šåªæ˜¯åˆ©ç”¨äº†éšæœºåŒ–äº‰å–æœ€å¤§å¯èƒ½çš„ä¸å¤±è¡¡ï¼‰
- ä¸‰æ•°å–ä¸­æ³•åœ¨è®¸å¤šå®é™…åœºæ™¯ä¸‹æ¯”éšæœºæ³•æ›´å¥½ï¼ˆç‰¹åˆ«æ˜¯è¿‘ä¹æœ‰åºçš„æ•°æ®ï¼‰

â€‹	å®é™…ä¸Šå°±æ˜¯åœ¨å·¦ä¸­å³ä¸‰ä¸ªéƒ¨åˆ†ä¸Šå–å‡ºæ¥ä¸­é—´å€¼

```
int median_of_three(std::vector<int>& vec, int left, int right) {
    int mid = left + (right - left) / 2;
    if (vec[left] > vec[mid]) std::swap(vec[left], vec[mid]);
    if (vec[left] > vec[right]) std::swap(vec[left], vec[right]);
    if (vec[mid] > vec[right]) std::swap(vec[mid], vec[right]);
    std::swap(vec[mid], vec[right]); // æŠŠä¸­ä½æ•°æ”¾åˆ° right å½“ pivot
    return partition(vec, left, right);
}
```

### 3ï¸âƒ£ **å°æ•°ç»„æ”¹ç”¨æ’å…¥æ’åºï¼ˆHybrid Sortï¼‰**

â€‹	å¿«é€Ÿæ’åºåœ¨å¤„ç†**å°è§„æ¨¡å­æ•°ç»„**æ—¶ï¼ˆä¾‹å¦‚å…ƒç´ æ•° â‰¤ 16ï¼‰ï¼Œé€’å½’å¸¦æ¥çš„å¼€é”€åè€Œæ¯”æ’å…¥æ’åºæ…¢ã€‚è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å°±å¯ä»¥è€ƒè™‘å¯¹å°è§„æ¨¡æ•°ç»„æ”¹ç”¨å †æ’åºæˆ–è€…æ˜¯æ’å…¥æ’åºã€‚

```cpp
void insertion_sort(std::vector<int>& vec, int left, int right) {
    for (int i = left + 1; i <= right; ++i) {
        int key = vec[i];
        int j = i - 1;
        while (j >= left && vec[j] > key) {
            vec[j + 1] = vec[j];
            j--;
        }
        vec[j + 1] = key;
    }
}

void hybrid_quick_sort(std::vector<int>& vec, int left, int right) {
    const int threshold = 16;
    if (right - left <= threshold) {
        insertion_sort(vec, left, right);
        return;
    }

    int pivot_index = median_of_three(vec, left, right);
    hybrid_quick_sort(vec, left, pivot_index - 1);
    hybrid_quick_sort(vec, pivot_index + 1, right);
}
```

> ğŸ“Œ å®é™…çš„ `std::sort()` å°±æ˜¯è¿™ç§ï¼šä¸‰æ•°å–ä¸­ + æ’æ’ + å †æ’ çš„æ··åˆç‰ˆï¼ˆIntroSortï¼‰

| ä¼˜åŒ–ç­–ç•¥     | ç›®çš„               | é€‚ç”¨åœºæ™¯           |
| ------------ | ------------------ | ------------------ |
| éšæœºåŒ– pivot | é¿å…æœ€åæƒ…å†µ O(nÂ²) | æ•°æ®è¿‘ä¹æœ‰åºæ—¶     |
| ä¸‰æ•°å–ä¸­     | æ›´ç¨³å®šé€‰æ‹© pivot   | å·¥ä¸šçº§å¿«æ’æ ‡å‡†é…ç½® |
| å°æ•°ç»„ç”¨æ’æ’ | å¸¸æ•°å¼€é”€å°         | å­æ•°ç»„å…ƒç´  â‰¤ 16    |

------

## å †æ’åº

### ä»€ä¹ˆæ˜¯å †ï¼Ÿ

â€‹	å †ï¼ˆHeapï¼‰å®é™…ä¸Šæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å®Œå…¨äºŒå‰æ ‘ï¼ˆé™¤äº†æœ€åä¸€å±‚ä¹‹å¤–ï¼Œæ‰€æœ‰çš„èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œä¸”æœ€åä¸€å±‚çš„èŠ‚ç‚¹éƒ½å°½å¯èƒ½åœ°é å·¦æ’åˆ—ã€‚ï¼‰

â€‹	è€Œä¸”ï¼Œä»–ä¼šæ»¡è¶³ä¸‹é¢æ€§è´¨ä¸­çš„å…¶ä¸­ä¸€ä¸ªï¼š

- **å¤§é¡¶å †ï¼ˆæˆ–æœ€å¤§å †ï¼‰**ï¼šæ¯ä¸ªçˆ¶èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæˆ–ç­‰äºå…¶å­èŠ‚ç‚¹çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ**æœ€å¤§çš„å…ƒç´ æ°¸è¿œåœ¨æ ‘çš„é¡¶ç«¯**ï¼ˆæ ¹èŠ‚ç‚¹ï¼‰ã€‚
- **å°é¡¶å †ï¼ˆæˆ–æœ€å°å †ï¼‰**ï¼šæ¯ä¸ªçˆ¶èŠ‚ç‚¹çš„å€¼éƒ½å°äºæˆ–ç­‰äºå…¶å­èŠ‚ç‚¹çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ**æœ€å°çš„å…ƒç´ æ°¸è¿œåœ¨æ ‘çš„é¡¶ç«¯**ã€‚

### å †æ’åºçš„æ€è·¯æ˜¯ä»€ä¹ˆï¼Ÿ



å †æ’åºçš„æ€è·¯éå¸¸ç®€å•ï¼Œä¸»è¦åˆ†ä¸ºä¸¤æ­¥ï¼š

1. **æ„å»ºå¤§é¡¶å †**ï¼šæŠŠå¾…æ’åºçš„æ•°ç»„å˜æˆä¸€ä¸ªå¤§é¡¶å †ã€‚è¿™æ ·ä¸€æ¥ï¼Œæ•°ç»„ä¸­æœ€å¤§çš„å…ƒç´ å°±è·‘åˆ°æ•°ç»„çš„ç¬¬ä¸€ä¸ªä½ç½®äº†ã€‚
2. **æ’åº**ï¼š
   - æŠŠæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆæœ€å¤§çš„ï¼‰å’Œæœ€åä¸€ä¸ªå…ƒç´ äº¤æ¢ä½ç½®ã€‚è¿™æ ·ï¼Œæœ€å¤§çš„å…ƒç´ å°±è¢«æ”¾åˆ°æ•°ç»„çš„æœ«å°¾äº†ã€‚
   - æ­¤æ—¶ï¼Œæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ å·²ç»æ’å¥½åºäº†ï¼Œæˆ‘ä»¬ä¸å†ç†ä¼šå®ƒï¼Œåªå¯¹å‰©ä¸‹çš„ nâˆ’1 ä¸ªå…ƒç´ é‡æ–°è°ƒæ•´ï¼Œè®©å®ƒä»¬å†æ¬¡æˆä¸ºä¸€ä¸ªå¤§é¡¶å †ã€‚
   - é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰çš„å…ƒç´ éƒ½æ’å¥½åºã€‚

ç®€å•æ¥è¯´ï¼Œå †æ’åºå°±æ˜¯**ä¸æ–­åœ°æŠŠæœ€å¤§çš„å…ƒç´ â€œæâ€å‡ºæ¥ï¼Œæ”¾åˆ°æ•°ç»„çš„æœ«å°¾ï¼Œç„¶åå¯¹å‰©ä¸‹çš„å…ƒç´ é‡å¤è¿™ä¸ªè¿‡ç¨‹**ã€‚

------



### å †æ’åºçš„ä¾‹å­



å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæ•°ç»„ `[4, 1, 3, 2]`ï¼Œæˆ‘ä»¬æƒ³ç”¨å †æ’åºæŠŠå®ƒä»å°åˆ°å¤§æ’åºã€‚



#### **ç¬¬ä¸€æ­¥ï¼šæ„å»ºå¤§é¡¶å †**



æˆ‘ä»¬å°†æ•°ç»„ `[4, 1, 3, 2]` è½¬åŒ–ä¸ºå¤§é¡¶å †ï¼Œ**ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹**ï¼Œä¾æ¬¡å‘ä¸Šè°ƒæ•´ã€‚

- **åˆå§‹çŠ¶æ€**ï¼šæ•°ç»„å¯ä»¥çœ‹æˆä¸€æ£µæ ‘ï¼Œæ ¹èŠ‚ç‚¹æ˜¯ 4ã€‚
- **è°ƒæ•´**ï¼šä»å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹ 3 å¼€å§‹ï¼Œå®ƒçš„å­èŠ‚ç‚¹æ˜¯ 2ã€‚å› ä¸º 3 > 2ï¼Œä¸éœ€è¦è°ƒæ•´ã€‚
- **è°ƒæ•´**ï¼šåˆ°èŠ‚ç‚¹ 1ï¼Œå®ƒçš„å­èŠ‚ç‚¹æ˜¯ 3 å’Œ 2ã€‚å› ä¸º 3 > 1ï¼Œæ‰€ä»¥æŠŠ 1 å’Œ 3 äº¤æ¢ã€‚ç°åœ¨æ•°ç»„å˜æˆ `[4, 3, 1, 2]`ã€‚
- **è°ƒæ•´**ï¼šåˆ°èŠ‚ç‚¹ 4ï¼Œå®ƒçš„å­èŠ‚ç‚¹æ˜¯ 3 å’Œ 1ã€‚å› ä¸º 4 > 3ï¼Œä¸éœ€è¦è°ƒæ•´ã€‚
- æœ€ç»ˆï¼Œæˆ‘ä»¬å¾—åˆ°äº†ä¸€ä¸ªå¤§é¡¶å †ï¼Œå¯¹åº”çš„æ•°ç»„æ˜¯ `[4, 3, 1, 2]`ã€‚



#### **ç¬¬äºŒæ­¥ï¼šæ’åº**



1. **æŠŠæœ€å¤§çš„å…ƒç´ ï¼ˆ4ï¼‰å’Œæœ€åä¸€ä¸ªå…ƒç´ ï¼ˆ2ï¼‰äº¤æ¢**ã€‚æ•°ç»„å˜æˆ `[2, 3, 1, 4]`ã€‚
   - **ç°åœ¨ 4 å·²ç»æ’å¥½åºäº†**ã€‚
   - æˆ‘ä»¬åªå…³æ³¨ `[2, 3, 1]`ã€‚
2. **å¯¹å‰©ä¸‹çš„ `[2, 3, 1]` é‡æ–°è°ƒæ•´ä¸ºå¤§é¡¶å †**ã€‚
   - è°ƒæ•´åï¼Œæœ€å¤§çš„å…ƒç´  3 è·‘åˆ°æœ€å‰é¢ï¼Œæ•°ç»„å˜æˆ `[3, 2, 1]`ã€‚
   - æŠŠ 3 å’Œ 1 äº¤æ¢ã€‚æ•°ç»„å˜æˆ `[1, 2, 3, 4]`ã€‚
   - **ç°åœ¨ 3 å·²ç»æ’å¥½åºäº†**ã€‚
   - æˆ‘ä»¬åªå…³æ³¨ `[1, 2]`ã€‚
3. **å¯¹å‰©ä¸‹çš„ `[1, 2]` é‡æ–°è°ƒæ•´ä¸ºå¤§é¡¶å †**ã€‚
   - è°ƒæ•´åï¼Œæœ€å¤§çš„å…ƒç´  2 è·‘åˆ°æœ€å‰é¢ï¼Œæ•°ç»„å˜æˆ `[2, 1]`ã€‚
   - æŠŠ 2 å’Œ 1 äº¤æ¢ã€‚æ•°ç»„å˜æˆ `[1, 2, 3, 4]`ã€‚
   - **ç°åœ¨ 2 å·²ç»æ’å¥½åºäº†**ã€‚
   - æˆ‘ä»¬åªå…³æ³¨ `[1]`ã€‚
4. **åªå‰©ä¸€ä¸ªå…ƒç´  1ï¼Œå®ƒå¤©ç„¶å°±æ˜¯æ’å¥½åºçš„**ã€‚

è‡³æ­¤ï¼Œæ’åºå®Œæˆï¼Œæ•°ç»„å˜æˆäº† `[1, 2, 3, 4]`ã€‚

------



### å †æ’åºçš„ä¼˜ç¼ºç‚¹

#### **ä¼˜ç‚¹**

- **æ€§èƒ½ç¨³å®š**ï¼šä¸ç®¡æ•°ç»„æœ€åˆæ˜¯ä»€ä¹ˆæ ·å­ï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦æ€»æ˜¯ O(nlogn)ã€‚
- **ç©ºé—´åˆ©ç”¨ç‡é«˜**ï¼šå®ƒæ˜¯ä¸€ç§åŸåœ°æ’åºç®—æ³•ï¼Œåªéœ€è¦æå°‘çš„é¢å¤–ç©ºé—´ã€‚

#### **ç¼ºç‚¹**

- **ä¸å¤ªç¨³å®š**ï¼šå¦‚æœæ•°ç»„ä¸­æœ‰ç›¸åŒçš„å…ƒç´ ï¼Œæ’åºåå®ƒä»¬çš„ç›¸å¯¹ä½ç½®å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚
- **å®ç°ä¸Šæ¯”å¿«é€Ÿæ’åºæˆ–å½’å¹¶æ’åºå¤æ‚ä¸€äº›**ã€‚

### Example Code

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // Required for std::swap

/**
 * @brief Adjusts a subtree rooted at index i into a max-heap.
 *
 * This function assumes that the children of node i (if they exist)
 * are already max-heaps. It ensures that the node at index i
 * satisfies the max-heap property.
 *
 * @param arr The vector representing the heap.
 * @param n The current size of the heap (number of active elements).
 * @param i The index of the root of the subtree to be heapified.
 */
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // Left child's index
    int right = 2 * i + 2; // Right child's index

    // If left child is within the bounds of the heap and is larger than current largest
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    // If right child is within the bounds of the heap and is larger than current largest
    if (if (right < n && arr[right] > arr[largest])) {
        largest = right;
    }

    // If the largest element is not the root
    if (largest != i) {
        std::swap(arr[i], arr[largest]); // Swap the root with the largest child

        // Recursively heapify the affected sub-tree (where the swap occurred)
        heapify(arr, n, largest);
    }
}

/**
 * @brief Sorts a vector using the Heap Sort algorithm.
 *
 * Heap Sort works in two main phases:
 * 1. Building a max-heap from the input array.
 * 2. Repeatedly extracting the maximum element (root) and rebuilding the heap.
 *
 * @param arr The vector to be sorted.
 */
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // 1. Build a max-heap
    // Iterate from the last non-leaf node up to the root.
    // The last non-leaf node is at index n/2 - 1 in a 0-indexed array.
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // 2. Sort the array
    // Iterate from the last element down to the second element (index 1).
    for (int i = n - 1; i > 0; i--) {
        // Move current root (maximum element) to the end of the unsorted part
        std::swap(arr[0], arr[i]);

        // Call heapify on the reduced heap (excluding the already sorted elements).
        // The effective size of the heap is now 'i'.
        // The root (index 0) needs to be re-heapified.
        heapify(arr, i, 0);
    }
}

/**
 * @brief Prints the elements of a vector to the console.
 *
 * @param arr The vector to be printed.
 */
void printArray(const std::vector<int>& arr) {
    for (int x : arr) {
        std::cout << x << " ";
    }
    std::cout << std::endl;
}
/**
 * @brief Main function to demonstrate Heap Sort.
 */
int main() {
    std::vector<int> arr = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};

    std::cout << "Original array: ";
    printArray(arr);

    heapSort(arr);

    std::cout << "Sorted array: ";
    printArray(arr);

    return 0;
}
```

