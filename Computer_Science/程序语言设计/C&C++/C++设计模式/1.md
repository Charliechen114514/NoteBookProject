# C++中的设计模式1

## 继承和多态导论

### 类和对象

​	面向对象编程是一种将算法和算法所操作的数据组合成单个实体（称为对象）来构建程序的方法。大多数面向对象语言（包括  C++）都是基于类的。类是对象的定义  ‑ 它描述算法和数据、其格式以及与其他类的关系。对象是类的具体实例，即变量。对象有一个地址，即内存中的位置。类是用户定义的类型。通常，可以根据类提供的定义实例化任意数量的对象（某些类限制可以创建的对象数量，但这是例外，而不是常态）。

​	在  C++  中，类中包含的数据被组织为数据成员的集合，即不同类型的变量。算法被实现为函数（类的方法）。虽然没有语言要求类的数据成员应该与其方法的实现有某种相关性，但是当数据很好地封装在类中，并且方法与外部数据的交互有限时，这是良好设计的标志之一。

封装的概念是  C++ 类的核心 该语言允许我们控制哪些数据成员和方法是公共的 在类外部可见，哪些是内部的 对类来说是私有的。一个设计良好的类大部分或只有私有数据成员，而唯一的公共方法是那些表达类的公共接口所需的方法换句话说，就是类的作用。这个公共接口就像一个契约 类设计者承诺这个类提供某些特性和操作。类的私有数据和方法是实现的一部分，只要公共接口（我们所承诺的契约）仍然有效，它们就可以改变。

​	例如，下面的类表示一个有理数，并支持其公共接口所公开的增量运算：

```
class Rational {
    public:
    Rational& operator+=(const Rational& rhs);
};
```

​	**设计良好的类不会通过其公共接口暴露任何超出其必须暴露的实现细节。**实现不是合同的一部分，尽管记录的接口可能会对其施加一些限制。例如，如果我们承诺所有有理数在分子和面额中都不包含任何共同乘数，则加法应该包括取消它们的步骤。这将是私有成员函数的一个很好的用途。其他几个操作的实现将需要调用它，但类的客户端永远不需要调用它，因为每个有理数在暴露给调用者之前已经简化为最低项：

```
class Rational {
    public:
    Rational& operator+=(const Rational& rhs);
    private:
    long n_;    // numerator
    long d_;    // denominator
    void reduce();
};

Rational& Rational::operator+=(const Rational& rhs) {
    n_ = n_*rhs.d_ + rhs.n_*d_;
    d_ = d_*rhs.d_;
    reduce();
    return *this;
}

Rational a, b;
a += b;
```

​	类方法对数据成员具有特殊访问权限——它们可以访问类的私有数据。请注意此处类和对象之间的区别——operator+=() 是 Rational 类的方法，并在对象 a 上调用。但是，它也可以访问 b 对象的私有数据，因为 a 和 b 是同一类的对象。如果成员函数按名称引用类成员而没有任何附加限定符，则它将访问调用它的同一类的成员（我们可以通过编写 this->n_ 和 this->d_ 来明确说明）。访问同一类的另一个对象的成员需要指向该对象的指针或引用，但除此之外不受限制，就像我们尝试从非成员函数访问私有数据成员一样。顺便说一句，C++ 还支持 C 样式结构。但在 C++ 中，结构不仅限于数据成员的集合——它可以具有方法、公共和私有访问修饰符以及类所具有的任何其他内容。从语言的角度来看，类和结构之间的唯一区别是默认访问——在类中，所有成员和方法默认都是私有的，而在结构中则是公共的。除此之外，使用结构而不是类是一种惯例——传统上，结构用于 C 样式结构（在 C 中合法的结构）以及几乎 C 样式结构，例如，仅添加了构造函数的结构。当然，这个界限并不精确，而是每个项目或团队的编码风格和实践的问题。

​	除了我们看到的方法和数据成员之外，C++ 还支持静态数据和方法。静态方法与常规非成员函数非常相似 - 它不会在任何特定对象上调用，并且它访问任何类型的对象的唯一方法是通过其参数。但是，与非成员函数不同，**静态方法保留了对类的私有数据的特权访问。类本身是一种有用的方法，可以将算法和它们操作的数据组合在一起，并限制对某些数据的访问。但是，C++ 最强大的面向对象特性是继承和由此产生的类层次结构。**

### 继承和类层次结构

​	C++ 中的类层次结构具有双重用途。一方面，它们允许我们表达对象之间的关系。另一方面，它们允许我们从更简单的类型组合出更复杂的类型。这两种用途都是通过继承来实现的。
继承的概念是 C++ 使用类和对象的核心。继承允许我们将新类定义为现有类的扩展。当派生类从基类继承时，它以某种形式包含基类中的所有数据和算法，并添加一些自己的数据和算法。在 C++ 中，区分两种主要的继承类型（公共和私有）非常重要。

​	公共继承继承了类的公共接口。它还继承了实现——基类的数据成员也是派生类的一部分。但是，接口的继承是公共继承的区别——派生类将基类的公共成员函数作为其公共接口的一部分。请记住，公共接口就像一个契约——我们向类的客户端承诺，它支持某些操作、维护一些不变量并遵守指定的限制。通过从基类公开继承，我们将派生类绑定到相同的契约（以及契约的任何扩展，如果我们决定定义额外的公共接口）。因为派生类也尊重基类的接口契约，所以我们可以在代码中任何需要基类的地方使用派生类——我们不能使用接口的任何扩展（代码需要基类，我们不知道此时有任何扩展），但基类接口及其限制必须有效。这通常表示为 is-a 原则——派生类的实例也是基类的实例。

​	然而，我们在 C++ 中解释 is-a 关系的方式并不完全直观。例如，正方形是矩形吗？如果是，那么我们可以从 Rectangle 类派生 Square 类：

```
class Rectangle {
    public:
    double Length() const { return length_; }
    double Width() const { return width_; }
    ...
    private:
    double l_;
    double w_;
};
class Square : public Rectangle {
    ...
};
```

​	马上，似乎有些不对劲——派生类有两个数据成员用于表示尺寸，但实际上只需要一个。我们必须以某种方式强制它们始终相同。这似乎并不坏——Rectangle 类具有允许长度和宽度为任何正值的接口，而 Square 施加了额外的限制。但情况比这更糟——Rectangle 类有一个契约，允许用户使尺寸不同。这可能非常明确：

```
class Rectangle {
    public:
    void Scale(double sl, double sw) {    // Scale the dimensions
        length_ *= sl;
        width_ *= sw;
    }
    ...
};
```

​	现在，我们有一个公共方法，它允许我们扭曲矩形，改变其纵横比。与任何其他公共方法一样，它由派生类继承，因此现在 Square 类也有它。事实上，通过使用公共继承，我们断言 Square 对象可以在使用 Rectangle 对象的任何地方使用，甚至不知道它是否真的是 Square。显然，这是我们无法遵守的承诺——当我们的类层次结构的客户端试图改变正方形的纵横比时，我们无法做到。我们可以忽略调用或在运行时报告错误。无论哪种方式，我们都违反了基类提供的契约。**只有一个解决方案——在 C++ 中，正方形不是矩形（意思就是：我们正方形的API实际上跟矩形的API根本没法协调）**。请注意，矩形通常也不是正方形——如果我们从 Square 派生 Rectangle 类，Square 接口提供的契约可能包含任意数量的保证，我们无法维护这些保证。

​	类似地，如果鸟接口包含飞行，企鹅在 C++ 中就不是鸟。这种情况的正确设计通常包括一个更抽象的基类 Bird，它不会做出至少一个派生类无法实现的承诺（例如，Bird 对象不会保证它可以飞）。然后，我们创建基于中间类的类，例如 FlyingBird 和 FlightlessBird，它们派生自公共基类，并作为 Eagle 或 Penguin 等更具体类的基类。这里重要的一课是，企鹅在 C++ 中是否是鸟取决于我们如何定义什么是鸟，或者用 C++ 术语来说，Bird 类的公共接口是什么。

​	由于公共继承意味着 is-a 关系，因此该语言允许在同一层次结构中对不同类的引用和指针进行广泛的转换。首先，从指向派生类的指针到指向基类的指针的转换是隐式的（对于引用也是如此）.

```
class Base { ... };
class Derived : public Base { ... };
Derived* d = new Derived;
Base* b = d;    // Implicit conversion
```

​	这种转换始终有效，因为派生类的实例也是基类的实例。逆转换是可能的，但必须明确说明：

```
Base* b = new Derived; // *b 确实是 Derived
Derived* d = b; // 无法编译，不是隐式的
Derived* d = static_cast<Derived*>(b); // 显式转换
```

​	这种转换不是隐式的，原因是只有当基类指针确实指向派生对象时，它才有效（否则，行为未定义）。因此，程序员必须使用静态转换明确断言，通过程序逻辑或先前的测试或其他方式，可以知道这种转换是有效的。

​	C++ 中的另一种继承是私有继承。当私有继承时，派生类不会扩展基类的公共接口——所有基类方法在派生类中都变为私有的。任何公共接口都必须由派生类从头开始创建。没有假设派生类的对象可以代替基类的对象。派生类从基类获得的是实现细节——派生类可以使用方法和数据成员来实现自己的算法。因此，可以说私有继承实现了“具有”关系——派生对象包含基类的一个实例。因此，私有派生类与其基类的关系类似于类与其数据成员的关系。后一种实现技术称为组合——一个对象由任意数量的其他对象组成，这些对象都用作其数据成员。在没有任何理由不这样做的情况下，**组合应该优于私有继承。那么，使用私有继承的原因可能是什么呢？有几种可能性。**首先，在派生类中，可以借助 using 声明重新公开基类的一个公共成员函数：

```
class Container : private std::vector<int> {
    public:
    using std::vector<int>::size;
    ...
};
```

​	还有一种办法就是写一个函数暴露出去：

```
class Container {
    private:
    std::vector<int> v_;
    public:
    size_t size() const { return v_.size(); }
    ...
};
```

