# 操作系统八股文收集

## 进程和线程的区别

​	在**现代操作系统**中，进程是操作系统分配资源的最小单元，而线程更加轻量，是操作系统调度类调度的最小单元，换而言之，当我们创建一个进程的时候，我们往往分配给了操作系统层次的大部分资源，比如说文件系统的文件描述符抽象，网络套接字等等资源来使用；线程则更加细致，被认为是执行流的抽象。或者说：进程是一个独立的**工厂**。每个工厂都有自己的生产线、仓库、工人、设备等资源，彼此独立运行，那么线程就是其中的工人，工人有地方拿东西做事情，就是线程使用进程分配给执行流（线程）的资源干活。

| 特性       | 进程 (Process)                                               | 线程 (Thread)                                                |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **资源**   | 拥有独立的内存空间和系统资源（文件、设备等），是资源分配的基本单位。 | 共享进程的内存空间和大部分资源，但有独立的栈、程序计数器、寄存器等。是CPU调度的基本单位。 |
| **开销**   | 创建、销毁、切换开销大。                                     | 创建、销毁、切换开销小。                                     |
| **独立性** | 进程之间相互独立，一个进程崩溃通常不会影响其他进程。         | 线程共享进程资源，一个线程崩溃可能导致整个进程崩溃。         |
| **通信**   | 进程间通信（IPC）相对复杂，需要特定的机制（管道、消息队列、共享内存等）。 | 线程间通信相对简单，可以直接读写共享数据。                   |
| **并发**   | 多个进程可以实现并发执行。                                   | 多个线程可以在同一进程内实现并发执行。                       |

​	基于这个共识，我们可以聊一聊多进程和多线程了。

### 多进程or多线程

​	进程认为自己掌管了整台计算机，所以，它的隔离性非常强，完全可以自己干好自己的事情，将所有的请求归结到若干请求接口之后就可以猛猛做自己的事情，而代价就是，非常的吃资源，IPC也比较繁琐

​	线程是轻量级的，创建、销毁、切换的开销远小于进程。我们只需要把执行上下文压入结构体中就完事了，甚至Linux等操作系统本身就支持线程层次的切换。另外，因为是共享一个进程的资源，我们知道相互的通信非常的容易，不需要IPC等复杂的机制。这种轻量的代价就是我们编写比较麻烦，稳定性不好，同步复杂。

### 什么时候用线程？什么时候用进程？

#### 什么时候用进程：

- **需要高稳定性：** 当一个子任务的失败不能影响整个应用程序时，例如Web服务器中的Nginx，每个请求可以由一个独立的Worker进程处理，即使一个Worker进程崩溃，其他Worker进程仍然可以继续服务。
- **需要独立资源：** 当任务需要独立的内存空间和系统资源，或者需要严格隔离时。
- **涉及大量计算且相互独立的任务：** 比如运行不同的独立应用程序，或者进行大型数据分析，每个分析任务可以作为独立进程。
- **分布式系统：** 不同的服务部署在不同的进程中，通过网络进行通信。

#### 什么时候用线程：

- **需要频繁创建和销毁任务：** 线程的创建和销毁开销小，适合任务粒度较小且数量多的场景，例如线程池。
- **需要高并发和共享数据：** 当任务之间需要频繁通信和共享数据时，线程可以避免复杂的IPC机制，提高效率。
- **I/O密集型任务：** 当程序中有大量I/O操作（如网络请求、文件读写、数据库访问）时，线程可以使CPU在等待I/O的同时执行其他任务，提高效率。
- **CPU密集型任务：** 在多核CPU上，多线程可以充分利用多核优势，让不同线程在不同CPU核心上并行执行。但需要注意线程数量不宜过多，以免造成过多的上下文切换开销。

**总结：**

- **进程适合** 独立性强、稳定性要求高、资源隔离性要求高的场景。
- **线程适合** 任务间协作频繁、需要共享数据、对性能和并发要求高的场景。

## 进程和线程的同步方法

### 进程同步方法

#### 管道

pipe就是一个经典的进程同步方法，其

- 匿名管道通常用于父子进程之间单向通信，生命周期随进程。这个一般是我们直接用pipe创建出来的进程内队列，我们随后使用Fork类型的API创建子进程，这个进程树内的进程一并使用管道进行相互的通信。
- **命名管道 (Named Pipe / FIFO)：** 可以在不相关进程间通信，通过文件系统中的特殊文件标识，支持双向通信

#### 消息队列

进程可以将格式化的数据放入消息队列中，其他进程可以从队列中读取。提供了缓冲机制，允许异步通信

#### 共享内存

​	我们特意修改进程的页表，让他们指向同一块物理内存，这个时候我们就实际上打穿了进程之间的隔离，在硬件层次就把问题解决了。

#### **信号 (Signal)：**

一种异步通信方式，用于通知进程发生了某个事件，可以携带少量信息。

#### **信号量 (Semaphore)：**

用于进程间的同步。它是一个计数器，用于控制对共享资源的访问。当资源可用时，信号量减一；当资源被释放时，信号量加一。

#### **套接字 (Socket)：**

可以用于同一台机器上不同进程间通信，也可以用于网络上不同机器间通信。支持客户端-服务器模式。

### 多线程同步方法：

多线程共享进程内存空间，因此同步主要是为了保护共享数据的访问：

#### **互斥锁 (Mutex / Lock)：**

- 最常用的同步机制。同一时间只允许一个线程访问共享资源，其他线程必须等待。

#### **读写锁 (Read-Write Lock)：**

- 允许多个线程同时读取共享资源，但只允许一个线程写入资源。读操作不互斥，写操作互斥，写和读也互斥。适用于读多写少的场景。

#### **条件变量 (Condition Variable)：**

- 通常与互斥锁一起使用。允许线程等待某个条件为真时才继续执行，或者在条件改变时通知其他等待的线程。

#### **信号量 (Semaphore)：**

- 与进程间的信号量类似，用于控制对共享资源的并发访问数量。

#### **原子操作 (Atomic Operations)：**

- 针对特定变量类型（如整型）的无锁操作，通过硬件指令保证操作的原子性，避免竞态条件。

#### **屏障 (Barrier)：**

- 允许一组线程在达到某个公共点之前等待，当所有线程都达到这个点时，它们才一起继续执行。

## 进程的空间地址模型

​	进程的出现就是为了屏蔽底层硬件，操作系统向上给以进程形式运行的可执行文件一个虚拟的环境，这样看来：它使得每个进程都认为自己拥有独立的、完整的内存空间，尽管物理内存可能被多个进程共享。

​	当然，这样来看虚拟地址空间被排布成了如下的格式：

1. **代码段 (Text Segment / Code Segment)：**
   - 存放可执行程序的机器指令。这部分通常是只读的，防止程序运行时修改自身指令。
2. **数据段 (Data Segment)：**
   - 存放已初始化的全局变量和静态变量。
3. **BSS段 (Block Started by Symbol Segment)：**
   - 存放未初始化的全局变量和静态变量。在程序加载时，系统会将其初始化为零。
4. **堆 (Heap)：**
   - 用于动态内存分配。程序运行时，通过`malloc`、`new`等函数申请的内存就在堆中。堆从低地址向高地址增长。
5. **栈 (Stack)：**
   - 用于存放局部变量、函数参数、返回地址等。每次函数调用都会在栈上创建一个栈帧。栈从高地址向低地址增长。
6. **命令行参数和环境变量区域：**
   - 存放程序启动时传入的命令行参数和环境变量。
7. **内核空间 (Kernel Space)：**
   - 这部分地址空间是所有进程共享的，用于存放操作系统内核的代码和数据。用户进程无法直接访问内核空间，需要通过系统调用（陷入内核态）才能与内核交互。

```
+--------------------------+  高地址 (0xFFFFFFFF)
|       内核空间         |
|                          |
|                          |
+--------------------------+
|  命令行参数和环境变量  |
+--------------------------+
|         栈 (Stack)       |  (由高地址向低地址增长)
|        ...               |
+--------------------------+
|                          |
|         堆 (Heap)        |  (由低地址向高地址增长)
|        ...               |
+--------------------------+
|         BSS段            |  (未初始化全局/静态变量)
+--------------------------+
|         数据段           |  (已初始化全局/静态变量)
+--------------------------+
|         代码段           |  (可执行指令)
+--------------------------+  低地址 (0x00000000)
```

## 说一说进程的状态转化关系？



1. **创建 (New / Created)：**
   - 进程/线程刚刚被创建，操作系统为它分配资源，但尚未被调度执行。
2. **就绪 (Ready)：**
   - 进程/线程已经准备好运行，所有必要的资源都已分配，只等待CPU被调度执行。
3. **运行 (Running)：**
   - 进程/线程正在CPU上执行其指令。在单核CPU上，任何给定时刻只有一个进程/线程处于运行状态。在多核CPU上，可以有多个进程/线程同时处于运行状态。
4. **阻塞 (Blocked / Waiting)：**
   - 进程/线程正在等待某个事件的发生才能继续执行，例如等待I/O操作完成、等待获取锁、等待某个信号量、等待用户输入等。当等待的事件发生时，它会从阻塞状态转换为就绪状态。
5. **终止 (Terminated / Dead)：**
   - 进程/线程执行完毕或被异常终止，操作系统会回收其占用的资源。

```
       +--------------+
       |    创建      |
       +------+-------+
              |
              V
       +--------------+
       |    就绪      |<----------+
       +------+-------+           |
              |                   | 事件发生 (I/O完成、获取锁、信号)
              V                   |
       +--------------+           |
  调度 |    运行      |-----------+
       +------+-------+
              |    |
              |    V
              |  +--------------+
              |  |    阻塞      |  (等待I/O, 等待锁, sleep等)
              |  +--------------+
              V
       +--------------+
       |    终止      |
       +--------------+
```



## 所以，进程何时转向阻塞，又何时转向就绪呢？

#### 阻塞：

1. 第一个就是我们的耗时，非CPU密集的操作发生的时候，我们就会yield CPU，CPU会将这个线程置于阻塞状态，转而去执行其他就绪的进程/线程。当I/O操作完成时，该进程/线程会从阻塞状态变为就绪状态。
2. 当进程/线程需要获取某个共享资源（如锁、信号量），而该资源当前不可用时，它会被阻塞，直到资源被释放。
3. **等待事件：** 当进程/线程需要等待某个特定事件（如子进程结束、特定消息到达）发生时，它会进入阻塞状态。
4. **睡眠/延时：** 进程/线程主动调用`sleep()`或类似的延时函数时，也会进入阻塞状态，直到延时时间到达。
5. 页面置换：当进程访问的内存页不在物理内存中时，会触发页面置换，导致进程阻塞等待页面从磁盘加载。

#### 就绪

- **创建完成：** 进程/线程创建完成后，一旦资源分配完毕，就会进入就绪状态。（创建转向就绪）
- **阻塞解除：** 当进程/线程等待的事件发生（I/O完成、获得资源、等待时间结束等）时，它会从阻塞状态转变为就绪状态。
- **时间片用完：** 运行中的进程/线程的时间片用完后，会被操作系统剥夺CPU，从而从运行状态转变为就绪状态，等待下一次调度。
- **更高优先级进程抢占：** 当有更高优先级的进程/线程变为就绪状态时，当前运行的低优先级进程/线程可能会被剥夺CPU，进入就绪状态。

## 父子进程

在类Unix系统中，新的进程通常是通过现有进程的**fork**系统调用创建的。调用`fork()`的进程称为**父进程 (Parent Process)**，新创建的进程称为**子进程 (Child Process)**。

- **继承与复制：** 当父进程调用`fork()`时，子进程会**复制**父进程的几乎所有资源，包括：
  - 进程的虚拟地址空间（代码、数据、堆、栈等，通常采用**写时拷贝 (Copy-on-Write, CoW)** 机制，即只有在父子进程各自修改数据时，才会真正复制一份数据，否则共享同一份物理内存）。
  - 文件描述符（子进程会继承父进程打开的所有文件描述符）。
  - 信号处理设置。
  - 当前工作目录等。
- **生命周期：** 子进程是一个独立的进程，有自己的PID (Process ID)。子进程的生命周期可以独立于父进程，它可以在父进程之前或之后结束。
- **父子关系维护：** 操作系统维护着父子进程之间的关系，例如，当子进程终止时，会向父进程发送`SIGCHLD`信号。父进程通常需要通过`wait()`或`waitpid()`系统调用来回收子进程的资源（包括其退出状态），避免产生**僵尸进程 (Zombie Process)**。
- **孤儿进程：** 如果父进程在子进程之前终止，那么子进程就变成了**孤儿进程 (Orphan Process)**。在类Unix系统中，孤儿进程通常会被**init进程**（PID为1的进程，系统中的所有进程的祖先）“收养”，并由init进程来回收其资源。



| 特性         | 父进程                                              | 子进程                                                       |
| ------------ | --------------------------------------------------- | ------------------------------------------------------------ |
| **创建方式** | 调用`fork()`系统调用的进程。                        | 由`fork()`系统调用新创建的进程。                             |
| **PID**      | 拥有自己的PID。                                     | 拥有独立的PID，与父进程不同。                                |
| **PPID**     | 自己的PID是子进程的PPID (Parent Process ID)。       | 继承父进程的PID作为自己的PPID。                              |
| **资源**     | 拥有自己的资源副本，`fork()`后与子进程共享（CoW）。 | 复制父进程的资源，大部分最初是共享（CoW）的。                |
| **执行流**   | 从`fork()`调用点继续执行，`fork()`返回子进程的PID。 | 从`fork()`调用点继续执行，`fork()`返回0。                    |
| **退出**     | 正常退出或异常终止，需`wait()`子进程。              | 正常退出或异常终止，会成为僵尸进程直到被父进程回收（或被`init`收养）。 |

示例场景：

在Unix/Linux中，shell在执行用户命令时，通常会创建一个子进程来执行该命令，而shell自身作为父进程等待子进程的完成。这种模型保证了命令的执行不会影响到shell的稳定性。

## 进程上下文 + 中断上下文

在操作系统中，**上下文 (Context)** 是指CPU在执行某个任务时所需要的所有信息，包括CPU寄存器、程序计数器、栈指针等。当CPU从一个任务切换到另一个任务时，需要保存当前任务的上下文并加载新任务的上下文，这个过程称为**上下文切换 (Context Switch)**。

#### 进程上下文

**进程上下文**是指CPU在执行用户进程时所需要的全部信息。它包括：

- **用户空间上下文：** 程序的代码、数据、堆、栈等用户态可见的内存区域。
- **寄存器上下文：** CPU的通用寄存器、程序计数器(PC)、栈指针(SP)等。
- **系统空间上下文（内核态上下文）：** 进程在内核态的执行状态，包括内核栈、内核状态的寄存器值等。当进程通过系统调用从用户态切换到内核态时，会使用这部分上下文。
- **页表信息：** 用于将进程的虚拟地址映射到物理地址的页表。

**进程上下文切换的时机：**

- **时间片用完：** 操作系统调度器剥夺当前运行进程的CPU。
- **进程主动阻塞：** 进程执行I/O操作、等待锁、调用`sleep()`等，主动放弃CPU。
- **更高优先级进程就绪：** 操作系统调度更高优先级的进程运行。
- **系统调用：** 进程从用户态进入内核态，虽然仍是同一进程，但CPU执行模式和上下文环境发生变化。

#### 中断上下文 (Interrupt Context)：

**中断上下文**是指CPU在响应硬件中断时所需要的环境信息。当一个硬件中断发生时，CPU会暂停当前正在执行的进程（或内核代码），保存当前状态，然后跳转到中断服务程序 (ISR) 执行。

**中断上下文主要包括：**

- **被中断进程的寄存器状态：** 包括程序计数器、栈指针以及其他通用寄存器，这些是中断发生时CPU正在执行的指令所依赖的状态。
- **中断服务程序执行所需的内核栈：** 中断处理程序通常在内核态执行，并有自己的内核栈。

**中断上下文与进程上下文的区别：**

- **用户态资源：** 中断上下文切换不涉及进程的用户态资源（如虚拟内存、用户栈、全局变量等）的保存和恢复。它只关注在内核态执行中断服务程序所需的状态。
- **优先级：** 中断处理通常比进程调度有更高的优先级。中断会打断当前进程或内核代码的执行，因此中断上下文切换不会与进程上下文切换同时发生。
- **执行时间：** 为了快速响应硬件事件，中断服务程序通常设计得尽可能短小精悍，以减少对正常进程执行的干扰。

## 一个进程可以创建多少线程，和什么有关



一个进程可以创建的线程数量没有一个固定的绝对值，它受多种因素的限制：

1. **系统虚拟内存空间大小：**
   - **32位系统：** 进程的虚拟地址空间通常为4GB，其中约2GB或3GB是用户态空间。每个线程都需要分配一个独立的栈空间（默认通常为几MB到十几MB，例如Linux上默认为8MB或10MB）。如果每个线程的栈空间较大，那么可创建的线程数就会受到虚拟内存的限制。例如，3GB用户空间，每个线程栈10MB，理论上最多只能创建300个左右的线程。
   - **64位系统：** 64位系统的虚拟地址空间非常大（理论上达到128TB或更高），通常不会受到虚拟内存大小的直接限制。
2. **系统资源限制：**
   - **`/proc/sys/kernel/threads-max`：** 这是Linux系统级别的参数，表示整个系统支持的最大线程数。即使单个进程的虚拟内存足够，也可能受到系统总线程数的限制。
   - **`ulimit -s` (stack size)：** 用户可以设置单个线程的栈空间大小。减小栈空间可以增加可创建的线程数量，但可能会导致栈溢出。
   - **文件描述符限制：** 某些系统可能将线程看作一种特殊的文件描述符，从而受文件描述符上限的限制。
   - **其他系统资源：** 例如，CPU的核心数量、物理内存大小、以及内核为每个线程维护的控制块等，都会间接影响可创建的线程数量。过多的线程会增加内核的调度开销，降低系统性能。
3. **应用程序设计和性能要求：**
   - **任务类型：** 对于CPU密集型任务，线程数通常不宜超过CPU核心数，否则会增加上下文切换开销。对于I/O密集型任务，线程数可以适当多于CPU核心数，因为线程在等待I/O时会释放CPU。
   - **并发模型：** 线程池等并发模型会限制并发线程的数量以优化性能。

总结：

在32位系统上，一个进程能创建的线程数主要受限于进程的虚拟内存空间大小，特别是每个线程所需的栈空间。

在64位系统上，一个进程能创建的线程数更多地受限于系统级别参数、可用物理内存和系统性能（如调度器开销）。

实际应用中，通常不会创建成千上万个线程，因为过多的线程会导致：

- **频繁的上下文切换：** 增加CPU开销。
- **内存消耗：** 即使64位系统虚拟内存大，物理内存仍然有限。
- **调度器负担：** 操作系统调度大量线程的开销会增加。
- **同步复杂性：** 更多的线程意味着更复杂的同步问题。

因此，通常会根据CPU核心数、任务类型和系统负载来合理设置线程数量，例如使用线程池来管理线程，避免无限制地创建线程。

